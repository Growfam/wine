/**
 * api.js - –®–≤–∏–¥–∫–∏–π —ñ –Ω–∞–¥—ñ–π–Ω–∏–π API –º–æ–¥—É–ª—å –¥–ª—è WINIX
 * –í–ò–ü–†–ê–í–õ–ï–ù–ê –≤–µ—Ä—Å—ñ—è –∑ —É—Å—ñ–º–∞ –Ω–µ–æ–±—Ö—ñ–¥–Ω–∏–º–∏ –º–µ—Ç–æ–¥–∞–º–∏
 */

class WinixAPI {
    constructor() {
        this.baseURL = this.detectBaseURL();
        this.requestQueue = new Map();
        this.retryQueue = new Set();
        this.interceptors = { request: [], response: [] };

        // Performance tracking
        this.metrics = {
            requests: 0,
            errors: 0,
            avgResponseTime: 0,
            cache_hits: 0
        };

        // Request deduplication
        this.pendingRequests = new Map();

        // Circuit breaker pattern
        this.circuitBreaker = {
            failures: 0,
            threshold: 5,
            timeout: 30000,
            state: 'CLOSED' // CLOSED, OPEN, HALF_OPEN
        };

        this.initializeInterceptors();
    }

    detectBaseURL() {
        const hostname = window.location.hostname;

        if (hostname === 'localhost' || hostname === '127.0.0.1') {
            return `http://${hostname}:8080`;
        }

        return 'https://winixbot.com';
    }

    initializeInterceptors() {
        // Request interceptor - –¥–æ–¥–∞—î auth headers
        this.addRequestInterceptor((config) => {
            const token = this.getAuthToken();
            const userId = this.getUserId();

            if (token) {
                config.headers = config.headers || {};
                config.headers['Authorization'] = `Bearer ${token}`;
            }

            if (userId) {
                config.headers = config.headers || {};
                config.headers['X-Telegram-User-Id'] = userId;
            }

            return config;
        });

        // Response interceptor - –æ–±—Ä–æ–±–ª—è—î –ø–æ–º–∏–ª–∫–∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü—ñ—ó
        this.addResponseInterceptor(
            (response) => response,
            async (error) => {
                // –í–ò–ü–†–ê–í–õ–ï–ù–û: –ö—Ä–∞—â—è –æ–±—Ä–æ–±–∫–∞ –ø–æ–º–∏–ª–æ–∫ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü—ñ—ó
                if (error.status === 401 || (error.status === 400 && error.config?.url?.includes('refresh-token'))) {
                    console.warn('üîÑ API: –¢–æ–∫–µ–Ω –Ω–µ–¥—ñ–π—Å–Ω–∏–π, —Å–ø—Ä–æ–±–∞ –ø–æ–≤–Ω–æ—ó –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü—ñ—ó...');

                    try {
                        // –û—á–∏—â–∞—î–º–æ –Ω–µ–¥—ñ–π—Å–Ω–∏–π —Ç–æ–∫–µ–Ω
                        localStorage.removeItem('auth_token');

                        // –°–ø—Ä–æ–±—É—î–º–æ –ø–æ–≤–Ω—É –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü—ñ—é
                        const newTokenResponse = await this.performFullAuth();

                        if (newTokenResponse && newTokenResponse.token) {
                            // –ü–æ–≤—Ç–æ—Ä—é—î–º–æ –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–∏–π –∑–∞–ø–∏—Ç –∑ –Ω–æ–≤–∏–º —Ç–æ–∫–µ–Ω–æ–º
                            if (error.config && !error.config.url?.includes('refresh-token')) {
                                error.config.headers = error.config.headers || {};
                                error.config.headers['Authorization'] = `Bearer ${newTokenResponse.token}`;
                                return this.retry(error.config);
                            }

                            return newTokenResponse;
                        }
                    } catch (authError) {
                        console.error('‚ùå API: –ü–æ–≤–Ω–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü—ñ—è –Ω–µ –≤–¥–∞–ª–∞—Å—è:', authError);
                        window.WinixState?.emit('authError', authError);
                    }
                }

                return Promise.reject(error);
            }
        );
    }

    // ==================== –ì–û–õ–û–í–ù–Ü API –ú–ï–¢–û–î–ò ====================

    /**
     * –û—Å–Ω–æ–≤–Ω–∏–π –º–µ—Ç–æ–¥ –¥–ª—è API –∑–∞–ø–∏—Ç—ñ–≤ (–ø–æ—Ç—Ä—ñ–±–µ–Ω –¥–ª—è auth.js)
     * @param {string} endpoint - API endpoint
     * @param {string} method - HTTP –º–µ—Ç–æ–¥
     * @param {Object} data - –î–∞–Ω—ñ –¥–ª—è –≤—ñ–¥–ø—Ä–∞–≤–∫–∏
     * @param {Object} options - –î–æ–¥–∞—Ç–∫–æ–≤—ñ –æ–ø—Ü—ñ—ó
     */
    async apiRequest(endpoint, method = 'GET', data = null, options = {}) {
        const config = {
            method: method.toUpperCase(),
            headers: { 'Content-Type': 'application/json' },
            timeout: options.timeout || 10000,
            cache: options.cache !== false,
            optimistic: options.optimistic || false,
            suppressErrors: options.suppressErrors || false,
            ...options
        };

        // –î–æ–¥–∞—î–º–æ body –¥–ª—è POST/PUT –∑–∞–ø–∏—Ç—ñ–≤
        if (data && ['POST', 'PUT', 'PATCH'].includes(config.method)) {
            config.body = JSON.stringify(data);
        }

        // –û—á–∏—â–∞—î–º–æ endpoint –≤—ñ–¥ –∑–∞–π–≤–∏—Ö —Å–ª–µ—à—ñ–≤
        const cleanEndpoint = endpoint.replace(/^\/+/, '').replace(/^api\/+/, '');

        try {
            const response = await this.request(cleanEndpoint, config);
            return response;
        } catch (error) {
            if (!config.suppressErrors) {
                console.error(`API Request Error [${method} ${endpoint}]:`, error);
                window.WinixState?.emit('apiError', error);
            }
            throw error;
        }
    }

    /**
     * –û–Ω–æ–≤–ª–µ–Ω–Ω—è –±–∞–ª–∞–Ω—Å—É (–ø–æ—Ç—Ä—ñ–±–µ–Ω –¥–ª—è state.js)
     */
    async refreshBalance() {
        try {
            const response = await this.getBalance();

            if (response && response.status === 'success' && response.data) {
                // –û–Ω–æ–≤–ª—é—î–º–æ state
                if (window.WinixState) {
                    if (response.data.balance !== undefined) {
                        window.WinixState.balance = response.data.balance;
                    }
                    if (response.data.coins !== undefined) {
                        window.WinixState.coins = response.data.coins;
                    }
                }

                // –û–Ω–æ–≤–ª—é—î–º–æ localStorage
                if (response.data.balance !== undefined) {
                    localStorage.setItem('userTokens', response.data.balance.toString());
                }
                if (response.data.coins !== undefined) {
                    localStorage.setItem('userCoins', response.data.coins.toString());
                }
            }

            return response;
        } catch (error) {
            console.warn('Refresh balance failed:', error);
            throw error;
        }
    }

    /**
     * –û—á–∏—â–µ–Ω–Ω—è –∫–µ—à—É
     */
    clearCache() {
        if (window.WinixState && window.WinixState.cache) {
            window.WinixState.cache.clear();
        }

        // –û—á–∏—â–∞—î–º–æ pending requests
        this.pendingRequests.clear();

        console.log('API cache cleared');
    }

    // ==================== –í–ù–£–¢–†–Ü–®–ù–Ü –ú–ï–¢–û–î–ò ====================

    // Smart request deduplication
    async request(endpoint, options = {}) {
        const config = {
            method: 'GET',
            headers: { 'Content-Type': 'application/json' },
            timeout: 10000,
            cache: true,
            optimistic: false,
            ...options
        };

        // Create request key for deduplication
        const requestKey = this.createRequestKey(endpoint, config);

        // Check for pending identical request
        if (this.pendingRequests.has(requestKey)) {
            return this.pendingRequests.get(requestKey);
        }

        // Check circuit breaker
        if (!this.isCircuitBreakerOpen()) {
            const promise = this.executeRequest(endpoint, config);
            this.pendingRequests.set(requestKey, promise);

            promise.finally(() => {
                this.pendingRequests.delete(requestKey);
            });

            return promise;
        } else {
            throw new Error('Circuit breaker is open');
        }
    }

    async executeRequest(endpoint, config) {
        const startTime = performance.now();
        this.metrics.requests++;

        try {
            // Apply request interceptors
            config = await this.applyRequestInterceptors(config);

            // Check cache first
            if (config.cache && config.method === 'GET') {
                const cached = window.WinixState?.getCache(endpoint);
                if (cached) {
                    this.metrics.cache_hits++;
                    return cached;
                }
            }

            // Optimistic update
            if (config.optimistic && window.WinixState) {
                this.handleOptimisticUpdate(endpoint, config);
            }

            // Execute request
            const response = await this.fetchWithTimeout(
                `${this.baseURL}/api/${endpoint.replace(/^\/+/, '')}`,
                config
            );

            // Handle response
            const result = await this.handleResponse(response, config);

            // Update metrics
            const responseTime = performance.now() - startTime;
            this.updateMetrics(responseTime, true);

            // Cache successful GET requests
            if (config.cache && config.method === 'GET' && result.status === 'success') {
                window.WinixState?.setCache(endpoint, result, config.cacheTTL);
            }

            // Update state
            this.updateStateFromResponse(endpoint, result, config);

            return result;

        } catch (error) {
            this.updateMetrics(performance.now() - startTime, false);
            this.handleCircuitBreaker(error);

            // Apply response interceptors
            throw await this.applyResponseInterceptors(null, error);
        }
    }

    // Optimistic updates –¥–ª—è instant UI
    handleOptimisticUpdate(endpoint, config) {
        if (endpoint.includes('balance') && config.method === 'POST') {
            const amount = config.body?.amount || 0;
            const currentCoins = window.WinixState?.coins || 0;

            // Instantly update UI
            window.WinixState?.optimisticUpdate('coins', currentCoins + amount, 'apiError');
        }

        if (endpoint.includes('staking') && config.method === 'POST') {
            window.WinixState?.optimisticUpdate('loading', false);
            window.showNotification?.('–°—Ç–µ–π–∫—ñ–Ω–≥ —Å—Ç–≤–æ—Ä—é—î—Ç—å—Å—è...', false);
        }
    }

    // Smart state updates
    updateStateFromResponse(endpoint, result, config) {
        if (!window.WinixState || result.status !== 'success') return;

        const data = result.data;

        // User data updates
        if (endpoint.includes('user/') && !endpoint.includes('balance')) {
            if (data.telegram_id) window.WinixState.user = data;
            if (data.balance !== undefined) window.WinixState.balance = data.balance;
            if (data.coins !== undefined) window.WinixState.coins = data.coins;
        }

        // Balance specific updates
        if (endpoint.includes('balance')) {
            if (data.coins !== undefined) window.WinixState.coins = data.coins;
            if (data.balance !== undefined) window.WinixState.balance = data.balance;
        }

        // Staking updates
        if (endpoint.includes('staking')) {
            window.WinixState.emit('stakingUpdated', data);
        }
    }

    async fetchWithTimeout(url, config) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), config.timeout);

        try {
            const response = await fetch(url, {
                ...config,
                signal: controller.signal
            });

            clearTimeout(timeoutId);
            return response;
        } catch (error) {
            clearTimeout(timeoutId);
            throw error;
        }
    }

    async handleResponse(response, config) {
        if (!response.ok) {
            const errorData = await response.text();
            let errorMessage;

            try {
                const errorJson = JSON.parse(errorData);
                errorMessage = errorJson.message || `HTTP ${response.status}`;
            } catch {
                errorMessage = `HTTP ${response.status}`;
            }

            const error = new Error(errorMessage);
            error.status = response.status;
            error.config = config;
            throw error;
        }

        return await response.json();
    }

    // Circuit breaker implementation
    isCircuitBreakerOpen() {
        return this.circuitBreaker.state === 'OPEN' &&
               Date.now() < this.circuitBreaker.nextAttempt;
    }

    handleCircuitBreaker(error) {
        if (error.name === 'AbortError' || error.status >= 500) {
            this.circuitBreaker.failures++;

            if (this.circuitBreaker.failures >= this.circuitBreaker.threshold) {
                this.circuitBreaker.state = 'OPEN';
                this.circuitBreaker.nextAttempt = Date.now() + this.circuitBreaker.timeout;

                window.WinixState?.emit('circuitBreakerOpen');
                console.warn('üî¥ API Circuit Breaker OPEN');
            }
        }
    }

    updateMetrics(responseTime, success) {
        if (success) {
            this.circuitBreaker.failures = 0;
            this.circuitBreaker.state = 'CLOSED';
        } else {
            this.metrics.errors++;
        }

        // Moving average for response time
        this.metrics.avgResponseTime =
            (this.metrics.avgResponseTime * 0.9) + (responseTime * 0.1);
    }

    // Interceptors
    addRequestInterceptor(interceptor) {
        this.interceptors.request.push(interceptor);
    }

    addResponseInterceptor(success, error) {
        this.interceptors.response.push({ success, error });
    }

    async applyRequestInterceptors(config) {
        for (const interceptor of this.interceptors.request) {
            config = await interceptor(config);
        }
        return config;
    }

    async applyResponseInterceptors(response, error) {
        for (const { success, error: errorHandler } of this.interceptors.response) {
            if (error && errorHandler) {
                try {
                    return await errorHandler(error);
                } catch (e) {
                    error = e;
                }
            } else if (response && success) {
                response = await success(response);
            }
        }

        if (error) throw error;
        return response;
    }

    createRequestKey(endpoint, config) {
        return `${config.method}:${endpoint}:${JSON.stringify(config.body || {})}`;
    }

    // ==================== HIGH-LEVEL API –ú–ï–¢–û–î–ò ====================

    /**
     * –û—Ç—Ä–∏–º–∞–Ω–Ω—è –¥–∞–Ω–∏—Ö –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
     */
    async getUserData(forceRefresh = false) {
        const userId = this.getUserId();
        if (!userId) throw new Error('No user ID');

        return this.apiRequest(`user/${userId}`, 'GET', null, {
            cache: !forceRefresh,
            cacheTTL: 300000 // 5 minutes
        });
    }

    /**
     * –û—Ç—Ä–∏–º–∞–Ω–Ω—è –±–∞–ª–∞–Ω—Å—É
     */
    async getBalance() {
        const userId = this.getUserId();
        if (!userId) throw new Error('No user ID');

        return this.apiRequest(`user/${userId}/balance`, 'GET', null, {
            cache: true,
            cacheTTL: 30000 // 30 seconds
        });
    }

    /**
     * –û–Ω–æ–≤–ª–µ–Ω–Ω—è –±–∞–ª–∞–Ω—Å—É
     */
    async updateBalance(amount, operation = 'add') {
        const userId = this.getUserId();
        if (!userId) throw new Error('No user ID');

        return this.apiRequest(`user/${userId}/balance`, 'POST', { amount, operation }, {
            optimistic: true,
            cache: false
        });
    }

    /**
     * –°—Ç–≤–æ—Ä–µ–Ω–Ω—è —Å—Ç–µ–π–∫—ñ–Ω–≥—É
     */
    async createStaking(amount, period) {
        const userId = this.getUserId();
        if (!userId) throw new Error('No user ID');

        return this.apiRequest(`user/${userId}/staking`, 'POST', { stakingAmount: amount, period }, {
            cache: false
        });
    }

    /**
     * –û–Ω–æ–≤–ª–µ–Ω–Ω—è —Ç–æ–∫–µ–Ω–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü—ñ—ó (–í–ò–ü–†–ê–í–õ–ï–ù–û)
     */
    async refreshToken() {
        const userId = this.getUserId();
        if (!userId) {
            throw new Error('No user ID for token refresh');
        }

        try {
            // –í–ò–ü–†–ê–í–õ–ï–ù–û: –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –ø—Ä–∞–≤–∏–ª—å–Ω–∏–π —Ñ–æ—Ä–º–∞—Ç –∑–∞–ø–∏—Ç—É
            const config = {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Telegram-User-Id': userId  // –î–æ–¥–∞—î–º–æ –∑–∞–≥–æ–ª–æ–≤–æ–∫
                },
                timeout: 10000,
                cache: false,
                suppressErrors: false  // –î–æ–∑–≤–æ–ª—è—î–º–æ –æ–±—Ä–æ–±–∫—É –ø–æ–º–∏–ª–æ–∫
            };

            // –í—ñ–¥–ø—Ä–∞–≤–ª—è—î–º–æ –∑–∞–ø–∏—Ç –∑ telegram_id –≤ —Ç—ñ–ª—ñ + –∑–∞–≥–æ–ª–æ–≤–∫—É
            const response = await this.executeRequest('auth/refresh-token', {
                ...config,
                body: JSON.stringify({ telegram_id: userId })
            });

            if (response && response.status === 'success' && response.token) {
                localStorage.setItem('auth_token', response.token);
                window.WinixState?.emit('tokenRefreshed', response.token);
                console.log('‚úÖ –¢–æ–∫–µ–Ω —É—Å–ø—ñ—à–Ω–æ –æ–Ω–æ–≤–ª–µ–Ω–æ');
                return response;
            } else {
                throw new Error(response?.message || '–ù–µ–≤–¥–∞–ª–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥—å —Å–µ—Ä–≤–µ—Ä–∞');
            }

        } catch (error) {
            console.warn('‚ö†Ô∏è –ü–æ–º–∏–ª–∫–∞ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è —Ç–æ–∫–µ–Ω—É:', error);

            // –Ø–∫—â–æ —Ç–æ–∫–µ–Ω –Ω–µ–¥—ñ–π—Å–Ω–∏–π, –æ—á–∏—â–∞—î–º–æ –π–æ–≥–æ —ñ –ø–æ—Ç—Ä–µ–±—É—î–º–æ –ø–æ–≤—Ç–æ—Ä–Ω–æ—ó –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü—ñ—ó
            if (error.status === 400 || error.status === 401) {
                localStorage.removeItem('auth_token');
                window.WinixState?.emit('authRequired');

                // –°–ø—Ä–æ–±—É—î–º–æ —Å—Ç–≤–æ—Ä–∏—Ç–∏ –Ω–æ–≤–∏–π —á–µ—Ä–µ–∑ –ø–æ–≤–Ω—É –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü—ñ—é
                return this.performFullAuth();
            }

            throw error;
        }
    }

    /**
     * –ù–û–í–ò–ô: –ü–æ–≤–Ω–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü—ñ—è –∫–æ–ª–∏ —Ç–æ–∫–µ–Ω –Ω–µ–¥—ñ–π—Å–Ω–∏–π
     */
    async performFullAuth() {
        try {
            const userId = this.getUserId();
            if (!userId) {
                throw new Error('No user ID for full auth');
            }

            // –û—Ç—Ä–∏–º—É—î–º–æ –¥–∞–Ω—ñ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –∑ Telegram
            const telegramData = this.extractTelegramData();

            console.log('üîÑ –í–∏–∫–æ–Ω–∞–Ω–Ω—è –ø–æ–≤–Ω–æ—ó –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü—ñ—ó...');

            const response = await this.apiRequest('auth', 'POST', telegramData, {
                cache: false,
                suppressErrors: false
            });

            if (response && response.status === 'success' && response.token) {
                localStorage.setItem('auth_token', response.token);
                window.WinixState?.emit('tokenRefreshed', response.token);
                console.log('‚úÖ –ü–æ–≤–Ω–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü—ñ—è —É—Å–ø—ñ—à–Ω–∞');
                return response;
            } else {
                throw new Error('–ü–æ–≤–Ω–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü—ñ—è –Ω–µ –≤–¥–∞–ª–∞—Å—è');
            }

        } catch (error) {
            console.error('‚ùå –ü–æ–≤–Ω–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü—ñ—è –Ω–µ –≤–¥–∞–ª–∞—Å—è:', error);
            throw new Error('–ù–µ –≤–¥–∞–ª–æ—Å—è –∞–≤—Ç–æ—Ä–∏–∑—É–≤–∞—Ç–∏—Å—è. –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç—ñ—Ç—å –¥–æ–¥–∞—Ç–æ–∫ —á–µ—Ä–µ–∑ Telegram.');
        }
    }

    /**
     * –ù–û–í–ò–ô: –í–∏—Ç—è–≥—É–≤–∞–Ω–Ω—è –¥–∞–Ω–∏—Ö –∑ Telegram WebApp
     */
    extractTelegramData() {
        const tg = window.Telegram?.WebApp;
        if (!tg || !tg.initDataUnsafe?.user) {
            throw new Error('Telegram WebApp data not available');
        }

        const user = tg.initDataUnsafe.user;
        return {
            id: user.id,
            telegram_id: user.id.toString(),
            username: user.username,
            first_name: user.first_name,
            last_name: user.last_name,
            language_code: user.language_code,
            initData: tg.initData,  // –î–æ–¥–∞—î–º–æ initData –¥–ª—è –≤–∞–ª—ñ–¥–∞—Ü—ñ—ó
            from_telegram: true
        };
    }

    /**
     * –û–Ω–æ–≤–ª–µ–Ω–Ω—è –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω—å –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
     */
    async updateSettings(settings) {
        const userId = this.getUserId();
        if (!userId) throw new Error('No user ID');

        return this.apiRequest(`user/${userId}/settings`, 'POST', settings, {
            cache: false
        });
    }

    // ==================== UTILITY –ú–ï–¢–û–î–ò ====================

    getUserId() {
        return window.Telegram?.WebApp?.initDataUnsafe?.user?.id?.toString() ||
               localStorage.getItem('telegram_user_id');
    }

    getAuthToken() {
        return localStorage.getItem('auth_token');
    }

    async retry(config) {
        return this.executeRequest(config.endpoint, config);
    }

    // Performance monitoring
    getMetrics() {
        return {
            ...this.metrics,
            circuitBreaker: this.circuitBreaker.state,
            pendingRequests: this.pendingRequests.size
        };
    }
}

// Initialize global instance
window.WinixAPI = new WinixAPI();

// Auto-connect with state manager
if (window.WinixState) {
    window.WinixAPI.addResponseInterceptor(
        (response) => {
            window.WinixState.connected = true;
            return response;
        },
        (error) => {
            if (error.name === 'TypeError') {
                window.WinixState.connected = false;
            }
            throw error;
        }
    );
}

console.log('‚úÖ WinixAPI: –í–∏–ø—Ä–∞–≤–ª–µ–Ω–∏–π API –º–æ–¥—É–ª—å —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–æ–≤–∞–Ω–æ');