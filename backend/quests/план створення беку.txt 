# ğŸ—ï¸ WINIX Backend - Ğ”ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ğ° Ğ°Ñ€Ñ…Ñ–Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ° ÑĞ¸ÑÑ‚ĞµĞ¼Ğ¸ Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½ÑŒ

## ğŸ“‹ Ğ—Ğ°Ğ³Ğ°Ğ»ÑŒĞ½Ğ° ÑÑ…ĞµĞ¼Ğ° Ğ°Ñ€Ñ…Ñ–Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ¸

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        CLIENT LAYER                             â”‚
â”‚     (Web App, Mobile App, Desktop App, Telegram Bot)           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚ HTTP/HTTPS, WebSocket
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      API GATEWAY                                â”‚
â”‚                    (Flask Application)                          â”‚
â”‚                       main.py                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚   Logger    â”‚ â”‚Rate Limiter â”‚ â”‚  Security   â”‚               â”‚
â”‚  â”‚ Middleware  â”‚ â”‚ Middleware  â”‚ â”‚ Middleware  â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  WINIX QUESTS SYSTEM                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚    ROUTES       â”‚ â”‚  CONTROLLERS    â”‚ â”‚    SERVICES     â”‚   â”‚
â”‚  â”‚                 â”‚ â”‚                 â”‚ â”‚                 â”‚   â”‚
â”‚  â”‚  API Endpoints  â”‚ â”‚ Business Logic  â”‚ â”‚  Core Services  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚     MODELS      â”‚ â”‚     UTILS       â”‚ â”‚    VALIDATORS   â”‚   â”‚
â”‚  â”‚                 â”‚ â”‚                 â”‚ â”‚                 â”‚   â”‚
â”‚  â”‚  Data Models    â”‚ â”‚   Helpers       â”‚ â”‚   Validation    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    DATABASE LAYER                               â”‚
â”‚                  (Supabase Client)                              â”‚
â”‚              supabase_client.py                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  EXTERNAL SERVICES                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚  â”‚  Supabase   â”‚ â”‚  Telegram   â”‚ â”‚    TON      â”‚               â”‚
â”‚  â”‚  Database   â”‚ â”‚  Bot API    â”‚ â”‚ Blockchain  â”‚               â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ¯ ĞÑ€Ñ…Ñ–Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ½Ñ– ÑˆĞ°Ñ€Ğ¸ Ñ‚Ğ° Ñ—Ñ… Ğ²Ğ·Ğ°Ñ”Ğ¼Ğ¾Ğ´Ñ–Ñ—

### 1. **ROUTES LAYER** - HTTP API Endpoints
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ROUTES LAYER                             â”‚
â”‚                                                             â”‚
â”‚ auth_routes.py     â†’ ĞĞ²Ñ‚Ğ¾Ñ€Ğ¸Ğ·Ğ°Ñ†Ñ–Ñ Ñ‚Ğ° JWT Ñ‚Ğ¾ĞºĞµĞ½Ğ¸             â”‚
â”‚ user_routes.py     â†’ Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»Ñ–Ğ½Ğ½Ñ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ°Ğ¼Ğ¸              â”‚
â”‚ daily_routes.py    â†’ Ğ©Ğ¾Ğ´ĞµĞ½Ğ½Ñ– Ğ±Ğ¾Ğ½ÑƒÑĞ¸                        â”‚
â”‚ flex_routes.py     â†’ FLEX Ñ‚Ğ¾ĞºĞµĞ½Ğ¸ Ñ‚Ğ° Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ¸              â”‚
â”‚ tasks_routes.py    â†’ Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½ÑŒ                        â”‚
â”‚ wallet_routes.py   â†’ TON Ğ³Ğ°Ğ¼Ğ°Ğ½Ñ†Ñ–                           â”‚
â”‚ transaction_routes.py â†’ Ğ¤Ñ–Ğ½Ğ°Ğ½ÑĞ¾Ğ²Ñ– Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ñ–Ñ—                 â”‚
â”‚ analytics_routes.py â†’ ĞĞ½Ğ°Ğ»Ñ–Ñ‚Ğ¸ĞºĞ° Ñ‚Ğ° Ğ¼ĞµÑ‚Ñ€Ğ¸ĞºĞ¸                 â”‚
â”‚                                                             â”‚
â”‚ Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ:                                          â”‚
â”‚ â€¢ HTTP Ğ·Ğ°Ğ¿Ğ¸Ñ‚Ğ¸/Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ñ–                                    â”‚
â”‚ â€¢ Ğ’Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ Ğ²Ñ…Ñ–Ğ´Ğ½Ğ¸Ñ… Ğ´Ğ°Ğ½Ğ¸Ñ…                                  â”‚
â”‚ â€¢ Rate limiting                                            â”‚
â”‚ â€¢ Security Ğ´ĞµĞºĞ¾Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ¸                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 CONTROLLERS LAYER                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. **CONTROLLERS LAYER** - Ğ‘Ñ–Ğ·Ğ½ĞµÑ-Ğ»Ğ¾Ğ³Ñ–ĞºĞ° ĞºĞ¾Ğ¾Ñ€Ğ´Ğ¸Ğ½Ğ°Ñ†Ñ–Ñ
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                CONTROLLERS LAYER                            â”‚
â”‚                                                             â”‚
â”‚ AuthController        â†’ Telegram WebApp Ğ²Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ          â”‚
â”‚ UserController        â†’ ĞŸÑ€Ğ¾Ñ„Ñ–Ğ»Ñ– Ñ‚Ğ° Ğ±Ğ°Ğ»Ğ°Ğ½ÑĞ¸                 â”‚
â”‚ DailyController       â†’ Ğ©Ğ¾Ğ´ĞµĞ½Ğ½Ñ– Ğ±Ğ¾Ğ½ÑƒÑĞ¸ + Transaction Srv   â”‚
â”‚ FlexController        â†’ FLEX Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ¸ + TON Ñ–Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ñ–Ñ   â”‚
â”‚ TasksController       â†’ Ğ—Ğ°Ğ²Ğ´Ğ°Ğ½Ğ½Ñ + Ğ²ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ             â”‚
â”‚ WalletController      â†’ TON Ğ³Ğ°Ğ¼Ğ°Ğ½Ñ†Ñ– + Ğ±Ğ¾Ğ½ÑƒÑĞ¸               â”‚
â”‚ TransactionController â†’ Ğ¦ĞµĞ½Ñ‚Ñ€Ğ°Ğ»Ñ–Ğ·Ğ¾Ğ²Ğ°Ğ½Ñ– Ñ„Ñ–Ğ½Ğ°Ğ½ÑĞ¸             â”‚
â”‚ AnalyticsController   â†’ ĞĞ½Ğ°Ğ»Ñ–Ñ‚Ğ¸Ñ‡Ğ½Ñ– Ğ¿Ğ¾Ğ´Ñ–Ñ—                  â”‚
â”‚                                                             â”‚
â”‚ ĞŸĞ°Ñ‚Ñ‚ĞµÑ€Ğ½ Ğ²Ğ·Ğ°Ñ”Ğ¼Ğ¾Ğ´Ñ–Ñ—:                                         â”‚
â”‚ Controller â†’ Services â†’ Models â†’ Database                  â”‚
â”‚ Controller â†’ Analytics (async logging)                     â”‚
â”‚ Controller â†’ Transaction Service (atomic operations)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  SERVICES LAYER                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3. **SERVICES LAYER** - Domain Services
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SERVICES LAYER                           â”‚
â”‚                                                             â”‚
â”‚ RewardCalculator     â†’ Ğ Ğ¾Ğ·Ñ€Ğ°Ñ…ÑƒĞ½ĞºĞ¸ Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´               â”‚
â”‚ TelegramService      â†’ Telegram Bot API Ñ–Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ñ–Ñ        â”‚
â”‚ TONConnectService    â†’ TON Blockchain Ñ–Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ñ–Ñ          â”‚
â”‚ TransactionService   â†’ ĞÑ‚Ğ¾Ğ¼Ğ°Ñ€Ğ½Ñ– Ñ„Ñ–Ğ½Ğ°Ğ½ÑĞ¾Ğ²Ñ– Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ñ–Ñ—        â”‚
â”‚ VerificationService  â†’ Ğ’ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ ÑĞ¾Ñ†Ñ–Ğ°Ğ»ÑŒĞ½Ğ¸Ñ… Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½ÑŒ     â”‚
â”‚                                                             â”‚
â”‚ ĞšĞ»ÑÑ‡Ğ¾Ğ²Ñ– Ğ¾ÑĞ¾Ğ±Ğ»Ğ¸Ğ²Ğ¾ÑÑ‚Ñ–:                                       â”‚
â”‚ â€¢ ĞÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ğ° Ğ¾Ğ±Ñ€Ğ¾Ğ±ĞºĞ°                                       â”‚
â”‚ â€¢ Retry Ğ»Ğ¾Ğ³Ñ–ĞºĞ° Ğ´Ğ»Ñ Ğ·Ğ¾Ğ²Ğ½Ñ–ÑˆĞ½Ñ–Ñ… API                          â”‚
â”‚ â€¢ ĞšĞµÑˆÑƒĞ²Ğ°Ğ½Ğ½Ñ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ–Ğ²                                    â”‚
â”‚ â€¢ Fallback Ğ¼ĞµÑ…Ğ°Ğ½Ñ–Ğ·Ğ¼Ğ¸                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   MODELS LAYER                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4. **MODELS LAYER** - Data Access
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     MODELS LAYER                            â”‚
â”‚                                                             â”‚
â”‚ UserQuest        â†’ ĞšĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ñ–, Ğ±Ğ°Ğ»Ğ°Ğ½ÑĞ¸, ÑÑ‚Ğ°Ñ‚ÑƒÑĞ¸          â”‚
â”‚ DailyBonus       â†’ Ğ©Ğ¾Ğ´ĞµĞ½Ğ½Ñ– Ğ±Ğ¾Ğ½ÑƒÑĞ¸, ÑĞµÑ€Ñ–Ñ—                  â”‚
â”‚ FlexRewards      â†’ FLEX Ñ‚Ğ¾ĞºĞµĞ½Ğ¸, Ñ€Ñ–Ğ²Ğ½Ñ– Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´           â”‚
â”‚ Task             â†’ Ğ—Ğ°Ğ²Ğ´Ğ°Ğ½Ğ½Ñ, Ñ‚Ğ¸Ğ¿Ğ¸, Ğ¿Ğ»Ğ°Ñ‚Ñ„Ğ¾Ñ€Ğ¼Ğ¸              â”‚
â”‚ Transaction      â†’ Ğ¤Ñ–Ğ½Ğ°Ğ½ÑĞ¾Ğ²Ñ– Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ñ–Ñ—, Ñ–ÑÑ‚Ğ¾Ñ€Ñ–Ñ            â”‚
â”‚ Wallet           â†’ TON Ğ³Ğ°Ğ¼Ğ°Ğ½Ñ†Ñ–, Ğ¿Ñ–Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ½Ñ               â”‚
â”‚ Analytics        â†’ ĞŸĞ¾Ğ´Ñ–Ñ—, ÑĞµÑÑ–Ñ—, ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°               â”‚
â”‚                                                             â”‚
â”‚ Data Flow:                                                  â”‚
â”‚ Models â†” Supabase Client â†” PostgreSQL Database            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”„ Ğ”ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ñ– Ğ²Ğ·Ğ°Ñ”Ğ¼Ğ¾Ğ´Ñ–Ñ— Ğ¼Ñ–Ğ¶ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ğ°Ğ¼Ğ¸

### ğŸ’° Transaction Service - Ğ¦ĞµĞ½Ñ‚Ñ€Ğ°Ğ»ÑŒĞ½Ğ¸Ğ¹ HUB Ñ„Ñ–Ğ½Ğ°Ğ½ÑĞ¾Ğ²Ğ¸Ñ… Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ñ–Ğ¹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              TRANSACTION SERVICE ECOSYSTEM                  â”‚
â”‚                                                             â”‚
â”‚                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚
â”‚                 â”‚ Transaction     â”‚                        â”‚
â”‚                 â”‚ Service         â”‚                        â”‚
â”‚                 â”‚ (Core Hub)      â”‚                        â”‚
â”‚                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚
â”‚                          â”‚                                  â”‚
â”‚        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚
â”‚        â”‚                 â”‚                 â”‚               â”‚
â”‚        â–¼                 â–¼                 â–¼               â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚ â”‚   Daily     â”‚ â”‚    FLEX     â”‚ â”‚   Tasks     â”‚          â”‚
â”‚ â”‚ Controller  â”‚ â”‚ Controller  â”‚ â”‚ Controller  â”‚          â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚        â”‚                 â”‚                 â”‚               â”‚
â”‚        â–¼                 â–¼                 â–¼               â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚ â”‚   Wallet    â”‚ â”‚    User     â”‚ â”‚ Analytics   â”‚          â”‚
â”‚ â”‚ Controller  â”‚ â”‚ Controller  â”‚ â”‚ Events      â”‚          â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                                             â”‚
â”‚ Ğ’ÑÑ– Ñ„Ñ–Ğ½Ğ°Ğ½ÑĞ¾Ğ²Ñ– Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ñ–Ñ— Ğ¿Ñ€Ğ¾Ñ…Ğ¾Ğ´ÑÑ‚ÑŒ Ñ‡ĞµÑ€ĞµĞ· Transaction Service â”‚
â”‚ Ğ—Ğ°Ğ±ĞµĞ·Ğ¿ĞµÑ‡ÑƒÑ”: Ğ°Ñ‚Ğ¾Ğ¼Ğ°Ñ€Ğ½Ñ–ÑÑ‚ÑŒ, Ğ°ÑƒĞ´Ğ¸Ñ‚, ĞºĞ¾Ğ½ÑĞ¸ÑÑ‚ĞµĞ½Ñ‚Ğ½Ñ–ÑÑ‚ÑŒ           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ¯ Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½ÑŒ - Ğ”ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ğ¸Ğ¹ flow

```
1. Ğ¡Ğ¢Ğ’ĞĞ Ğ•ĞĞĞ¯ Ğ—ĞĞ’Ğ”ĞĞĞĞ¯ (Admin Panel)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ TasksController.create_task()           â”‚
â”‚ â†“                                       â”‚
â”‚ TaskModel.create_task()                 â”‚
â”‚ â†“                                       â”‚
â”‚ Supabase: INSERT into tasks            â”‚
â”‚ â†“                                       â”‚
â”‚ Analytics: log_task_created_event()     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

2. ĞĞ¢Ğ Ğ˜ĞœĞĞĞĞ¯ Ğ¡ĞŸĞ˜Ğ¡ĞšĞ£ Ğ—ĞĞ’Ğ”ĞĞĞ¬
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ GET /api/tasks/list/{telegram_id}       â”‚
â”‚ â†“                                       â”‚
â”‚ TasksController.get_tasks_list()        â”‚
â”‚ â†“                                       â”‚
â”‚ TaskModel.get_available_tasks()         â”‚
â”‚ â†“                                       â”‚
â”‚ UserQuest.get_completed_tasks()         â”‚
â”‚ â†“                                       â”‚
â”‚ Filter + Merge (available - completed)  â”‚
â”‚ â†“                                       â”‚
â”‚ Response: List[TaskWithStatus]          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

3. ĞŸĞĞ§ĞĞ¢ĞĞš Ğ’Ğ˜ĞšĞĞĞĞĞĞ¯ Ğ—ĞĞ’Ğ”ĞĞĞĞ¯
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ POST /api/tasks/start/{id}/{task_id}    â”‚
â”‚ â†“                                       â”‚
â”‚ TasksController.start_task()            â”‚
â”‚ â†“                                       â”‚
â”‚ Validation: task exists, not completed  â”‚
â”‚ â†“                                       â”‚
â”‚ TaskModel.update_task_progress()        â”‚
â”‚ â†“                                       â”‚
â”‚ VerificationService.schedule_check()    â”‚
â”‚ â†“                                       â”‚
â”‚ Analytics: log_task_started_event()     â”‚
â”‚ â†“                                       â”‚
â”‚ Response: {status: "started", timer: X} â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

4. Ğ’Ğ•Ğ Ğ˜Ğ¤Ğ†ĞšĞĞ¦Ğ†Ğ¯ Ğ—ĞĞ’Ğ”ĞĞĞĞ¯
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ POST /api/tasks/verify/{id}/{task_id}   â”‚
â”‚ â†“                                       â”‚
â”‚ TasksController.verify_task()           â”‚
â”‚ â†“                                       â”‚
â”‚ VerificationService.verify_completion() â”‚
â”‚ â”œâ”€ Telegram: check_subscription()       â”‚
â”‚ â”œâ”€ YouTube: check_subscription()        â”‚
â”‚ â”œâ”€ Twitter: check_follow()              â”‚
â”‚ â””â”€ Discord: check_membership()          â”‚
â”‚ â†“                                       â”‚
â”‚ IF verified = True:                     â”‚
â”‚   â”œâ”€ TaskModel.mark_completed()         â”‚
â”‚   â”œâ”€ TransactionService.process_reward()â”‚
â”‚   â””â”€ Analytics: log_task_completed()    â”‚
â”‚ ELSE:                                   â”‚
â”‚   â””â”€ Return verification_failed         â”‚
â”‚ â†“                                       â”‚
â”‚ Response: {verified, reward_given}      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ Ğ©Ğ¾Ğ´ĞµĞ½Ğ½Ñ– Ğ±Ğ¾Ğ½ÑƒÑĞ¸ - ĞŸĞ¾Ğ²Ğ½Ğ¸Ğ¹ lifecycle

```
1. ĞŸĞ•Ğ Ğ•Ğ’Ğ†Ğ ĞšĞ Ğ¡Ğ¢ĞĞ¢Ğ£Ğ¡Ğ£
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ GET /api/daily/status/{telegram_id}     â”‚
â”‚ â†“                                       â”‚
â”‚ DailyController.get_daily_status()      â”‚
â”‚ â†“                                       â”‚
â”‚ DailyBonusManager.get_user_status()     â”‚
â”‚ â†“                                       â”‚
â”‚ Calculate: can_claim, next_claim_time   â”‚
â”‚ â†“                                       â”‚
â”‚ RewardCalculator.preview_reward()       â”‚
â”‚ â†“                                       â”‚
â”‚ Response: {                             â”‚
â”‚   current_day: 5,                       â”‚
â”‚   current_streak: 5,                    â”‚
â”‚   can_claim: true,                      â”‚
â”‚   next_reward: {winix: 20, tickets: 0}, â”‚
â”‚   time_until_next: 0                    â”‚
â”‚ }                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

2. ĞĞ¢Ğ Ğ˜ĞœĞĞĞĞ¯ Ğ‘ĞĞĞ£Ğ¡Ğ£
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ POST /api/daily/claim/{telegram_id}     â”‚
â”‚ â†“                                       â”‚
â”‚ DailyController.claim_daily_bonus()     â”‚
â”‚ â†“                                       â”‚
â”‚ Validation:                             â”‚
â”‚ â”œâ”€ User exists                          â”‚
â”‚ â”œâ”€ Can claim (20+ hours passed)         â”‚
â”‚ â””â”€ Not already claimed today            â”‚
â”‚ â†“                                       â”‚
â”‚ RewardCalculator.calculate_reward()     â”‚
â”‚ â”œâ”€ Base reward: 20 WINIX                â”‚
â”‚ â”œâ”€ Day multipliers (7,14,21,30)         â”‚
â”‚ â”œâ”€ Streak bonuses                       â”‚
â”‚ â””â”€ Special day tickets                  â”‚
â”‚ â†“                                       â”‚
â”‚ TransactionService.process_daily_bonus()â”‚
â”‚ â”œâ”€ Create transaction record            â”‚
â”‚ â”œâ”€ Update user balance (atomic)         â”‚
â”‚ â”œâ”€ Update daily_bonus_status            â”‚
â”‚ â””â”€ Create daily_bonus_entry             â”‚
â”‚ â†“                                       â”‚
â”‚ Analytics.log_daily_bonus_claimed()     â”‚
â”‚ â†“                                       â”‚
â”‚ Response: {                             â”‚
â”‚   success: true,                        â”‚
â”‚   reward: {winix: 40, tickets: 1},      â”‚
â”‚   new_balance: {winix: 1250, ...},      â”‚
â”‚   next_claim_in: "20:15:30"             â”‚
â”‚ }                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

3. Ğ ĞĞ—Ğ ĞĞ¥Ğ£ĞĞĞš Ğ’Ğ˜ĞĞĞ“ĞĞ ĞĞ” (RewardCalculator)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ calculate_daily_bonus(day, streak, lvl) â”‚
â”‚ â†“                                       â”‚
â”‚ Base calculation:                       â”‚
â”‚ â”œâ”€ base_winix = 20                      â”‚
â”‚ â”œâ”€ tickets = 0                          â”‚
â”‚ â””â”€ multiplier = 1.0                     â”‚
â”‚ â†“                                       â”‚
â”‚ Apply day-specific rules:               â”‚
â”‚ â”œâ”€ Day 7:  multiplier = 2.0, +1 ticket â”‚
â”‚ â”œâ”€ Day 14: multiplier = 2.5, +2 ticketsâ”‚
â”‚ â”œâ”€ Day 21: multiplier = 3.0, +3 ticketsâ”‚
â”‚ â””â”€ Day 30: multiplier = 5.0, +10 ticketsâ”‚
â”‚ â†“                                       â”‚
â”‚ Apply streak bonus:                     â”‚
â”‚ â”œâ”€ 7+ days:  +10% WINIX                 â”‚
â”‚ â”œâ”€ 14+ days: +20% WINIX                 â”‚
â”‚ â””â”€ 21+ days: +30% WINIX                 â”‚
â”‚ â†“                                       â”‚
â”‚ Apply user level bonus:                 â”‚
â”‚ â””â”€ level > 1: +5% per level             â”‚
â”‚ â†“                                       â”‚
â”‚ Return: Reward(winix, tickets)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ’ FLEX Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° - TON Blockchain Ñ–Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ñ–Ñ

```
1. ĞŸĞ•Ğ Ğ•Ğ’Ğ†Ğ ĞšĞ FLEX Ğ‘ĞĞ›ĞĞĞ¡Ğ£
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ GET /api/flex/balance/{telegram_id}     â”‚
â”‚ â†“                                       â”‚
â”‚ FlexController.get_flex_balance()       â”‚
â”‚ â†“                                       â”‚
â”‚ UserQuest.get_wallet_address()          â”‚
â”‚ â†“                                       â”‚
â”‚ IF wallet_connected:                    â”‚
â”‚   â”œâ”€ TONConnectService.get_balance()    â”‚
â”‚   â”œâ”€ Cache: 5 min TTL                   â”‚
â”‚   â””â”€ FlexRewards.update_balance()       â”‚
â”‚ ELSE:                                   â”‚
â”‚   â””â”€ Return: wallet_not_connected       â”‚
â”‚ â†“                                       â”‚
â”‚ FlexRewards.calculate_available_levels()â”‚
â”‚ â†“                                       â”‚
â”‚ Response: {                             â”‚
â”‚   flex_balance: 75000,                  â”‚
â”‚   available_levels: ["Bronze","Silver"],â”‚
â”‚   can_claim: {                          â”‚
â”‚     "Bronze": true,                     â”‚
â”‚     "Silver": false                     â”‚
â”‚   }                                     â”‚
â”‚ }                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

2. ĞĞ¢Ğ Ğ˜ĞœĞĞĞĞ¯ FLEX Ğ’Ğ˜ĞĞĞ“ĞĞ ĞĞ”Ğ˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ POST /api/flex/claim/{telegram_id}      â”‚
â”‚ Body: {level: "Silver"}                 â”‚
â”‚ â†“                                       â”‚
â”‚ FlexController.claim_flex_reward()      â”‚
â”‚ â†“                                       â”‚
â”‚ Validation:                             â”‚
â”‚ â”œâ”€ Level exists in config               â”‚
â”‚ â”œâ”€ User has enough FLEX                 â”‚
â”‚ â”œâ”€ Cooldown expired (24h)               â”‚
â”‚ â””â”€ Not already claimed for this level   â”‚
â”‚ â†“                                       â”‚
â”‚ TONConnectService.verify_balance()      â”‚
â”‚ â”œâ”€ Real-time blockchain check           â”‚
â”‚ â””â”€ Confirm sufficient FLEX              â”‚
â”‚ â†“                                       â”‚
â”‚ FlexRewards.get_level_config()          â”‚
â”‚ â”œâ”€ Silver: 50,000 FLEX required         â”‚
â”‚ â””â”€ Reward: 75 WINIX + 2 tickets         â”‚
â”‚ â†“                                       â”‚
â”‚ TransactionService.process_flex_reward()â”‚
â”‚ â”œâ”€ Create FLEX transaction              â”‚
â”‚ â”œâ”€ Update balances                      â”‚
â”‚ â””â”€ Set cooldown timer                   â”‚
â”‚ â†“                                       â”‚
â”‚ FlexRewards.log_claim()                 â”‚
â”‚ â†“                                       â”‚
â”‚ Analytics.log_flex_claim_event()        â”‚
â”‚ â†“                                       â”‚
â”‚ Response: {                             â”‚
â”‚   claimed: true,                        â”‚
â”‚   level: "Silver",                      â”‚
â”‚   reward: {winix: 75, tickets: 2},      â”‚
â”‚   next_claim_in: "23:59:45"             â”‚
â”‚ }                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

3. FLEX Ğ Ğ†Ğ’ĞĞ† ĞšĞĞĞ¤Ğ†Ğ“Ğ£Ğ ĞĞ¦Ğ†Ğ¯
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ FLEX_LEVELS_CONFIG = {                  â”‚
â”‚   "Bronze": {                           â”‚
â”‚     required_flex: 10000,               â”‚
â”‚     reward_winix: 25,                   â”‚
â”‚     reward_tickets: 1                   â”‚
â”‚   },                                    â”‚
â”‚   "Silver": {                           â”‚
â”‚     required_flex: 50000,               â”‚
â”‚     reward_winix: 75,                   â”‚
â”‚     reward_tickets: 2                   â”‚
â”‚   },                                    â”‚
â”‚   "Gold": {                             â”‚
â”‚     required_flex: 100000,              â”‚
â”‚     reward_winix: 150,                  â”‚
â”‚     reward_tickets: 4                   â”‚
â”‚   },                                    â”‚
â”‚   "Platinum": {                         â”‚
â”‚     required_flex: 250000,              â”‚
â”‚     reward_winix: 300,                  â”‚
â”‚     reward_tickets: 8                   â”‚
â”‚   },                                    â”‚
â”‚   "Diamond": {                          â”‚
â”‚     required_flex: 500000,              â”‚
â”‚     reward_winix: 500,                  â”‚
â”‚     reward_tickets: 15                  â”‚
â”‚   }                                     â”‚
â”‚ }                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ’¼ TON Wallet Integration

```
1. ĞŸĞ†Ğ”ĞšĞ›Ğ®Ğ§Ğ•ĞĞĞ¯ Ğ“ĞĞœĞĞĞ¦Ğ¯
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ POST /api/wallet/connect/{telegram_id}  â”‚
â”‚ Body: {                                 â”‚
â”‚   address: "EQD...",                    â”‚
â”‚   provider: "TonKeeper",                â”‚
â”‚   signature: "..."                      â”‚
â”‚ }                                       â”‚
â”‚ â†“                                       â”‚
â”‚ WalletController.connect_wallet()       â”‚
â”‚ â†“                                       â”‚
â”‚ Validation:                             â”‚
â”‚ â”œâ”€ TONConnectService.validate_address() â”‚
â”‚ â”œâ”€ Signature verification               â”‚
â”‚ â””â”€ Provider compatibility check         â”‚
â”‚ â†“                                       â”‚
â”‚ WalletModel.create_connection()         â”‚
â”‚ â”œâ”€ Save wallet info                     â”‚
â”‚ â”œâ”€ Set status: connected                â”‚
â”‚ â””â”€ Record connection time               â”‚
â”‚ â†“                                       â”‚
â”‚ Check: first_connection_bonus           â”‚
â”‚ IF first_time:                          â”‚
â”‚   â”œâ”€ TransactionService.process_bonus() â”‚
â”‚   â””â”€ Reward: 100 WINIX + 5 tickets      â”‚
â”‚ â†“                                       â”‚
â”‚ TONConnectService.start_monitoring()    â”‚
â”‚ â”œâ”€ Periodic balance checks              â”‚
â”‚ â””â”€ Transaction monitoring               â”‚
â”‚ â†“                                       â”‚
â”‚ Analytics.log_wallet_connected()        â”‚
â”‚ â†“                                       â”‚
â”‚ Response: {                             â”‚
â”‚   connected: true,                      â”‚
â”‚   address: "EQD...",                    â”‚
â”‚   bonus_received: true,                 â”‚
â”‚   ton_balance: 1.5,                     â”‚
â”‚   flex_balance: 25000                   â”‚
â”‚ }                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

2. ĞœĞĞĞ†Ğ¢ĞĞ Ğ˜ĞĞ“ Ğ‘ĞĞ›ĞĞĞ¡Ğ†Ğ’
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ TONConnectService Background Process    â”‚
â”‚ â†“                                       â”‚
â”‚ Every 5 minutes:                        â”‚
â”‚ â”œâ”€ Get all connected wallets            â”‚
â”‚ â”œâ”€ Fetch TON balance                    â”‚
â”‚ â”œâ”€ Fetch FLEX balance                   â”‚
â”‚ â””â”€ Update cache                         â”‚
â”‚ â†“                                       â”‚
â”‚ Cache strategy:                         â”‚
â”‚ â”œâ”€ Memory: 1 min TTL                    â”‚
â”‚ â”œâ”€ Redis: 5 min TTL                     â”‚
â”‚ â””â”€ Database: 30 min update              â”‚
â”‚ â†“                                       â”‚
â”‚ On significant balance change:          â”‚
â”‚ â”œâ”€ Trigger FLEX level recalculation     â”‚
â”‚ â”œâ”€ Send notification (if enabled)       â”‚
â”‚ â””â”€ Log analytics event                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ” Security & Authentication Layer

### JWT Authentication Flow
```
1. TELEGRAM WEBAPP AUTHENTICATION
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Frontend: Telegram WebApp               â”‚
â”‚ â†“                                       â”‚
â”‚ initData = Telegram.WebApp.initData     â”‚
â”‚ â†“                                       â”‚
â”‚ POST /api/auth/validate-telegram        â”‚
â”‚ Body: {initData: "query_string..."}     â”‚
â”‚ â†“                                       â”‚
â”‚ AuthController.validate_telegram()      â”‚
â”‚ â†“                                       â”‚
â”‚ TelegramService.validate_webapp_data()  â”‚
â”‚ â”œâ”€ Parse query string                   â”‚
â”‚ â”œâ”€ Verify HMAC-SHA256 signature         â”‚
â”‚ â”œâ”€ Check timestamp (not older than 24h) â”‚
â”‚ â””â”€ Validate bot token                   â”‚
â”‚ â†“                                       â”‚
â”‚ UserQuest.get_or_create_user()          â”‚
â”‚ â”œâ”€ Get existing user OR                 â”‚
â”‚ â””â”€ Create new user with referral        â”‚
â”‚ â†“                                       â”‚
â”‚ JWT.generate_token()                    â”‚
â”‚ â”œâ”€ Payload: {user_id, telegram_id, exp} â”‚
â”‚ â”œâ”€ Sign with SECRET_KEY                 â”‚
â”‚ â””â”€ Set expiration: 7 days               â”‚
â”‚ â†“                                       â”‚
â”‚ Analytics.log_auth_success()            â”‚
â”‚ â†“                                       â”‚
â”‚ Response: {                             â”‚
â”‚   token: "eyJ0eXAiOiJKV1QiLCJhbGciOiJSâ”‚
â”‚   user: {id, username, balance, ...},   â”‚
â”‚   expires_in: 604800                    â”‚
â”‚ }                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

2. REQUEST AUTHORIZATION
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Frontend: API Request                   â”‚
â”‚ Header: Authorization: Bearer {token}   â”‚
â”‚ â†“                                       â”‚
â”‚ @require_auth decorator                 â”‚
â”‚ â†“                                       â”‚
â”‚ JWT.decode_token()                      â”‚
â”‚ â”œâ”€ Verify signature                     â”‚
â”‚ â”œâ”€ Check expiration                     â”‚
â”‚ â””â”€ Extract user data                    â”‚
â”‚ â†“                                       â”‚
â”‚ Rate Limiting Check:                    â”‚
â”‚ â”œâ”€ IP-based: 100 req/min               â”‚
â”‚ â”œâ”€ User-based: 50 req/min               â”‚
â”‚ â””â”€ Endpoint-based: varies               â”‚
â”‚ â†“                                       â”‚
â”‚ Security Validations:                   â”‚
â”‚ â”œâ”€ @validate_telegram_id                â”‚
â”‚ â”œâ”€ @validate_json                       â”‚
â”‚ â””â”€ @security_headers                    â”‚
â”‚ â†“                                       â”‚
â”‚ Controller function execution           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“Š Analytics & Monitoring System

### Event Tracking Architecture
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           ANALYTICS ECOSYSTEM           â”‚
â”‚                                         â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ Analytics       â”‚ â”‚ Metrics         â”‚ â”‚
â”‚ â”‚ Events          â”‚ â”‚ Collector       â”‚ â”‚
â”‚ â”‚                 â”‚ â”‚                 â”‚ â”‚
â”‚ â”‚ â€¢ User actions  â”‚ â”‚ â€¢ Performance   â”‚ â”‚
â”‚ â”‚ â€¢ System events â”‚ â”‚ â€¢ Health checks â”‚ â”‚
â”‚ â”‚ â€¢ Error logs    â”‚ â”‚ â€¢ Usage stats   â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚          â”‚                   â”‚          â”‚
â”‚          â–¼                   â–¼          â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚        Analytics Database           â”‚ â”‚
â”‚ â”‚                                     â”‚ â”‚
â”‚ â”‚ â€¢ analytics_events                  â”‚ â”‚
â”‚ â”‚ â€¢ user_analytics_stats              â”‚ â”‚
â”‚ â”‚ â€¢ user_sessions                     â”‚ â”‚
â”‚ â”‚ â€¢ system_metrics                    â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                    â”‚                    â”‚
â”‚                    â–¼                    â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚      Monitoring Dashboard           â”‚ â”‚
â”‚ â”‚                                     â”‚ â”‚
â”‚ â”‚ â€¢ Real-time metrics                 â”‚ â”‚
â”‚ â”‚ â€¢ Alerts and notifications          â”‚ â”‚
â”‚ â”‚ â€¢ Performance analytics             â”‚ â”‚
â”‚ â”‚ â€¢ User behavior insights            â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Event Types:
â€¢ AUTH: login, logout, token_refresh
â€¢ TASK: started, completed, failed
â€¢ DAILY: claimed, missed, streak_broken
â€¢ FLEX: claimed, level_up, balance_updated
â€¢ WALLET: connected, disconnected, verified
â€¢ TRANSACTION: created, failed, reversed
â€¢ SYSTEM: error, warning, info, debug
```

## ğŸ”„ Data Flow Patterns

### Complete User Journey Example

```
ğŸŒŸ ĞĞĞ’Ğ˜Ğ™ ĞšĞĞ Ğ˜Ğ¡Ğ¢Ğ£Ğ’ĞĞ§ - ĞŸĞĞ’ĞĞ˜Ğ™ JOURNEY

1. ĞŸĞ•Ğ Ğ¨Ğ˜Ğ™ Ğ’Ğ¥Ğ†Ğ”
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ User clicks Telegram mini-app           â”‚
â”‚ â†“                                       â”‚
â”‚ TelegramWebApp.initData generated       â”‚
â”‚ â†“                                       â”‚
â”‚ POST /api/auth/validate-telegram        â”‚
â”‚ â†“                                       â”‚
â”‚ AuthController validates + creates user â”‚
â”‚ â†“                                       â”‚
â”‚ UserQuest.create_user() + referral      â”‚
â”‚ â†“                                       â”‚
â”‚ TransactionService.welcome_bonus()      â”‚
â”‚ â†“                                       â”‚
â”‚ Analytics.log_new_user_event()          â”‚
â”‚ â†“                                       â”‚
â”‚ JWT token generated                     â”‚
â”‚ â†“                                       â”‚
â”‚ Response: Welcome package               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

2. ĞŸĞ•Ğ Ğ¨Ğ˜Ğ™ Ğ©ĞĞ”Ğ•ĞĞĞ˜Ğ™ Ğ‘ĞĞĞ£Ğ¡
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ GET /api/daily/status/{id}              â”‚
â”‚ â†“                                       â”‚
â”‚ DailyController.get_status()            â”‚
â”‚ â”œâ”€ Day 1, Streak 0, Can claim: true     â”‚
â”‚ â””â”€ Preview: 20 WINIX                    â”‚
â”‚ â†“                                       â”‚
â”‚ POST /api/daily/claim/{id}              â”‚
â”‚ â†“                                       â”‚
â”‚ RewardCalculator.calculate()            â”‚
â”‚ â”œâ”€ Base: 20 WINIX                       â”‚
â”‚ â””â”€ Total: 20 WINIX                      â”‚
â”‚ â†“                                       â”‚
â”‚ TransactionService.process_daily()      â”‚
â”‚ â”œâ”€ Transaction created                  â”‚
â”‚ â”œâ”€ Balance: 0 â†’ 20 WINIX                â”‚
â”‚ â””â”€ Daily status updated                 â”‚
â”‚ â†“                                       â”‚
â”‚ Analytics.log_daily_claimed()           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

3. ĞŸĞ•Ğ Ğ¨Ğ• Ğ—ĞĞ’Ğ”ĞĞĞĞ¯
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ GET /api/tasks/list/{id}                â”‚
â”‚ â†“                                       â”‚
â”‚ TasksController.get_list()              â”‚
â”‚ â”œâ”€ Available: Join Telegram Channel     â”‚
â”‚ â”œâ”€ Reward: 50 WINIX + 2 tickets         â”‚
â”‚ â””â”€ Type: telegram_subscribe             â”‚
â”‚ â†“                                       â”‚
â”‚ POST /api/tasks/start/{id}/telegram_1   â”‚
â”‚ â†“                                       â”‚
â”‚ TasksController.start_task()            â”‚
â”‚ â”œâ”€ Status: in_progress                  â”‚
â”‚ â”œâ”€ Started_at: timestamp                â”‚
â”‚ â””â”€ Timer: 30 seconds                    â”‚
â”‚ â†“                                       â”‚
â”‚ User joins channel manually             â”‚
â”‚ â†“                                       â”‚
â”‚ POST /api/tasks/verify/{id}/telegram_1  â”‚
â”‚ â†“                                       â”‚
â”‚ VerificationService.verify()            â”‚
â”‚ â”œâ”€ TelegramService.check_subscription() â”‚
â”‚ â”œâ”€ Result: VERIFIED                     â”‚
â”‚ â””â”€ Auto-reward trigger                  â”‚
â”‚ â†“                                       â”‚
â”‚ TransactionService.process_task_reward()â”‚
â”‚ â”œâ”€ Transaction: +50 WINIX, +2 tickets   â”‚
â”‚ â”œâ”€ Balance: 20 â†’ 70 WINIX, 0 â†’ 2 ticketsâ”‚
â”‚ â””â”€ Task marked completed                â”‚
â”‚ â†“                                       â”‚
â”‚ Analytics.log_task_completed()          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

4. ĞŸĞ†Ğ”ĞšĞ›Ğ®Ğ§Ğ•ĞĞĞ¯ TON Ğ“ĞĞœĞĞĞ¦Ğ¯
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ POST /api/wallet/connect/{id}           â”‚
â”‚ Body: {address: "EQD...", provider}     â”‚
â”‚ â†“                                       â”‚
â”‚ WalletController.connect()              â”‚
â”‚ â”œâ”€ TONConnectService.validate()         â”‚
â”‚ â”œâ”€ Signature verification               â”‚
â”‚ â””â”€ Address format check                 â”‚
â”‚ â†“                                       â”‚
â”‚ WalletModel.create_connection()         â”‚
â”‚ â”œâ”€ Save wallet info                     â”‚
â”‚ â””â”€ Status: connected                    â”‚
â”‚ â†“                                       â”‚
â”‚ Check: first_wallet_bonus               â”‚
â”‚ â”œâ”€ TransactionService.wallet_bonus()    â”‚
â”‚ â”œâ”€ Reward: 100 WINIX + 5 tickets        â”‚
â”‚ â””â”€ Balance: 70â†’170 WINIX, 2â†’7 tickets   â”‚
â”‚ â†“                                       â”‚
â”‚ TONConnectService.get_balances()        â”‚
â”‚ â”œâ”€ TON: 1.5                             â”‚
â”‚ â””â”€ FLEX: 75,000                         â”‚
â”‚ â†“                                       â”‚
â”‚ Analytics.log_wallet_connected()        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

5. ĞŸĞ•Ğ Ğ¨Ğ FLEX Ğ’Ğ˜ĞĞĞ“ĞĞ ĞĞ”Ğ
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ GET /api/flex/levels/{id}               â”‚
â”‚ â†“                                       â”‚
â”‚ FlexController.get_levels()             â”‚
â”‚ â”œâ”€ Current FLEX: 75,000                 â”‚
â”‚ â”œâ”€ Available: Bronze, Silver            â”‚
â”‚ â””â”€ Can claim: Bronze (10K), Silver (50K)â”‚
â”‚ â†“                                       â”‚
â”‚ POST /api/flex/claim/{id}               â”‚
â”‚ Body: {level: "Silver"}                 â”‚
â”‚ â†“                                       â”‚
â”‚ FlexController.claim()                  â”‚
â”‚ â”œâ”€ Verify 50K FLEX requirement          â”‚
â”‚ â”œâ”€ Check cooldown (24h)                 â”‚
â”‚ â””â”€ Silver reward: 75 WINIX + 2 tickets  â”‚
â”‚ â†“                                       â”‚
â”‚ TransactionService.process_flex()       â”‚
â”‚ â”œâ”€ Transaction created                  â”‚
â”‚ â””â”€ Balance: 170â†’245 WINIX, 7â†’9 tickets  â”‚
â”‚ â†“                                       â”‚
â”‚ FlexRewards.set_cooldown()              â”‚
â”‚ â””â”€ Next claim in: 24:00:00              â”‚
â”‚ â†“                                       â”‚
â”‚ Analytics.log_flex_claimed()            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

FINAL STATE:
â”œâ”€ WINIX Balance: 245
â”œâ”€ Tickets: 9
â”œâ”€ Completed Tasks: 1
â”œâ”€ Daily Streak: 1
â”œâ”€ Wallet Connected: âœ…
â”œâ”€ FLEX Level: Silver
â””â”€ Total Transactions: 4
```

## ğŸš€ Performance & Scalability

### Caching Strategy
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              CACHING LAYERS             â”‚
â”‚                                         â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ Level 1: Memory â”‚ â”‚ Level 2: Redis  â”‚ â”‚
â”‚ â”‚                 â”‚ â”‚                 â”‚ â”‚
â”‚ â”‚ â€¢ JWT tokens    â”‚ â”‚ â€¢ User sessions â”‚ â”‚
â”‚ â”‚ â€¢ Rate limits   â”‚ â”‚ â€¢ TON balances  â”‚ â”‚
â”‚ â”‚ â€¢ Temp data     â”‚ â”‚ â€¢ Task progress â”‚ â”‚
â”‚ â”‚ TTL: 1-5 min    â”‚ â”‚ TTL: 5-60 min   â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚          â”‚                   â”‚          â”‚
â”‚          â–¼                   â–¼          â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚        Level 3: Database            â”‚ â”‚
â”‚ â”‚                                     â”‚ â”‚
â”‚ â”‚ â€¢ Persistent data                   â”‚ â”‚
â”‚ â”‚ â€¢ Historical records                â”‚ â”‚
â”‚ â”‚ â€¢ Analytics events                  â”‚ â”‚
â”‚ â”‚ â€¢ User profiles                     â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                         â”‚
â”‚ Cache Invalidation Strategy:            â”‚
â”‚ â€¢ User update â†’ Clear user cache        â”‚
â”‚ â€¢ Balance change â†’ Clear balance cache  â”‚
â”‚ â€¢ Task completion â†’ Clear task cache    â”‚
â”‚ â€¢ Daily bonus â†’ Clear daily cache       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Async Processing
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          ASYNC ARCHITECTURE             â”‚
â”‚                                         â”‚
â”‚ Synchronous Operations:                 â”‚
â”‚ â”œâ”€ User authentication                  â”‚
â”‚ â”œâ”€ Balance updates                      â”‚
â”‚ â”œâ”€ Task verification                    â”‚
â”‚ â””â”€ Transaction processing               â”‚
â”‚                                         â”‚
â”‚ Asynchronous Operations:                â”‚
â”‚ â”œâ”€ Analytics event logging              â”‚
â”‚ â”œâ”€ Email/Push notifications             â”‚
â”‚ â”œâ”€ TON balance monitoring               â”‚
â”‚ â”œâ”€ Background health checks             â”‚
â”‚ â””â”€ Cache warming                        â”‚
â”‚                                         â”‚
â”‚ Implementation:                         â”‚
â”‚ â”œâ”€ asyncio.create_task()                â”‚
â”‚ â”œâ”€ Background threads                   â”‚
â”‚ â”œâ”€ Queue processing                     â”‚
â”‚ â””â”€ Scheduled jobs                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ›¡ï¸ Error Handling & Recovery

### Fallback Mechanisms
```
1. Transaction Service Fallback
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Primary: TransactionService.process()   â”‚
â”‚ â†“ (if fails)                            â”‚
â”‚ Fallback: Direct DB operations          â”‚
â”‚ â”œâ”€ supabase_client.update_balance()     â”‚
â”‚ â”œâ”€ Manual transaction logging           â”‚
â”‚ â””â”€ Analytics.log_fallback_used()        â”‚
â”‚ â†“                                       â”‚
â”‚ Recovery: Sync transactions later       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

2. External API Fallback
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Primary: TelegramService.check()        â”‚
â”‚ â†“ (if API down)                         â”‚
â”‚ Fallback: Cached results (if available) â”‚
â”‚ â†“ (if no cache)                         â”‚
â”‚ Graceful: Mark as "pending verification"â”‚
â”‚ â†“                                       â”‚
â”‚ Recovery: Retry queue processing        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

3. Database Connection Fallback
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Primary: Supabase connection            â”‚
â”‚ â†“ (if connection lost)                  â”‚
â”‚ Retry: 3 attempts with backoff         â”‚
â”‚ â†“ (if still failing)                    â”‚
â”‚ Fallback: Local caching mode           â”‚
â”‚ â”œâ”€ Store operations in memory           â”‚
â”‚ â”œâ”€ Return cached responses              â”‚
â”‚ â””â”€ Queue operations for later sync      â”‚
â”‚ â†“                                       â”‚
â”‚ Recovery: Auto-reconnect + sync         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“ˆ Monitoring & Health Checks

### Health Check Endpoints
```
GET /api/health
â”œâ”€ Overall system health
â”œâ”€ Database connectivity
â”œâ”€ External services status
â””â”€ Performance metrics

GET /api/winix/health
â”œâ”€ WINIX system components
â”œâ”€ Transaction service status
â”œâ”€ Cache system health
â””â”€ Background job status

GET /api/winix/diagnosis
â”œâ”€ Detailed component analysis
â”œâ”€ Performance bottlenecks
â”œâ”€ Error rate statistics
â””â”€ Resource utilization
```

## ğŸ“ Ğ”ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ğ¸Ğ¹ Ğ¾Ğ¿Ğ¸Ñ ĞšĞĞ–ĞĞĞ“Ğ Ñ„Ğ°Ğ¹Ğ»Ñƒ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ¸

### ğŸ  CORE SYSTEM FILES

#### `main.py` - Ğ“Ğ¾Ğ»Ğ¾Ğ²Ğ½Ğ¸Ğ¹ Ñ„Ğ°Ğ¹Ğ» Ğ´Ğ¾Ğ´Ğ°Ñ‚ĞºÑƒ
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: Ğ¢Ğ¾Ñ‡ĞºĞ° Ğ²Ñ…Ğ¾Ğ´Ñƒ Flask Ğ´Ğ¾Ğ´Ğ°Ñ‚ĞºÑƒ
```
**ĞšĞ»ÑÑ‡Ğ¾Ğ²Ñ– Ñ„ÑƒĞ½ĞºÑ†Ñ–Ñ—:**
- ğŸš€ `create_app()` - Flask App Factory pattern
- ğŸ”— `setup_winix_routes(app)` - Ğ ĞµÑ”ÑÑ‚Ñ€Ğ°Ñ†Ñ–Ñ Ğ²ÑÑ–Ñ… WINIX Ğ¼Ğ°Ñ€ÑˆÑ€ÑƒÑ‚Ñ–Ğ²
- ğŸ¥ `diagnose_winix_import()` - Ğ”Ñ–Ğ°Ğ³Ğ½Ğ¾ÑÑ‚Ğ¸ĞºĞ° Ğ·Ğ°Ğ²Ğ°Ğ½Ñ‚Ğ°Ğ¶ĞµĞ½Ğ½Ñ Ğ¼Ğ¾Ğ´ÑƒĞ»Ñ–Ğ²
- âš™ï¸ CORS Ğ½Ğ°Ğ»Ğ°ÑˆÑ‚ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ´Ğ»Ñ frontend
- ğŸ›¡ï¸ Middleware Ñ–Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ñ–Ñ (Logger, Rate Limiter, Security)
- ğŸ“„ Static files serving (/assets, /js, /css, /ChenelPNG)
- âŒ Error handlers (404, 500)

**Ğ—Ğ°Ğ»ĞµĞ¶Ğ½Ğ¾ÑÑ‚Ñ–:**
- `settings.config` â†’ ĞšĞ¾Ğ½Ñ„Ñ–Ğ³ÑƒÑ€Ğ°Ñ†Ñ–Ñ Ğ´Ğ¾Ğ´Ğ°Ñ‚ĞºÑƒ
- `quests/__init__.py` â†’ WINIX ÑĞ¸ÑÑ‚ĞµĞ¼Ğ°
- `middleware/*` â†’ Middleware ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ğ¸

**ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚Ğ¸ Ñ‰Ğ¾ Ñ€ĞµÑ”ÑÑ‚Ñ€ÑƒÑÑ‚ÑŒÑÑ:**
```python
/api/health           â†’ Ğ—Ğ°Ğ³Ğ°Ğ»ÑŒĞ½Ğ¸Ğ¹ health check
/api/winix/*          â†’ WINIX ÑĞ¸ÑÑ‚ĞµĞ¼Ğ° Ğ¼Ğ°Ñ€ÑˆÑ€ÑƒÑ‚Ñ–Ğ²
/debug                â†’ Ğ”Ñ–Ğ°Ğ³Ğ½Ğ¾ÑÑ‚Ğ¸Ñ‡Ğ½Ğ¸Ğ¹ endpoint
/assets/<filename>    â†’ Ğ¡Ñ‚Ğ°Ñ‚Ğ¸Ñ‡Ğ½Ñ– Ñ„Ğ°Ğ¹Ğ»Ğ¸
```

---

#### `supabase_client.py` - Database Layer
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: Ğ„Ğ´Ğ¸Ğ½Ğ° Ñ‚Ğ¾Ñ‡ĞºĞ° Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ñƒ Ğ´Ğ¾ Supabase PostgreSQL
```
**ĞšĞ»ÑÑ‡Ğ¾Ğ²Ñ– Ñ„ÑƒĞ½ĞºÑ†Ñ–Ñ—:**
- ğŸ‘¤ **User Management**: `get_user()`, `create_user()`, `update_user()`
- ğŸ’° **Balance Operations**: `update_balance()`, `update_coins()`
- ğŸ’³ **Transaction Processing**: Create, read, update transactions
- ğŸ“Š **Analytics Integration**: `create_analytics_event()`, `get_user_analytics()`
- ğŸ **Daily Bonus System**: `get_user_daily_status()`, `create_daily_bonus_entry()`
- ğŸ’ **FLEX System**: `get_user_flex_balance()`, `create_flex_claim()`
- ğŸ“‹ **Tasks Management**: `get_user_tasks_progress()`, `update_task_progress()`
- ğŸ’¼ **Wallet Integration**: `get_user_wallet_info()`, `update_wallet_connection()`
- ğŸ¯ **Staking System**: `create_staking_session()`, `complete_staking_session()`

**Caching Strategy:**
```python
@cached(timeout=300)  # User data: 5 Ñ…Ğ²Ğ¸Ğ»Ğ¸Ğ½
@cached(timeout=60)   # Daily status: 1 Ñ…Ğ²Ğ¸Ğ»Ğ¸Ğ½Ğ°
@cached(timeout=180)  # Balance: 3 Ñ…Ğ²Ğ¸Ğ»Ğ¸Ğ½Ğ¸
```

**Error Handling:**
- Connection retry logic (3 ÑĞ¿Ñ€Ğ¾Ğ±Ğ¸)
- Timeout handling (10 ÑĞµĞºÑƒĞ½Ğ´)
- Graceful degradation Ğ¿Ñ€Ğ¸ Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾ÑÑ‚Ñ– DB

---

### ğŸ“¦ QUESTS PACKAGE

#### `quests/__init__.py` - WINIX System Core
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: Ğ¦ĞµĞ½Ñ‚Ñ€Ğ°Ğ»ÑŒĞ½Ğ¸Ğ¹ ĞºĞ¾Ğ¾Ñ€Ğ´Ğ¸Ğ½Ğ°Ñ‚Ğ¾Ñ€ WINIX ÑĞ¸ÑÑ‚ĞµĞ¼Ğ¸
```
**Ğ“Ğ¾Ğ»Ğ¾Ğ²Ğ½Ğ¸Ğ¹ ĞºĞ»Ğ°Ñ:**
```python
class WinixQuests:
    def __init__(self):
        self.models = self._init_models()           # Data layer
        self.services = self._init_services()       # Business logic
        self.controllers = self._init_controllers() # API coordination
        self.utils = self._init_utils()            # Utilities
```

**ĞšĞ»ÑÑ‡Ğ¾Ğ²Ñ– Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¸:**
- ğŸ¥ `health_check()` â†’ Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ Ğ²ÑÑ–Ñ… ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ñ–Ğ² ÑĞ¸ÑÑ‚ĞµĞ¼Ğ¸
- ğŸ›£ï¸ `register_routes(app)` â†’ Ğ ĞµÑ”ÑÑ‚Ñ€Ğ°Ñ†Ñ–Ñ Ğ²ÑÑ–Ñ… API Ğ¼Ğ°Ñ€ÑˆÑ€ÑƒÑ‚Ñ–Ğ²
- ğŸ” `get_component_status()` â†’ Ğ”Ñ–Ğ°Ğ³Ğ½Ğ¾ÑÑ‚Ğ¸ĞºĞ° Ğ¾ĞºÑ€ĞµĞ¼Ğ¸Ñ… Ğ¼Ğ¾Ğ´ÑƒĞ»Ñ–Ğ²
- âš ï¸ `handle_component_failure()` â†’ Fallback Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ¼Ğ¸Ğ»ĞºĞ°Ñ…

**Component Status Tracking:**
```python
COMPONENTS_STATUS = {
    'models': {'loaded': True, 'error': None, 'count': 7},
    'services': {'loaded': True, 'error': None, 'count': 5},
    'controllers': {'loaded': True, 'error': None, 'count': 8},
    'routes': {'loaded': True, 'error': None, 'count': 8},
    'utils': {'loaded': True, 'error': None, 'count': 4}
}
```

**Graceful Degradation:**
- ĞŸÑ€Ğ¸ Ğ¿Ğ¾Ğ¼Ğ¸Ğ»Ñ†Ñ– ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ğ° ÑÑ‚Ğ²Ğ¾Ñ€ÑÑÑ‚ÑŒÑÑ Ğ·Ğ°Ğ³Ğ»ÑƒÑˆĞºĞ¸ (stubs)
- Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° Ğ¿Ñ€Ğ¾Ğ´Ğ¾Ğ²Ğ¶ÑƒÑ” Ğ¿Ñ€Ğ°Ñ†ÑĞ²Ğ°Ñ‚Ğ¸ Ğ· Ğ¾Ğ±Ğ¼ĞµĞ¶ĞµĞ½Ğ¸Ğ¼ Ñ„ÑƒĞ½ĞºÑ†Ñ–Ğ¾Ğ½Ğ°Ğ»Ğ¾Ğ¼
- Ğ›Ğ¾Ğ³ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ²ÑÑ–Ñ… Ğ¿Ğ¾Ğ¼Ğ¸Ğ»Ğ¾Ğº Ğ´Ğ»Ñ Ğ´Ñ–Ğ°Ğ³Ğ½Ğ¾ÑÑ‚Ğ¸ĞºĞ¸

---

## ğŸ“Š MODELS LAYER - Data Access & Business Entities

### `models/__init__.py` - Models Coordinator
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: Ğ¦ĞµĞ½Ñ‚Ñ€Ğ°Ğ»Ñ–Ğ·Ğ¾Ğ²Ğ°Ğ½Ğµ Ğ·Ğ°Ğ²Ğ°Ğ½Ñ‚Ğ°Ğ¶ĞµĞ½Ğ½Ñ Ñ‚Ğ° ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»Ñ–Ğ½Ğ½Ñ Ğ¼Ğ¾Ğ´ĞµĞ»ÑĞ¼Ğ¸
```
**Ğ¤ÑƒĞ½ĞºÑ†Ñ–Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ:**
- ğŸ“‹ Model registration and initialization
- ğŸ” Health checking for all models
- âš ï¸ Error aggregation and reporting
- ğŸ¥ Dependencies validation

---

### `models/analytics.py` - Analytics & Events System
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: Ğ—Ğ±Ñ–Ñ€, Ğ·Ğ±ĞµÑ€ĞµĞ¶ĞµĞ½Ğ½Ñ Ñ‚Ğ° Ğ°Ğ½Ğ°Ğ»Ñ–Ğ· Ğ¿Ğ¾Ğ´Ñ–Ğ¹ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ñ–Ğ²
```

**ĞÑĞ½Ğ¾Ğ²Ğ½Ñ– ĞºĞ»Ğ°ÑĞ¸:**
```python
class AnalyticsDB:
    # ĞšĞ»Ğ°Ñ Ğ´Ğ»Ñ Ñ€Ğ¾Ğ±Ğ¾Ñ‚Ğ¸ Ğ· Ğ±Ğ°Ğ·Ğ¾Ñ Ğ´Ğ°Ğ½Ğ¸Ñ… Ğ°Ğ½Ğ°Ğ»Ñ–Ñ‚Ğ¸ĞºĞ¸
    def save_event(event: AnalyticsEvent) -> bool
    def get_user_events(user_id, date_range) -> List[AnalyticsEvent]
    def generate_user_stats(user_id) -> UserStats
    def cleanup_old_events(days_to_keep=90) -> int

class AnalyticsEvent:
    # ĞœĞ¾Ğ´ĞµĞ»ÑŒ Ğ¿Ğ¾Ğ´Ñ–Ñ— ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ°
    user_id: str
    event_type: EventType
    event_data: Dict[str, Any]
    timestamp: datetime
    severity: EventSeverity
    session_id: Optional[str]

class UserSession:
    # Ğ¡ĞµÑÑ–Ñ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ°
    session_id: str
    user_id: str
    start_time: datetime
    end_time: Optional[datetime]
    events_count: int
    platform: str

class UserStats:
    # Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ°
    total_events: int
    daily_events: int
    favorite_actions: List[str]
    session_duration_avg: float
    last_activity: datetime
```

**EventType Enum:**
```python
AUTH = "auth"                    # ĞĞ²Ñ‚Ğ¾Ñ€Ğ¸Ğ·Ğ°Ñ†Ñ–Ñ
TASK = "task"                    # Ğ—Ğ°Ğ²Ğ´Ğ°Ğ½Ğ½Ñ
WALLET = "wallet"                # Ğ“Ğ°Ğ¼Ğ°Ğ½ĞµÑ†ÑŒ
FLEX = "flex"                    # FLEX Ñ‚Ğ¾ĞºĞµĞ½Ğ¸
DAILY = "daily"                  # Ğ©Ğ¾Ğ´ĞµĞ½Ğ½Ñ– Ğ±Ğ¾Ğ½ÑƒÑĞ¸
TRANSACTION = "transaction"      # Ğ¢Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ñ–Ñ—
ERROR = "error"                  # ĞŸĞ¾Ğ¼Ğ¸Ğ»ĞºĞ¸
```

**Ğ’Ğ·Ğ°Ñ”Ğ¼Ğ¾Ğ´Ñ–Ñ—:**
- â†”ï¸ Supabase: `analytics_events`, `user_analytics_stats`, `user_sessions`
- â†—ï¸ All Controllers: ĞÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ğµ Ğ»Ğ¾Ğ³ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ¿Ğ¾Ğ´Ñ–Ğ¹
- â†—ï¸ Analytics Controller: Ğ—Ğ°Ğ¿Ğ¸Ñ‚Ğ¸ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ¸

**Async Event Processing:**
```python
asyncio.create_task(analytics_db.save_event(event))
# ĞŸĞ¾Ğ´Ñ–Ñ— Ğ·Ğ±ĞµÑ€Ñ–Ğ³Ğ°ÑÑ‚ÑŒÑÑ Ğ² Ñ„Ğ¾Ğ½Ğ¾Ğ²Ğ¾Ğ¼Ñƒ Ñ€ĞµĞ¶Ğ¸Ğ¼Ñ– Ğ±ĞµĞ· Ğ±Ğ»Ğ¾ĞºÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ¾ÑĞ½Ğ¾Ğ²Ğ½Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ñ‚Ğ¾ĞºÑƒ
```

---

### `models/user_quest.py` - User Management System
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»Ñ–Ğ½Ğ½Ñ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ°Ğ¼Ğ¸, Ğ±Ğ°Ğ»Ğ°Ğ½ÑĞ°Ğ¼Ğ¸, Ğ¿Ñ€Ğ¾Ñ„Ñ–Ğ»ÑĞ¼Ğ¸
```

**ĞÑĞ½Ğ¾Ğ²Ğ½Ñ– ĞºĞ»Ğ°ÑĞ¸:**
```python
class UserQuest:
    # Ğ Ğ¾Ğ·ÑˆĞ¸Ñ€ĞµĞ½Ğ° Ğ¼Ğ¾Ğ´ĞµĞ»ÑŒ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ° Ğ² ÑĞ¸ÑÑ‚ĞµĞ¼Ñ– ĞºĞ²ĞµÑÑ‚Ñ–Ğ²
    telegram_id: str
    username: str
    balance: UserBalance
    level: int
    experience: int
    created_at: datetime
    last_active: datetime
    daily_streak: int
    total_tasks_completed: int
    referrer_id: Optional[str]

    def get_user_by_telegram_id(telegram_id) -> Optional['UserQuest']
    def create_new_user(telegram_id, username, referrer_id) -> 'UserQuest'
    def update_balance(amount: int, currency: str) -> bool
    def add_experience(exp: int) -> bool
    def check_level_up() -> bool

class UserBalance:
    # Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° Ğ±Ğ°Ğ»Ğ°Ğ½ÑÑ–Ğ² ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ°
    winix: int = 0              # ĞÑĞ½Ğ¾Ğ²Ğ½Ğ° Ğ²Ğ°Ğ»ÑÑ‚Ğ°
    tickets: int = 0            # ĞšĞ²Ğ¸Ñ‚ĞºĞ¸ Ğ´Ğ»Ñ ÑĞ¿ĞµÑ†Ñ–Ğ°Ğ»ÑŒĞ½Ğ¸Ñ… Ğ¿Ğ¾Ğ´Ñ–Ğ¹
    flex_tokens: int = 0        # FLEX Ñ‚Ğ¾ĞºĞµĞ½Ğ¸ (ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ñ–Ğ·ÑƒÑ”Ñ‚ÑŒÑÑ Ğ· blockchain)

    def add_winix(amount: int) -> bool
    def spend_winix(amount: int) -> bool
    def add_tickets(amount: int) -> bool
    def spend_tickets(amount: int) -> bool
    def get_total_value() -> int

class Reward:
    # Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ¸
    winix: int = 0
    tickets: int = 0
    experience: int = 0

    def is_valid() -> bool
    def get_total_value() -> int

class TaskStatus(Enum):
    # Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑĞ¸ Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½ÑŒ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ°
    NOT_STARTED = "not_started"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    EXPIRED = "expired"
```

**ĞšĞ»ÑÑ‡Ğ¾Ğ²Ñ– Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¸:**
- ğŸ‘¤ **Profile Management**: CRUD Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ñ–Ñ— Ğ· Ğ¿Ñ€Ğ¾Ñ„Ñ–Ğ»ĞµĞ¼
- ğŸ’° **Balance Operations**: Atomic Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ñ–Ñ— Ğ· Ğ±Ğ°Ğ»Ğ°Ğ½ÑĞ°Ğ¼Ğ¸
- ğŸ“ˆ **Level System**: Ğ Ğ¾Ğ·Ñ€Ğ°Ñ…ÑƒĞ½Ğ¾Ğº Ñ€Ñ–Ğ²Ğ½Ñ–Ğ² Ñ‚Ğ° Ğ´Ğ¾ÑĞ²Ñ–Ğ´Ñƒ
- ğŸ¯ **Achievement Tracking**: Ğ’Ñ–Ğ´ÑÑ‚ĞµĞ¶ĞµĞ½Ğ½Ñ Ğ´Ğ¾ÑÑĞ³Ğ½ĞµĞ½ÑŒ
- ğŸ‘¥ **Referral System**: ĞĞ±Ñ€Ğ¾Ğ±ĞºĞ° Ñ€ĞµÑ„ĞµÑ€Ğ°Ğ»Ñ–Ğ²

**Ğ’Ğ·Ğ°Ñ”Ğ¼Ğ¾Ğ´Ñ–Ñ—:**
- â†”ï¸ Supabase: `winix` table (Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ½Ğ° Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ñ–Ğ²)
- â†—ï¸ Auth Controller: Ğ¡Ñ‚Ğ²Ğ¾Ñ€ĞµĞ½Ğ½Ñ/Ğ²Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ñ–Ğ²
- â†—ï¸ User Controller: ĞŸÑ€Ğ¾Ñ„Ñ–Ğ»ÑŒ Ñ‚Ğ° Ğ±Ğ°Ğ»Ğ°Ğ½ÑĞ¸
- â†—ï¸ All Controllers: ĞÑ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ Ğ´Ğ°Ğ½Ğ¸Ñ… ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ°

---

### `models/daily_bonus.py` - Daily Rewards System
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° Ñ‰Ğ¾Ğ´ĞµĞ½Ğ½Ğ¸Ñ… Ğ±Ğ¾Ğ½ÑƒÑÑ–Ğ² Ñ‚Ğ° ÑĞµÑ€Ñ–Ğ¹
```

**ĞÑĞ½Ğ¾Ğ²Ğ½Ñ– ĞºĞ»Ğ°ÑĞ¸:**
```python
class DailyBonusEntry:
    # Ğ—Ğ°Ğ¿Ğ¸Ñ Ğ¿Ñ€Ğ¾ Ğ¾Ñ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ Ñ‰Ğ¾Ğ´ĞµĞ½Ğ½Ğ¾Ğ³Ğ¾ Ğ±Ğ¾Ğ½ÑƒÑÑƒ
    telegram_id: str
    day_number: int              # Ğ”ĞµĞ½ÑŒ Ğ² ÑĞµÑ€Ñ–Ñ— (1-30)
    claimed_at: datetime
    reward_winix: int
    reward_tickets: int
    streak_bonus: int
    level_bonus: int

    def create_entry(telegram_id, day, reward) -> bool
    def get_user_history(telegram_id, limit=30) -> List['DailyBonusEntry']

class DailyBonusStatus:
    # ĞŸĞ¾Ñ‚Ğ¾Ñ‡Ğ½Ğ¸Ğ¹ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ñ‰Ğ¾Ğ´ĞµĞ½Ğ½Ğ¸Ñ… Ğ±Ğ¾Ğ½ÑƒÑÑ–Ğ² ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ°
    telegram_id: str
    current_day_number: int      # ĞŸĞ¾Ñ‚Ğ¾Ñ‡Ğ½Ğ¸Ğ¹ Ğ´ĞµĞ½ÑŒ (1-30, reset after 30)
    current_streak: int          # ĞĞºÑ‚Ğ¸Ğ²Ğ½Ğ° ÑĞµÑ€Ñ–Ñ Ğ´Ğ½Ñ–Ğ²
    last_claim_timestamp: datetime
    can_claim: bool
    next_claim_time: datetime

    def can_claim_now() -> bool
    def time_until_next_claim() -> timedelta
    def reset_streak() -> None
    def increment_day() -> None

class DailyBonusManager:
    # ĞœĞµĞ½ĞµĞ´Ğ¶ĞµÑ€ Ñ‰Ğ¾Ğ´ĞµĞ½Ğ½Ğ¸Ñ… Ğ±Ğ¾Ğ½ÑƒÑÑ–Ğ²
    def get_user_status(telegram_id) -> DailyBonusStatus
    def process_claim(telegram_id) -> Tuple[bool, Reward]
    def calculate_next_reward(telegram_id) -> Reward
    def check_streak_validity(last_claim) -> bool
    def reset_expired_streaks() -> int  # Background job
```

**Progressive Multipliers System:**
```python
DAILY_BONUS_CONFIG = {
    1: {"winix": 20, "tickets": 0, "multiplier": 1.0},
    7: {"winix": 20, "tickets": 1, "multiplier": 2.0},    # Special day
    14: {"winix": 20, "tickets": 2, "multiplier": 2.5},   # Special day
    21: {"winix": 20, "tickets": 3, "multiplier": 3.0},   # Special day
    30: {"winix": 20, "tickets": 10, "multiplier": 5.0}   # Final reward
}
```

**Ğ‘Ñ–Ğ·Ğ½ĞµÑ-Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»Ğ°:**
- â° ĞœÑ–Ğ½Ñ–Ğ¼ÑƒĞ¼ 20 Ğ³Ğ¾Ğ´Ğ¸Ğ½ Ğ¼Ñ–Ğ¶ Ğ¾Ñ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½ÑĞ¼Ğ¸
- ğŸ”¥ Ğ¡ĞµÑ€Ñ–Ñ Ğ¾Ğ±Ğ½ÑƒĞ»ÑÑ”Ñ‚ÑŒÑÑ Ğ¿Ñ–ÑĞ»Ñ 44 Ğ³Ğ¾Ğ´Ğ¸Ğ½ Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑĞºÑƒ
- ğŸ¯ Ğ¡Ğ¿ĞµÑ†Ñ–Ğ°Ğ»ÑŒĞ½Ñ– Ğ´Ğ½Ñ–: 7, 14, 21, 30 (Ğ´Ğ¾Ğ´Ğ°Ñ‚ĞºĞ¾Ğ²Ñ– tickets)
- ğŸ“ˆ ĞŸÑ€Ğ¾Ğ³Ñ€ĞµÑĞ¸Ğ²Ğ½Ğµ Ğ·Ñ€Ğ¾ÑÑ‚Ğ°Ğ½Ğ½Ñ Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´

**Ğ’Ğ·Ğ°Ñ”Ğ¼Ğ¾Ğ´Ñ–Ñ—:**
- â†”ï¸ Supabase: `daily_bonus_status`, `daily_bonus_entries`
- â†—ï¸ Daily Controller: Ğ‘Ñ–Ğ·Ğ½ĞµÑ-Ğ»Ğ¾Ğ³Ñ–ĞºĞ° Ğ±Ğ¾Ğ½ÑƒÑÑ–Ğ²
- â†—ï¸ Reward Calculator: Ğ Ğ¾Ğ·Ñ€Ğ°Ñ…ÑƒĞ½ĞºĞ¸ Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´
- â†—ï¸ Transaction Service: ĞĞ°Ñ€Ğ°Ñ…ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´

---

### `models/flex_rewards.py` - FLEX Token Rewards System
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: FLEX Ñ‚Ğ¾ĞºĞµĞ½Ğ¸, Ñ€Ñ–Ğ²Ğ½Ñ– Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´, Ñ–Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ñ–Ñ Ğ· TON
```

**ĞÑĞ½Ğ¾Ğ²Ğ½Ñ– ĞºĞ»Ğ°ÑĞ¸:**
```python
class FlexRewardsModel:
    # ĞÑĞ½Ğ¾Ğ²Ğ½Ğ° Ğ¼Ğ¾Ğ´ĞµĞ»ÑŒ FLEX ÑĞ¸ÑÑ‚ĞµĞ¼Ğ¸
    def get_user_flex_balance(telegram_id) -> int
    def update_flex_balance(telegram_id, balance, wallet_address) -> bool
    def get_available_levels(telegram_id) -> List[FlexLevel]
    def can_claim_level(telegram_id, level) -> bool
    def process_claim(telegram_id, level) -> Tuple[bool, Reward]
    def get_claim_history(telegram_id) -> List[Dict]

class FlexLevel:
    # Ğ Ñ–Ğ²ĞµĞ½ÑŒ FLEX Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ¸
    name: str                    # Bronze, Silver, Gold, Platinum, Diamond
    required_flex: int           # ĞœÑ–Ğ½Ñ–Ğ¼Ğ°Ğ»ÑŒĞ½Ğ° ĞºÑ–Ğ»ÑŒĞºÑ–ÑÑ‚ÑŒ FLEX
    reward_winix: int           # Ğ’Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ° WINIX
    reward_tickets: int         # Ğ’Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ° tickets
    cooldown_hours: int = 24    # Ğ§Ğ°Ñ Ğ¾Ñ‡Ñ–ĞºÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ¼Ñ–Ğ¶ claims

    def can_access(flex_balance: int) -> bool
    def get_reward() -> Reward

class FlexRewardConfig:
    # ĞšĞ¾Ğ½Ñ„Ñ–Ğ³ÑƒÑ€Ğ°Ñ†Ñ–Ñ Ñ€Ñ–Ğ²Ğ½Ñ–Ğ² FLEX
    LEVELS = {
        "Bronze": FlexLevel("Bronze", 10_000, 25, 1, 24),
        "Silver": FlexLevel("Silver", 50_000, 75, 2, 24),
        "Gold": FlexLevel("Gold", 100_000, 150, 4, 24),
        "Platinum": FlexLevel("Platinum", 250_000, 300, 8, 24),
        "Diamond": FlexLevel("Diamond", 500_000, 500, 15, 24)
    }

class UserFlexStatus:
    # Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ FLEX ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ°
    telegram_id: str
    current_flex_balance: int
    wallet_address: str
    last_balance_update: datetime
    claimed_levels: Dict[str, datetime]  # level -> last_claim_time

    def can_claim_level(level: str) -> bool
    def get_cooldown_remaining(level: str) -> timedelta
    def mark_level_claimed(level: str) -> None
```

**FLEX Levels Configuration:**
```python
Bronze:   10,000 FLEX   â†’ 25 WINIX + 1 Ticket
Silver:   50,000 FLEX   â†’ 75 WINIX + 2 Tickets
Gold:    100,000 FLEX   â†’ 150 WINIX + 4 Tickets
Platinum: 250,000 FLEX  â†’ 300 WINIX + 8 Tickets
Diamond:  500,000 FLEX  â†’ 500 WINIX + 15 Tickets
```

**ĞÑĞ¾Ğ±Ğ»Ğ¸Ğ²Ğ¾ÑÑ‚Ñ–:**
- ğŸ”— Ğ†Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ñ–Ñ Ğ· TON Blockchain Ğ´Ğ»Ñ Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ¸ Ğ±Ğ°Ğ»Ğ°Ğ½ÑÑ–Ğ²
- â° 24-Ğ³Ğ¾Ğ´Ğ¸Ğ½Ğ½Ğ¸Ğ¹ cooldown Ğ´Ğ»Ñ ĞºĞ¾Ğ¶Ğ½Ğ¾Ğ³Ğ¾ Ñ€Ñ–Ğ²Ğ½Ñ
- ğŸ“Š Real-time ÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ñ–Ğ·Ğ°Ñ†Ñ–Ñ Ğ· wallet Ğ±Ğ°Ğ»Ğ°Ğ½ÑĞ°Ğ¼Ğ¸
- ğŸ’ ĞœĞ½Ğ¾Ğ¶Ğ¸Ğ½Ğ½Ñ– Ñ€Ñ–Ğ²Ğ½Ñ– Ğ¼Ğ¾Ğ¶Ğ½Ğ° Ğ¾Ñ‚Ñ€Ğ¸Ğ¼ÑƒĞ²Ğ°Ñ‚Ğ¸ Ğ¿Ğ°Ñ€Ğ°Ğ»ĞµĞ»ÑŒĞ½Ğ¾

**Ğ’Ğ·Ğ°Ñ”Ğ¼Ğ¾Ğ´Ñ–Ñ—:**
- â†”ï¸ Supabase: `flex_balances`, `flex_claims`
- â†—ï¸ TON Connect Service: Ğ‘Ğ°Ğ»Ğ°Ğ½ÑĞ¸ FLEX Ñ‚Ğ¾ĞºĞµĞ½Ñ–Ğ²
- â†—ï¸ FLEX Controller: Ğ‘Ñ–Ğ·Ğ½ĞµÑ-Ğ»Ğ¾Ğ³Ñ–ĞºĞ°
- â†—ï¸ Transaction Service: ĞĞ°Ñ€Ğ°Ñ…ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´

---

### `models/task.py` - Task Management System
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½ÑŒ, Ñ‚Ğ¸Ğ¿Ğ¸, ÑÑ‚Ğ°Ñ‚ÑƒÑĞ¸, Ğ¿Ğ»Ğ°Ñ‚Ñ„Ğ¾Ñ€Ğ¼Ğ¸
```

**ĞÑĞ½Ğ¾Ğ²Ğ½Ñ– ĞºĞ»Ğ°ÑĞ¸:**
```python
class TaskModel:
    # ĞÑĞ½Ğ¾Ğ²Ğ½Ğ° Ğ¼Ğ¾Ğ´ĞµĞ»ÑŒ Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½ÑŒ
    def get_all_tasks() -> List[Dict]
    def get_task_by_id(task_id) -> Optional[Dict]
    def create_task(task_data) -> Dict
    def update_task(task_id, updates) -> bool
    def delete_task(task_id) -> bool
    def get_user_task_progress(telegram_id) -> List[Dict]
    def update_task_progress(telegram_id, task_id, status, data) -> bool

class TaskType(Enum):
    # Ğ¢Ğ¸Ğ¿Ğ¸ Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½ÑŒ
    TELEGRAM_SUBSCRIBE = "telegram_subscribe"    # ĞŸÑ–Ğ´Ğ¿Ğ¸ÑĞºĞ° Ğ½Ğ° ĞºĞ°Ğ½Ğ°Ğ»
    TELEGRAM_BOT_START = "telegram_bot_start"    # Ğ—Ğ°Ğ¿ÑƒÑĞº Ğ±Ğ¾Ñ‚Ğ°
    YOUTUBE_SUBSCRIBE = "youtube_subscribe"      # YouTube Ğ¿Ñ–Ğ´Ğ¿Ğ¸ÑĞºĞ°
    TWITTER_FOLLOW = "twitter_follow"            # Twitter Ğ¿Ñ–Ğ´Ğ¿Ğ¸ÑĞºĞ°
    DISCORD_JOIN = "discord_join"                # Discord ÑĞµÑ€Ğ²ĞµÑ€
    SOCIAL_SHARE = "social_share"                # ĞŸĞ¾Ğ´Ñ–Ğ»Ğ¸Ñ‚Ğ¸ÑÑ Ğ² ÑĞ¾Ñ†Ğ¼ĞµÑ€ĞµĞ¶Ğ°Ñ…
    LIMITED_TIME = "limited_time"                # ĞĞ±Ğ¼ĞµĞ¶ĞµĞ½Ñ– Ğ·Ğ° Ñ‡Ğ°ÑĞ¾Ğ¼
    PARTNER = "partner"                          # ĞŸĞ°Ñ€Ñ‚Ğ½ĞµÑ€ÑÑŒĞºÑ–
    DAILY_CHECK = "daily_check"                  # Ğ©Ğ¾Ğ´ĞµĞ½Ğ½Ñ– Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ¸

class TaskStatus(Enum):
    # Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑĞ¸ Ğ²Ğ¸ĞºĞ¾Ğ½Ğ°Ğ½Ğ½Ñ Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½ÑŒ
    AVAILABLE = "available"                      # Ğ”Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğµ Ğ´Ğ»Ñ Ğ²Ğ¸ĞºĞ¾Ğ½Ğ°Ğ½Ğ½Ñ
    STARTED = "started"                          # Ğ Ğ¾Ğ·Ğ¿Ğ¾Ñ‡Ğ°Ñ‚Ğ¾
    IN_VERIFICATION = "in_verification"          # ĞĞ° Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€Ñ†Ñ–
    COMPLETED = "completed"                      # Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¾
    FAILED = "failed"                           # ĞĞµ Ğ¿Ñ€Ğ¾Ğ¹Ğ´ĞµĞ½Ğ¾
    EXPIRED = "expired"                         # Ğ¢ĞµÑ€Ğ¼Ñ–Ğ½ Ğ²Ğ¸Ğ¹ÑˆĞ¾Ğ²

class TaskPlatform(Enum):
    # ĞŸĞ»Ğ°Ñ‚Ñ„Ğ¾Ñ€Ğ¼Ğ¸ Ğ´Ğ»Ñ Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½ÑŒ
    TELEGRAM = "telegram"
    YOUTUBE = "youtube"
    TWITTER = "twitter"
    DISCORD = "discord"
    INSTAGRAM = "instagram"
    TIKTOK = "tiktok"
    WEBSITE = "website"

class TaskAction(Enum):
    # Ğ”Ñ–Ñ— Ğ´Ğ»Ñ Ğ²Ğ¸ĞºĞ¾Ğ½Ğ°Ğ½Ğ½Ñ
    SUBSCRIBE = "subscribe"                      # ĞŸÑ–Ğ´Ğ¿Ğ¸ÑĞ°Ñ‚Ğ¸ÑÑ
    LIKE = "like"                               # ĞŸĞ¾ÑÑ‚Ğ°Ğ²Ğ¸Ñ‚Ğ¸ Ğ»Ğ°Ğ¹Ğº
    SHARE = "share"                             # ĞŸĞ¾Ğ´Ñ–Ğ»Ğ¸Ñ‚Ğ¸ÑÑ
    COMMENT = "comment"                         # ĞšĞ¾Ğ¼ĞµĞ½Ñ‚ÑƒĞ²Ğ°Ñ‚Ğ¸
    JOIN = "join"                               # ĞŸÑ€Ğ¸Ñ”Ğ´Ğ½Ğ°Ñ‚Ğ¸ÑÑ
    VISIT = "visit"                             # Ğ’Ñ–Ğ´Ğ²Ñ–Ğ´Ğ°Ñ‚Ğ¸
    DOWNLOAD = "download"                       # Ğ—Ğ°Ğ²Ğ°Ğ½Ñ‚Ğ°Ğ¶Ğ¸Ñ‚Ğ¸
```

**Task Structure:**
```python
task_schema = {
    "id": "task_uuid",
    "title": "ĞŸÑ–Ğ´Ğ¿Ğ¸ÑĞ°Ñ‚Ğ¸ÑÑ Ğ½Ğ° Telegram ĞºĞ°Ğ½Ğ°Ğ»",
    "description": "ĞŸÑ–Ğ´Ğ¿Ğ¸ÑˆÑ–Ñ‚ÑŒÑÑ Ğ½Ğ° Ğ½Ğ°Ñˆ Ğ¾Ñ„Ñ–Ñ†Ñ–Ğ¹Ğ½Ğ¸Ğ¹ ĞºĞ°Ğ½Ğ°Ğ»",
    "type": TaskType.TELEGRAM_SUBSCRIBE,
    "platform": TaskPlatform.TELEGRAM,
    "action": TaskAction.SUBSCRIBE,
    "target_url": "https://t.me/winixchannel",
    "verification_data": {
        "channel_username": "@winixchannel",
        "timer_seconds": 30
    },
    "reward": {
        "winix": 50,
        "tickets": 2,
        "experience": 10
    },
    "requirements": {
        "min_level": 1,
        "max_completions": 1,
        "expiry_date": "2024-12-31"
    },
    "status": "active"
}
```

**Ğ’Ğ·Ğ°Ñ”Ğ¼Ğ¾Ğ´Ñ–Ñ—:**
- â†”ï¸ Supabase: `tasks`, `task_progress`, `completed_tasks`
- â†—ï¸ Tasks Controller: CRUD Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ñ–Ñ—
- â†—ï¸ Verification Service: ĞŸÑ€Ğ¾Ñ†ĞµÑ Ğ²ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ—
- â†—ï¸ Transaction Service: Ğ’Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ¸ Ğ·Ğ° Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ½Ñ

---

### `models/transaction.py` - Transaction Management System
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: Ğ¤Ñ–Ğ½Ğ°Ğ½ÑĞ¾Ğ²Ñ– Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ñ–Ñ—, Ñ–ÑÑ‚Ğ¾Ñ€Ñ–Ñ Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ñ–Ğ¹, Ğ°ÑƒĞ´Ğ¸Ñ‚
```

**ĞÑĞ½Ğ¾Ğ²Ğ½Ñ– ĞºĞ»Ğ°ÑĞ¸:**
```python
class TransactionModel:
    # ĞœĞ¾Ğ´ĞµĞ»ÑŒ Ñ„Ñ–Ğ½Ğ°Ğ½ÑĞ¾Ğ²Ğ¸Ñ… Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ñ–Ğ¹
    def create_transaction(transaction: Transaction) -> str
    def get_transaction(transaction_id) -> Optional[Transaction]
    def get_user_transactions(telegram_id, limit=50) -> List[Transaction]
    def update_transaction_status(transaction_id, status) -> bool
    def get_balance_from_transactions(telegram_id) -> TransactionAmount
    def reverse_transaction(transaction_id, reason) -> bool

class Transaction:
    # Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ñ–Ñ—
    id: str                              # UUID Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ñ–Ñ—
    telegram_id: str                     # ĞšĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡
    type: TransactionType                # Ğ¢Ğ¸Ğ¿ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ñ–Ñ—
    status: TransactionStatus            # Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ
    amount: TransactionAmount            # Ğ¡ÑƒĞ¼Ğ¸ Ğ¿Ğ¾ Ğ²Ğ°Ğ»ÑÑ‚Ğ°Ñ…
    metadata: Dict[str, Any]            # Ğ”Ğ¾Ğ´Ğ°Ñ‚ĞºĞ¾Ğ²Ñ– Ğ´Ğ°Ğ½Ñ–
    created_at: datetime
    processed_at: Optional[datetime]
    description: str
    reference_id: Optional[str]          # ID Ğ¿Ğ¾Ğ²'ÑĞ·Ğ°Ğ½Ğ¾Ñ— Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ñ–Ñ—

class TransactionAmount:
    # Ğ¡ÑƒĞ¼Ğ¸ Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ñ–Ñ— Ğ¿Ğ¾ Ğ²Ğ°Ğ»ÑÑ‚Ğ°Ñ…
    winix: int = 0                      # Ğ—Ğ¼Ñ–Ğ½Ğ° WINIX
    tickets: int = 0                    # Ğ—Ğ¼Ñ–Ğ½Ğ° tickets

    def is_credit() -> bool             # ĞŸĞ¾Ğ·Ğ¸Ñ‚Ğ¸Ğ²Ğ½Ğ° Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ñ–Ñ
    def is_debit() -> bool              # ĞĞµĞ³Ğ°Ñ‚Ğ¸Ğ²Ğ½Ğ° Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ñ–Ñ
    def get_total_value() -> int        # Ğ—Ğ°Ğ³Ğ°Ğ»ÑŒĞ½Ğ° Ğ²Ğ°Ñ€Ñ‚Ñ–ÑÑ‚ÑŒ

class TransactionType(Enum):
    # Ğ¢Ğ¸Ğ¿Ğ¸ Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ñ–Ğ¹
    # Ğ—ĞĞ ĞĞ‘Ğ†Ğ¢ĞĞš
    DAILY_BONUS = "daily_bonus"         # Ğ©Ğ¾Ğ´ĞµĞ½Ğ½Ğ¸Ğ¹ Ğ±Ğ¾Ğ½ÑƒÑ
    FLEX_REWARD = "flex_reward"         # FLEX Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ°
    TASK_REWARD = "task_reward"         # Ğ’Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ° Ğ·Ğ° Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½Ğ½Ñ
    REFERRAL_BONUS = "referral_bonus"   # Ğ ĞµÑ„ĞµÑ€Ğ°Ğ»ÑŒĞ½Ğ¸Ğ¹ Ğ±Ğ¾Ğ½ÑƒÑ
    WALLET_CONNECTION_BONUS = "wallet_connection_bonus"  # Ğ‘Ğ¾Ğ½ÑƒÑ Ğ·Ğ° Ğ³Ğ°Ğ¼Ğ°Ğ½ĞµÑ†ÑŒ
    LEVEL_UP_REWARD = "level_up_reward" # Ğ’Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ° Ğ·Ğ° Ñ€Ñ–Ğ²ĞµĞ½ÑŒ

    # Ğ’Ğ˜Ğ¢Ğ ĞĞ¢Ğ˜
    PURCHASE = "purchase"               # ĞŸĞ¾ĞºÑƒĞ¿ĞºĞ°
    WITHDRAWAL = "withdrawal"           # Ğ’Ğ¸Ğ²ĞµĞ´ĞµĞ½Ğ½Ñ
    PENALTY = "penalty"                 # Ğ¨Ñ‚Ñ€Ğ°Ñ„

    # Ğ¡Ğ˜Ğ¡Ğ¢Ğ•ĞœĞĞ†
    ADMIN_ADJUSTMENT = "admin_adjustment"  # Ğ ÑƒÑ‡Ğ½Ğµ ĞºĞ¾Ñ€Ğ¸Ğ³ÑƒĞ²Ğ°Ğ½Ğ½Ñ
    MIGRATION = "migration"             # ĞœÑ–Ğ³Ñ€Ğ°Ñ†Ñ–Ñ Ğ´Ğ°Ğ½Ğ¸Ñ…
    CORRECTION = "correction"           # Ğ’Ğ¸Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ½Ñ Ğ¿Ğ¾Ğ¼Ğ¸Ğ»ĞºĞ¸

class TransactionStatus(Enum):
    # Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑĞ¸ Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ñ–Ğ¹
    PENDING = "pending"                 # Ğ’ Ğ¾Ğ±Ñ€Ğ¾Ğ±Ñ†Ñ–
    COMPLETED = "completed"             # Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¾
    FAILED = "failed"                   # ĞŸĞ¾Ğ¼Ğ¸Ğ»ĞºĞ°
    REVERSED = "reversed"               # Ğ’Ñ–Ğ´ĞºĞ¾Ñ‡ĞµĞ½Ğ¾
    CANCELLED = "cancelled"             # Ğ¡ĞºĞ°ÑĞ¾Ğ²Ğ°Ğ½Ğ¾
```

**ĞÑƒĞ´Ğ¸Ñ‚ Ñ‚Ğ° Ğ±ĞµĞ·Ğ¿ĞµĞºĞ°:**
```python
# ĞšĞ¾Ğ¶Ğ½Ğ° Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ñ–Ñ Ğ½ĞµĞ·Ğ¼Ñ–Ğ½Ğ½Ğ° Ğ¿Ñ–ÑĞ»Ñ ÑÑ‚Ğ²Ğ¾Ñ€ĞµĞ½Ğ½Ñ
# Reversals ÑÑ‚Ğ²Ğ¾Ñ€ÑÑÑ‚ÑŒ Ğ½Ğ¾Ğ²Ñƒ Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ñ–Ñ Ğ· Ğ¿Ñ€Ğ¾Ñ‚Ğ¸Ğ»ĞµĞ¶Ğ½Ğ¸Ğ¼Ğ¸ ÑÑƒĞ¼Ğ°Ğ¼Ğ¸
# ĞŸĞ¾Ğ²Ğ½Ğ° Ñ–ÑÑ‚Ğ¾Ñ€Ñ–Ñ Ğ·Ğ±ĞµÑ€Ñ–Ğ³Ğ°Ñ”Ñ‚ÑŒÑÑ Ğ´Ğ»Ñ Ğ°ÑƒĞ´Ğ¸Ñ‚Ñƒ
# Atomic operations Ñ‡ĞµÑ€ĞµĞ· database transactions
```

**Ğ’Ğ·Ğ°Ñ”Ğ¼Ğ¾Ğ´Ñ–Ñ—:**
- â†”ï¸ Supabase: `transactions` table
- â†—ï¸ Transaction Service: Ğ¡Ñ‚Ğ²Ğ¾Ñ€ĞµĞ½Ğ½Ñ Ñ‚Ğ° Ğ¾Ğ±Ñ€Ğ¾Ğ±ĞºĞ°
- â†—ï¸ All Controllers: Ğ›Ğ¾Ğ³ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ñ„Ñ–Ğ½Ğ°Ğ½ÑĞ¾Ğ²Ğ¸Ñ… Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ñ–Ğ¹
- â†—ï¸ Analytics: Ğ¤Ñ–Ğ½Ğ°Ğ½ÑĞ¾Ğ²Ğ° ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°

---

### `models/wallet.py` - TON Wallet Integration
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: TON Ğ³Ğ°Ğ¼Ğ°Ğ½Ñ†Ñ–, Ğ¿Ñ–Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ½Ñ, ÑÑ‚Ğ°Ñ‚ÑƒÑĞ¸, Ğ±Ğ¾Ğ½ÑƒÑĞ¸
```

**ĞÑĞ½Ğ¾Ğ²Ğ½Ñ– ĞºĞ»Ğ°ÑĞ¸:**
```python
class WalletModel:
    # ĞœĞ¾Ğ´ĞµĞ»ÑŒ TON Ğ³Ğ°Ğ¼Ğ°Ğ½Ñ†Ñ–Ğ²
    def get_wallet_info(telegram_id) -> Optional[Dict]
    def create_wallet_connection(telegram_id, wallet_data) -> bool
    def update_wallet_status(telegram_id, status) -> bool
    def disconnect_wallet(telegram_id) -> bool
    def get_wallet_events(telegram_id) -> List[Dict]
    def log_wallet_event(telegram_id, event_type, data) -> bool

class WalletStatus(Enum):
    # Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑĞ¸ Ğ¿Ñ–Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ½Ñ Ğ³Ğ°Ğ¼Ğ°Ğ½Ñ†Ñ
    DISCONNECTED = "disconnected"       # ĞĞµ Ğ¿Ñ–Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¾
    CONNECTING = "connecting"           # Ğ’ Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑ– Ğ¿Ñ–Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ½Ñ
    CONNECTED = "connected"             # ĞŸÑ–Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¾
    VERIFIED = "verified"               # Ğ’ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ¾Ğ²Ğ°Ğ½Ğ¾
    ERROR = "error"                     # ĞŸĞ¾Ğ¼Ğ¸Ğ»ĞºĞ° Ğ¿Ñ–Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ½Ñ

class WalletProvider(Enum):
    # ĞŸÑ€Ğ¾Ğ²Ğ°Ğ¹Ğ´ĞµÑ€Ğ¸ TON Ğ³Ğ°Ğ¼Ğ°Ğ½Ñ†Ñ–Ğ²
    TONKEEPER = "tonkeeper"
    TONHUB = "tonhub"
    OPENMASK = "openmask"
    MYTONWALLET = "mytonwallet"
    TONWALLET = "tonwallet"

class WalletConnectionBonus:
    # Ğ‘Ğ¾Ğ½ÑƒÑ Ğ·Ğ° Ğ¿Ñ–Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ½Ñ Ğ³Ğ°Ğ¼Ğ°Ğ½Ñ†Ñ
    FIRST_CONNECTION_WINIX = 100        # ĞŸĞµÑ€ÑˆĞµ Ğ¿Ñ–Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ½Ñ
    FIRST_CONNECTION_TICKETS = 5
    VERIFICATION_WINIX = 50             # Ğ’ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ Ğ¿Ñ–Ğ´Ğ¿Ğ¸ÑÑƒ
    VERIFICATION_TICKETS = 2

    @staticmethod
    def get_connection_bonus() -> Reward:
        return Reward(winix=100, tickets=5)

    @staticmethod
    def get_verification_bonus() -> Reward:
        return Reward(winix=50, tickets=2)
```

**Wallet Connection Flow:**
```python
wallet_schema = {
    "telegram_id": "123456789",
    "address": "EQDk2VTvn04SUKJrW7rXahzdF8_Qi6utb0wj...",
    "provider": WalletProvider.TONKEEPER,
    "status": WalletStatus.CONNECTED,
    "connected_at": "2024-01-15T10:30:00Z",
    "last_verified": "2024-01-15T10:30:00Z",
    "balance_info": {
        "ton": 1.5,
        "flex": 75000,
        "last_updated": "2024-01-15T10:30:00Z"
    },
    "bonuses_received": {
        "connection_bonus": True,
        "verification_bonus": True
    }
}
```

**Ğ’Ğ·Ğ°Ñ”Ğ¼Ğ¾Ğ´Ñ–Ñ—:**
- â†”ï¸ Supabase: `wallets`, `wallet_events`
- â†—ï¸ TON Connect Service: Blockchain Ğ²Ğ·Ğ°Ñ”Ğ¼Ğ¾Ğ´Ñ–Ñ
- â†—ï¸ Wallet Controller: Ğ›Ğ¾Ğ³Ñ–ĞºĞ° Ğ¿Ñ–Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ½Ñ
- â†—ï¸ Transaction Service: Ğ‘Ğ¾Ğ½ÑƒÑĞ¸ Ğ·Ğ° Ğ¿Ñ–Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ½Ñ

---

## ğŸ”§ SERVICES LAYER - Business Logic & Integrations

### `services/__init__.py` - Services Coordinator
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: Ğ¦ĞµĞ½Ñ‚Ñ€Ğ°Ğ»Ñ–Ğ·Ğ¾Ğ²Ğ°Ğ½Ğµ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»Ñ–Ğ½Ğ½Ñ ÑĞµÑ€Ğ²Ñ–ÑĞ°Ğ¼Ğ¸
```
**Ğ¤ÑƒĞ½ĞºÑ†Ñ–Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ:**
- ğŸ”§ Service initialization and dependency injection
- ğŸ¥ Health monitoring for all services
- âš ï¸ Error handling and fallback coordination
- ğŸ”„ Service lifecycle management

---

### `services/reward_calculator.py` - Reward Calculation Engine
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: Ğ Ğ¾Ğ·Ñ€Ğ°Ñ…ÑƒĞ½ĞºĞ¸ Ğ²ÑÑ–Ñ… Ğ²Ğ¸Ğ´Ñ–Ğ² Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ¸
```

**ĞÑĞ½Ğ¾Ğ²Ğ½Ñ– Ñ„ÑƒĞ½ĞºÑ†Ñ–Ñ—:**
```python
class RewardCalculator:
    # Ğ“Ğ¾Ğ»Ğ¾Ğ²Ğ½Ğ¸Ğ¹ ĞºĞ»Ğ°Ñ Ñ€Ğ¾Ğ·Ñ€Ğ°Ñ…ÑƒĞ½ĞºÑ–Ğ² Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´

    def calculate_daily_bonus(
        day_number: int,
        current_streak: int,
        user_level: int,
        bonus_multiplier: float = 1.0
    ) -> Reward:
        # Ğ Ğ¾Ğ·Ñ€Ğ°Ñ…ÑƒĞ½Ğ¾Ğº Ñ‰Ğ¾Ğ´ĞµĞ½Ğ½Ğ¾Ğ³Ğ¾ Ğ±Ğ¾Ğ½ÑƒÑÑƒ

    def calculate_task_reward(
        task_type: TaskType,
        task_difficulty: str,
        user_level: int
    ) -> Reward:
        # Ğ’Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ° Ğ·Ğ° Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½Ğ½Ñ

    def calculate_flex_reward(
        flex_level: str,
        user_level: int
    ) -> Reward:
        # FLEX Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ¸

    def calculate_referral_bonus(
        referrer_level: int,
        referred_action: str
    ) -> Reward:
        # Ğ ĞµÑ„ĞµÑ€Ğ°Ğ»ÑŒĞ½Ñ– Ğ±Ğ¾Ğ½ÑƒÑĞ¸

    def apply_multipliers(
        base_reward: Reward,
        multipliers: Dict[str, float]
    ) -> Reward:
        # Ğ—Ğ°ÑÑ‚Ğ¾ÑÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ¼Ğ½Ğ¾Ğ¶Ğ½Ğ¸ĞºÑ–Ğ²

    def get_reward_preview(
        start_day: int,
        end_day: int,
        user_level: int
    ) -> List[Reward]:
        # ĞŸĞ¾Ğ¿ĞµÑ€ĞµĞ´Ğ½Ñ–Ğ¹ Ğ¿ĞµÑ€ĞµĞ³Ğ»ÑĞ´ Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´
```

**Progressive Daily Bonus Logic:**
```python
def calculate_daily_bonus(day_number, current_streak, user_level, bonus_multiplier):
    # Ğ‘Ğ°Ğ·Ğ¾Ğ²Ğ° Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ°
    base_winix = 20
    tickets = 0
    multiplier = 1.0

    # Ğ¡Ğ¿ĞµÑ†Ñ–Ğ°Ğ»ÑŒĞ½Ñ– Ğ´Ğ½Ñ– Ğ· Ğ¼Ğ½Ğ¾Ğ¶Ğ½Ğ¸ĞºĞ°Ğ¼Ğ¸
    if day_number == 7:
        multiplier = 2.0
        tickets = 1
    elif day_number == 14:
        multiplier = 2.5
        tickets = 2
    elif day_number == 21:
        multiplier = 3.0
        tickets = 3
    elif day_number == 30:
        multiplier = 5.0
        tickets = 10

    # Ğ‘Ğ¾Ğ½ÑƒÑ Ğ·Ğ° ÑĞµÑ€Ñ–Ñ
    streak_bonus = 0
    if current_streak >= 7:
        streak_bonus = 0.1  # +10%
    if current_streak >= 14:
        streak_bonus = 0.2  # +20%
    if current_streak >= 21:
        streak_bonus = 0.3  # +30%

    # Ğ‘Ğ¾Ğ½ÑƒÑ Ğ·Ğ° Ñ€Ñ–Ğ²ĞµĞ½ÑŒ
    level_bonus = max(0, (user_level - 1) * 0.05)  # +5% Ğ·Ğ° Ñ€Ñ–Ğ²ĞµĞ½ÑŒ

    # Ğ¤Ñ–Ğ½Ğ°Ğ»ÑŒĞ½Ğ¸Ğ¹ Ñ€Ğ¾Ğ·Ñ€Ğ°Ñ…ÑƒĞ½Ğ¾Ğº
    final_winix = int(base_winix * multiplier * (1 + streak_bonus + level_bonus) * bonus_multiplier)

    return Reward(winix=final_winix, tickets=tickets)
```

**Task Rewards Configuration:**
```python
TASK_REWARDS = {
    TaskType.TELEGRAM_SUBSCRIBE: {"winix": 50, "tickets": 2},
    TaskType.YOUTUBE_SUBSCRIBE: {"winix": 75, "tickets": 3},
    TaskType.TWITTER_FOLLOW: {"winix": 40, "tickets": 1},
    TaskType.DISCORD_JOIN: {"winix": 60, "tickets": 2},
    TaskType.PARTNER: {"winix": 100, "tickets": 5},
    TaskType.LIMITED_TIME: {"winix": 150, "tickets": 7}
}
```

**Ğ’Ğ·Ğ°Ñ”Ğ¼Ğ¾Ğ´Ñ–Ñ—:**
- â†—ï¸ Daily Controller: Ğ Ğ¾Ğ·Ñ€Ğ°Ñ…ÑƒĞ½ĞºĞ¸ Ñ‰Ğ¾Ğ´ĞµĞ½Ğ½Ğ¸Ñ… Ğ±Ğ¾Ğ½ÑƒÑÑ–Ğ²
- â†—ï¸ Tasks Controller: Ğ’Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ¸ Ğ·Ğ° Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½Ğ½Ñ
- â†—ï¸ FLEX Controller: FLEX Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ¸
- â†—ï¸ Transaction Service: Ğ’Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ ÑÑƒĞ¼

---

### `services/telegram_service.py` - Telegram Integration
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: Ğ†Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ñ–Ñ Ğ· Telegram Bot API Ñ‚Ğ° WebApp
```

**ĞÑĞ½Ğ¾Ğ²Ğ½Ñ– Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¸:**
```python
class TelegramService:
    def __init__(self, bot_token: str):
        self.bot_token = bot_token
        self.bot_username = None
        self.session = aiohttp.ClientSession()

    # AUTHENTICATION & VALIDATION
    async def validate_webapp_data(self, init_data: str) -> Dict[str, Any]:
        # Ğ’Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ Telegram WebApp initData
        # ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° HMAC-SHA256 Ğ¿Ñ–Ğ´Ğ¿Ğ¸ÑÑƒ
        # Ğ’Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ Ñ‡Ğ°ÑÑƒ (Ğ½Ğµ ÑÑ‚Ğ°Ñ€ÑˆĞµ 24 Ğ³Ğ¾Ğ´Ğ¸Ğ½)

    def parse_init_data(self, init_data: str) -> Dict[str, Any]:
        # ĞŸĞ°Ñ€ÑĞ¸Ğ½Ğ³ query string Ğ· WebApp

    # BOT INTERACTION
    async def check_bot_started(self, user_id: int) -> bool:
        # ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ñ‡Ğ¸ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡ Ğ·Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ğ² Ğ±Ğ¾Ñ‚Ğ°

    async def send_message(self, user_id: int, text: str) -> bool:
        # Ğ’Ñ–Ğ´Ğ¿Ñ€Ğ°Ğ²ĞºĞ° Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ½Ñ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ñƒ

    async def send_notification(self, user_id: int, notification_type: str, data: Dict) -> bool:
        # Ğ’Ñ–Ğ´Ğ¿Ñ€Ğ°Ğ²ĞºĞ° Ğ½Ğ¾Ñ‚Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ğ¹

    # CHANNEL & SUBSCRIPTION MANAGEMENT
    async def check_channel_subscription(self, user_id: int, channel_username: str) -> bool:
        # ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ¿Ñ–Ğ´Ğ¿Ğ¸ÑĞºĞ¸ Ğ½Ğ° ĞºĞ°Ğ½Ğ°Ğ»
        # ĞĞ±Ñ€Ğ¾Ğ±ĞºĞ° Ñ€Ñ–Ğ·Ğ½Ğ¸Ñ… Ñ‚Ğ¸Ğ¿Ñ–Ğ² Ğ¿Ğ¾Ğ¼Ğ¸Ğ»Ğ¾Ğº

    async def get_chat_member(self, chat_id: str, user_id: int) -> Dict:
        # ĞÑ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ Ñ–Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ñ–Ñ— Ğ¿Ñ€Ğ¾ ÑƒÑ‡Ğ°ÑĞ½Ğ¸ĞºĞ° Ñ‡Ğ°Ñ‚Ñƒ

    # BOT INFO & HEALTH
    async def get_bot_info(self) -> Dict[str, Any]:
        # Ğ†Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ñ–Ñ Ğ¿Ñ€Ğ¾ Ğ±Ğ¾Ñ‚Ğ°

    async def health_check(self) -> bool:
        # ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾ÑÑ‚Ñ– Telegram API
```

**Error Handling:**
```python
# Ğ¢Ğ¸Ğ¿Ğ¸ Ğ¿Ğ¾Ğ¼Ğ¸Ğ»Ğ¾Ğº Telegram API
class TelegramError(Exception):
    pass

class BotBlocked(TelegramError):
    # ĞšĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡ Ğ·Ğ°Ğ±Ğ»Ğ¾ĞºÑƒĞ²Ğ°Ğ² Ğ±Ğ¾Ñ‚Ğ°
    pass

class ChatNotFound(TelegramError):
    # ĞšĞ°Ğ½Ğ°Ğ» Ğ½Ğµ Ğ·Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾
    pass

class UserNotFound(TelegramError):
    # ĞšĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡ Ğ½Ğµ Ğ·Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¸Ğ¹
    pass

class InsufficientPermissions(TelegramError):
    # ĞĞµĞ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ½ÑŒĞ¾ Ğ¿Ñ€Ğ°Ğ²
    pass
```

**Retry Logic:**
```python
@retry(max_attempts=3, backoff_seconds=1)
async def check_subscription_with_retry(user_id, channel_username):
    # ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡Ğ½Ñ– Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€Ğ½Ñ– ÑĞ¿Ñ€Ğ¾Ğ±Ğ¸ Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ¼Ğ¸Ğ»ĞºĞ°Ñ… Ğ¼ĞµÑ€ĞµĞ¶Ñ–
    # Exponential backoff strategy
    pass
```

**Ğ’Ğ·Ğ°Ñ”Ğ¼Ğ¾Ğ´Ñ–Ñ—:**
- â†—ï¸ Auth Controller: Ğ’Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ WebApp Ğ´Ğ°Ğ½Ğ¸Ñ…
- â†—ï¸ Verification Service: ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½ÑŒ
- â†—ï¸ Tasks Controller: Ğ’ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ Telegram Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½ÑŒ
- ğŸŒ Telegram Bot API: Ğ—Ğ¾Ğ²Ğ½Ñ–ÑˆĞ½Ñ– HTTP Ğ·Ğ°Ğ¿Ğ¸Ñ‚Ğ¸

---

### `services/ton_connect_service.py` - TON Blockchain Integration
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: Ğ†Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ñ–Ñ Ğ· TON Ğ±Ğ»Ğ¾ĞºÑ‡ĞµĞ¹Ğ½Ğ¾Ğ¼ Ñ‚Ğ° FLEX Ñ‚Ğ¾ĞºĞµĞ½Ğ°Ğ¼Ğ¸
```

**ĞÑĞ½Ğ¾Ğ²Ğ½Ñ– ĞºĞ»Ğ°ÑĞ¸ Ñ‚Ğ° Ğ¼ĞµÑ‚Ğ¾Ğ´Ğ¸:**
```python
class TONConnectService:
    def __init__(self, api_key: str, network: TONNetwork = TONNetwork.MAINNET):
        self.api_key = api_key
        self.network = network
        self.session = aiohttp.ClientSession()
        self.cache = {}

    # WALLET OPERATIONS
    async def validate_wallet_address(self, address: str) -> bool:
        # Ğ’Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ‚Ñƒ TON Ğ°Ğ´Ñ€ĞµÑĞ¸
        # ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° checksum

    async def get_wallet_balance(self, address: str) -> TONBalance:
        # ĞÑ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ Ğ±Ğ°Ğ»Ğ°Ğ½ÑÑƒ TON Ğ³Ğ°Ğ¼Ğ°Ğ½Ñ†Ñ
        # ĞšĞµÑˆÑƒĞ²Ğ°Ğ½Ğ½Ñ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ–Ğ² (5 Ñ…Ğ² TTL)

    async def get_flex_balance(self, address: str) -> int:
        # ĞÑ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ Ğ±Ğ°Ğ»Ğ°Ğ½ÑÑƒ FLEX Ñ‚Ğ¾ĞºĞµĞ½Ñ–Ğ²
        # Ğ—Ğ°Ğ¿Ğ¸Ñ‚ Ğ´Ğ¾ ÑĞ¼Ğ°Ñ€Ñ‚-ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚Ñƒ FLEX

    # TRANSACTION MONITORING
    async def get_recent_transactions(self, address: str, limit: int = 50) -> List[Dict]:
        # ĞÑÑ‚Ğ°Ğ½Ğ½Ñ– Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ñ–Ñ— Ğ³Ğ°Ğ¼Ğ°Ğ½Ñ†Ñ

    async def monitor_wallet_changes(self, address: str, callback: Callable) -> None:
        # ĞœĞ¾Ğ½Ñ–Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³ Ğ·Ğ¼Ñ–Ğ½ Ğ±Ğ°Ğ»Ğ°Ğ½ÑÑƒ Ğ² Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ¼Ñƒ Ñ‡Ğ°ÑÑ–

    # VERIFICATION
    async def verify_wallet_ownership(self, address: str, signature: str, message: str) -> bool:
        # Ğ’ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ Ğ¿Ñ–Ğ´Ğ¿Ğ¸ÑÑƒ Ğ´Ğ»Ñ Ğ¿Ñ–Ğ´Ñ‚Ğ²ĞµÑ€Ğ´Ğ¶ĞµĞ½Ğ½Ñ Ğ²Ğ¾Ğ»Ğ¾Ğ´Ñ–Ğ½Ğ½Ñ

    # SMART CONTRACT INTERACTION
    async def call_flex_contract_method(self, method: str, params: Dict) -> Any:
        # Ğ’Ğ¸ĞºĞ»Ğ¸Ğº Ğ¼ĞµÑ‚Ğ¾Ğ´Ñ–Ğ² FLEX ÑĞ¼Ğ°Ñ€Ñ‚-ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚Ñƒ
```

**Data Classes:**
```python
@dataclass
class TONBalance:
    ton_balance: float          # Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ TON
    flex_balance: int          # Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ FLEX Ñ‚Ğ¾ĞºĞµĞ½Ñ–Ğ²
    last_updated: datetime     # Ğ§Ğ°Ñ Ğ¾ÑÑ‚Ğ°Ğ½Ğ½ÑŒĞ¾Ğ³Ğ¾ Ğ¾Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ
    address: str              # ĞĞ´Ñ€ĞµÑĞ° Ğ³Ğ°Ğ¼Ğ°Ğ½Ñ†Ñ

@dataclass
class FlexTokenInfo:
    contract_address: str     # ĞĞ´Ñ€ĞµÑĞ° ÑĞ¼Ğ°Ñ€Ñ‚-ĞºĞ¾Ğ½Ñ‚Ñ€Ğ°ĞºÑ‚Ñƒ
    decimals: int            # ĞšÑ–Ğ»ÑŒĞºÑ–ÑÑ‚ÑŒ Ğ´ĞµÑÑÑ‚ĞºĞ¾Ğ²Ğ¸Ñ… Ğ·Ğ½Ğ°ĞºÑ–Ğ²
    symbol: str = "FLEX"     # Ğ¡Ğ¸Ğ¼Ğ²Ğ¾Ğ» Ñ‚Ğ¾ĞºĞµĞ½Ñƒ
    total_supply: int        # Ğ—Ğ°Ğ³Ğ°Ğ»ÑŒĞ½Ğ° ĞµĞ¼Ñ–ÑÑ–Ñ

class TONNetwork(Enum):
    MAINNET = "mainnet"
    TESTNET = "testnet"
```

**Caching Strategy:**
```python
# ĞšĞµÑˆÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ´Ğ»Ñ Ğ¾Ğ¿Ñ‚Ğ¸Ğ¼Ñ–Ğ·Ğ°Ñ†Ñ–Ñ—
CACHE_CONFIG = {
    "wallet_balance": {"ttl": 300, "type": "memory"},      # 5 Ñ…Ğ²Ğ¸Ğ»Ğ¸Ğ½
    "flex_balance": {"ttl": 180, "type": "memory"},        # 3 Ñ…Ğ²Ğ¸Ğ»Ğ¸Ğ½Ğ¸
    "transactions": {"ttl": 600, "type": "redis"},         # 10 Ñ…Ğ²Ğ¸Ğ»Ğ¸Ğ½
    "contract_info": {"ttl": 3600, "type": "redis"}        # 1 Ğ³Ğ¾Ğ´Ğ¸Ğ½Ğ°
}
```

**Background Monitoring:**
```python
async def background_balance_monitor():
    # Ğ¤Ğ¾Ğ½Ğ¾Ğ²Ğ¸Ğ¹ Ğ¿Ñ€Ğ¾Ñ†ĞµÑ Ğ´Ğ»Ñ Ğ¾Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ Ğ±Ğ°Ğ»Ğ°Ğ½ÑÑ–Ğ²
    while True:
        connected_wallets = await get_all_connected_wallets()
        for wallet in connected_wallets:
            try:
                balance = await get_wallet_balance(wallet.address)
                await update_cached_balance(wallet.telegram_id, balance)

                # Trigger FLEX level recalculation if needed
                if balance.flex_balance != wallet.last_flex_balance:
                    await recalculate_flex_levels(wallet.telegram_id)

            except Exception as e:
                logger.error(f"Balance update failed for {wallet.address}: {e}")

        await asyncio.sleep(300)  # 5 Ñ…Ğ²Ğ¸Ğ»Ğ¸Ğ½
```

**Ğ’Ğ·Ğ°Ñ”Ğ¼Ğ¾Ğ´Ñ–Ñ—:**
- â†—ï¸ Wallet Controller: ĞŸÑ–Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ½Ñ Ñ‚Ğ° Ğ²ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ Ğ³Ğ°Ğ¼Ğ°Ğ½Ñ†Ñ–Ğ²
- â†—ï¸ FLEX Controller: Ğ‘Ğ°Ğ»Ğ°Ğ½ÑĞ¸ FLEX Ñ‚Ğ¾ĞºĞµĞ½Ñ–Ğ²
- â†—ï¸ Analytics: Blockchain ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°
- ğŸŒ TON API: Ğ—Ğ¾Ğ²Ğ½Ñ–ÑˆĞ½Ñ– blockchain Ğ·Ğ°Ğ¿Ğ¸Ñ‚Ğ¸

---

### `services/transaction_service.py` - Transaction Processing Hub
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: Ğ¦ĞµĞ½Ñ‚Ñ€Ğ°Ğ»Ñ–Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ° Ğ¾Ğ±Ñ€Ğ¾Ğ±ĞºĞ° Ğ²ÑÑ–Ñ… Ñ„Ñ–Ğ½Ğ°Ğ½ÑĞ¾Ğ²Ğ¸Ñ… Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ñ–Ğ¹
```

**ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¸Ğ¹ ĞºĞ»Ğ°Ñ:**
```python
class TransactionService:
    def __init__(self):
        self.db = supabase_client
        self.analytics = analytics_db

    # CORE TRANSACTION METHODS
    def create_transaction(self, transaction_data: Dict) -> Dict[str, Any]:
        # Ğ¡Ñ‚Ğ²Ğ¾Ñ€ĞµĞ½Ğ½Ñ Ğ½Ğ¾Ğ²Ğ¾Ñ— Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ñ–Ñ— Ğ· Ğ²Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ”Ñ

    def process_reward(
        self,
        telegram_id: str,
        winix_amount: int = 0,
        tickets_amount: int = 0,
        transaction_type: TransactionType,
        metadata: Dict = None
    ) -> Dict[str, Any]:
        # Ğ¦ĞµĞ½Ñ‚Ñ€Ğ°Ğ»Ñ–Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ° Ğ¾Ğ±Ñ€Ğ¾Ğ±ĞºĞ° Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´

    def process_spending(
        self,
        telegram_id: str,
        winix_amount: int = 0,
        tickets_amount: int = 0,
        transaction_type: TransactionType,
        metadata: Dict = None
    ) -> Dict[str, Any]:
        # ĞĞ±Ñ€Ğ¾Ğ±ĞºĞ° Ğ²Ğ¸Ñ‚Ñ€Ğ°Ñ‚ Ğ· Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ¾Ñ Ğ±Ğ°Ğ»Ğ°Ğ½ÑÑƒ

    # SPECIALIZED REWARD METHODS
    def process_daily_bonus(
        self,
        telegram_id: str,
        winix_amount: int,
        tickets_amount: int,
        day_number: int,
        streak: int
    ) -> Dict[str, Any]:
        # ĞĞ±Ñ€Ğ¾Ğ±ĞºĞ° Ñ‰Ğ¾Ğ´ĞµĞ½Ğ½Ğ¾Ğ³Ğ¾ Ğ±Ğ¾Ğ½ÑƒÑÑƒ

    def process_flex_reward(
        self,
        telegram_id: str,
        winix_amount: int,
        tickets_amount: int,
        flex_level: str,
        flex_balance: int
    ) -> Dict[str, Any]:
        # ĞĞ±Ñ€Ğ¾Ğ±ĞºĞ° FLEX Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ¸

    def process_task_reward(
        self,
        telegram_id: str,
        winix_amount: int,
        tickets_amount: int,
        task_id: str,
        task_type: str
    ) -> Dict[str, Any]:
        # Ğ’Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ° Ğ·Ğ° Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½Ğ½Ñ

    def process_wallet_connection_bonus(
        self,
        telegram_id: str,
        wallet_address: str,
        is_first_connection: bool = False
    ) -> Dict[str, Any]:
        # Ğ‘Ğ¾Ğ½ÑƒÑ Ğ·Ğ° Ğ¿Ñ–Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ½Ñ Ğ³Ğ°Ğ¼Ğ°Ğ½Ñ†Ñ

    # BALANCE & HISTORY
    def get_user_balance_summary(self, telegram_id: str) -> Dict[str, Any]:
        # Ğ—Ğ²ĞµĞ´ĞµĞ½Ğ½Ñ Ğ±Ğ°Ğ»Ğ°Ğ½ÑÑƒ Ğ· Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ñ–Ğ¹

    def get_transaction_history(
        self,
        telegram_id: str,
        limit: int = 50,
        transaction_type: Optional[TransactionType] = None
    ) -> List[Dict]:
        # Ğ†ÑÑ‚Ğ¾Ñ€Ñ–Ñ Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ñ–Ğ¹ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ°

    def reverse_transaction(self, transaction_id: str, reason: str) -> Dict[str, Any]:
        # Ğ¡ĞºĞ°ÑÑƒĞ²Ğ°Ğ½Ğ½Ñ Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ñ–Ñ—
```

**Atomic Transaction Processing:**
```python
def process_reward(self, telegram_id, winix_amount, tickets_amount, transaction_type, metadata):
    """
    ĞÑ‚Ğ¾Ğ¼Ğ°Ñ€Ğ½Ğ° Ğ¾Ğ±Ñ€Ğ¾Ğ±ĞºĞ° Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ¸ Ğ· Ğ¿Ğ¾Ğ²Ğ½Ğ¸Ğ¼ Ğ°ÑƒĞ´Ğ¸Ñ‚Ğ¾Ğ¼
    """
    try:
        # 1. Ğ’Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ Ğ²Ñ…Ğ¾Ğ´Ñ–Ğ²
        if not self._validate_reward_amounts(winix_amount, tickets_amount):
            return {"success": False, "error": "Invalid amounts"}

        # 2. Ğ¡Ñ‚Ğ²Ğ¾Ñ€ĞµĞ½Ğ½Ñ Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ñ–Ñ— (pending)
        transaction = self._create_transaction_record(
            telegram_id=telegram_id,
            type=transaction_type,
            status=TransactionStatus.PENDING,
            amount=TransactionAmount(winix=winix_amount, tickets=tickets_amount),
            metadata=metadata
        )

        # 3. ĞÑ‚Ğ¾Ğ¼Ğ°Ñ€Ğ½Ğµ Ğ¾Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ Ğ±Ğ°Ğ»Ğ°Ğ½ÑÑƒ
        balance_updated = self.db.update_balance(
            telegram_id=telegram_id,
            winix_amount=winix_amount,
            tickets_amount=tickets_amount
        )

        if not balance_updated:
            # Rollback transaction
            self._update_transaction_status(transaction['id'], TransactionStatus.FAILED)
            return {"success": False, "error": "Balance update failed"}

        # 4. Ğ¤Ñ–Ğ½Ğ°Ğ»Ñ–Ğ·Ğ°Ñ†Ñ–Ñ Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ñ–Ñ—
        self._update_transaction_status(transaction['id'], TransactionStatus.COMPLETED)

        # 5. ĞÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ğµ Ğ»Ğ¾Ğ³ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ°Ğ½Ğ°Ğ»Ñ–Ñ‚Ğ¸ĞºĞ¸
        asyncio.create_task(self._log_transaction_analytics(transaction))

        # 6. Ğ£ÑĞ¿Ñ–ÑˆĞ½Ğ° Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´ÑŒ
        return {
            "success": True,
            "transaction_id": transaction['id'],
            "new_balance": self._get_user_balance(telegram_id),
            "amount_added": {"winix": winix_amount, "tickets": tickets_amount}
        }

    except Exception as e:
        # Ğ›Ğ¾Ğ³ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ¿Ğ¾Ğ¼Ğ¸Ğ»ĞºĞ¸ Ñ‚Ğ° rollback
        logger.error(f"Transaction failed for {telegram_id}: {e}", exc_info=True)
        if 'transaction' in locals():
            self._update_transaction_status(transaction['id'], TransactionStatus.FAILED)
        return {"success": False, "error": "Internal server error"}
```

**Balance Validation:**
```python
def _validate_spending_request(self, telegram_id: str, winix_amount: int, tickets_amount: int) -> bool:
    """
    ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ½Ğ¾ÑÑ‚Ñ– ĞºĞ¾ÑˆÑ‚Ñ–Ğ² Ğ´Ğ»Ñ Ğ²Ğ¸Ñ‚Ñ€Ğ°Ñ‚Ğ¸
    """
    current_balance = self._get_user_balance(telegram_id)

    if current_balance['winix'] < winix_amount:
        return False

    if current_balance['tickets'] < tickets_amount:
        return False

    return True
```

**Ğ’Ğ·Ğ°Ñ”Ğ¼Ğ¾Ğ´Ñ–Ñ—:**
- â†—ï¸ All Controllers: Ğ¡Ñ‚Ğ²Ğ¾Ñ€ĞµĞ½Ğ½Ñ Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ñ–Ğ¹ Ğ´Ğ»Ñ Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´/Ğ²Ğ¸Ñ‚Ñ€Ğ°Ñ‚
- â†”ï¸ Supabase: ĞÑ‚Ğ¾Ğ¼Ğ°Ñ€Ğ½Ñ– Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ñ–Ñ— Ğ· Ğ±Ğ°Ğ»Ğ°Ğ½ÑĞ°Ğ¼Ğ¸ Ñ‚Ğ° Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ñ–ÑĞ¼Ğ¸
- â†—ï¸ Analytics: ĞÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ğµ Ğ»Ğ¾Ğ³ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ¿Ğ¾Ğ´Ñ–Ğ¹
- â†—ï¸ User Model: Ğ¡Ğ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ñ–Ğ·Ğ°Ñ†Ñ–Ñ Ğ±Ğ°Ğ»Ğ°Ğ½ÑÑ–Ğ²

---

### `services/verification_service.py` - Task Verification Engine
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: Ğ’ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ Ğ²Ğ¸ĞºĞ¾Ğ½Ğ°Ğ½Ğ½Ñ Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½ÑŒ Ñ€Ñ–Ğ·Ğ½Ğ¸Ñ… Ñ‚Ğ¸Ğ¿Ñ–Ğ²
```

**ĞÑĞ½Ğ¾Ğ²Ğ½Ğ¸Ğ¹ ĞºĞ»Ğ°Ñ:**
```python
class VerificationService:
    def __init__(self):
        self.telegram_service = telegram_service
        self.verification_queue = {}
        self.active_verifications = {}

    # MAIN VERIFICATION METHODS
    async def start_verification(
        self,
        telegram_id: str,
        task_id: str,
        task_type: TaskType,
        verification_data: Dict
    ) -> Dict[str, Any]:
        # ĞŸĞ¾Ñ‡Ğ°Ñ‚Ğ¾Ğº Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑƒ Ğ²ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ—

    async def complete_verification(
        self,
        telegram_id: str,
        task_id: str
    ) -> Dict[str, Any]:
        # Ğ—Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ½Ñ Ğ²ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ— Ñ‚Ğ° Ğ²Ğ¸Ğ´Ğ°Ñ‡Ğ° Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ¸

    # PLATFORM-SPECIFIC VERIFICATION
    async def verify_telegram_task(
        self,
        user_id: int,
        task_data: Dict
    ) -> VerificationResult:
        # Ğ’ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ Telegram Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½ÑŒ

    async def verify_social_task(
        self,
        user_id: int,
        platform: TaskPlatform,
        task_data: Dict
    ) -> VerificationResult:
        # Ğ’ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ ÑĞ¾Ñ†Ñ–Ğ°Ğ»ÑŒĞ½Ğ¸Ñ… Ğ¼ĞµÑ€ĞµĞ¶

    # TIMER-BASED VERIFICATION
    def start_verification_timer(
        self,
        telegram_id: str,
        task_id: str,
        timer_seconds: int
    ) -> None:
        # Ğ—Ğ°Ğ¿ÑƒÑĞº Ñ‚Ğ°Ğ¹Ğ¼ĞµÑ€Ğ° Ğ´Ğ»Ñ Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½ÑŒ Ğ· Ğ·Ğ°Ñ‚Ñ€Ğ¸Ğ¼ĞºĞ¾Ñ

    def check_timer_completion(
        self,
        telegram_id: str,
        task_id: str
    ) -> bool:
        # ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ½Ñ Ñ‚Ğ°Ğ¹Ğ¼ĞµÑ€Ğ°
```

**Verification Result Structure:**
```python
@dataclass
class VerificationResult:
    verified: bool              # Ğ§Ğ¸ Ğ¿Ñ€Ğ¾Ğ¹ÑˆĞ»Ğ° Ğ²ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ
    error_message: str = ""     # ĞŸĞ¾Ğ²Ñ–Ğ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ½Ñ Ğ¿Ñ€Ğ¾ Ğ¿Ğ¾Ğ¼Ğ¸Ğ»ĞºÑƒ
    retry_after: int = 0        # Ğ§ĞµÑ€ĞµĞ· ÑĞºÑ–Ğ»ÑŒĞºĞ¸ ÑĞµĞºÑƒĞ½Ğ´ Ğ¼Ğ¾Ğ¶Ğ½Ğ° Ğ¿Ğ¾Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ñ‚Ğ¸
    metadata: Dict = None       # Ğ”Ğ¾Ğ´Ğ°Ñ‚ĞºĞ¾Ğ²Ñ– Ğ´Ğ°Ğ½Ñ–
```

**Platform-Specific Logic:**
```python
async def verify_telegram_task(self, user_id: int, task_data: Dict) -> VerificationResult:
    """
    Ğ’ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ Telegram Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½ÑŒ
    """
    task_type = task_data.get('type')

    if task_type == TaskType.TELEGRAM_SUBSCRIBE:
        # ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ¿Ñ–Ğ´Ğ¿Ğ¸ÑĞºĞ¸ Ğ½Ğ° ĞºĞ°Ğ½Ğ°Ğ»
        channel_username = task_data['verification_data']['channel_username']

        is_subscribed = await self.telegram_service.check_channel_subscription(
            user_id, channel_username
        )

        if is_subscribed:
            return VerificationResult(verified=True)
        else:
            return VerificationResult(
                verified=False,
                error_message="ĞŸÑ–Ğ´Ğ¿Ğ¸ÑĞºĞ° Ğ½Ğ° ĞºĞ°Ğ½Ğ°Ğ» Ğ½Ğµ Ğ·Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°",
                retry_after=30
            )

    elif task_type == TaskType.TELEGRAM_BOT_START:
        # ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ·Ğ°Ğ¿ÑƒÑĞºÑƒ Ğ±Ğ¾Ñ‚Ğ°
        bot_started = await self.telegram_service.check_bot_started(user_id)

        return VerificationResult(verified=bot_started)

    else:
        return VerificationResult(
            verified=False,
            error_message="ĞĞµĞ²Ñ–Ğ´Ğ¾Ğ¼Ğ¸Ğ¹ Ñ‚Ğ¸Ğ¿ Telegram Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½Ğ½Ñ"
        )

async def verify_social_task(self, user_id: int, platform: TaskPlatform, task_data: Dict) -> VerificationResult:
    """
    Ğ’ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½ÑŒ ÑĞ¾Ñ†Ñ–Ğ°Ğ»ÑŒĞ½Ğ¸Ñ… Ğ¼ĞµÑ€ĞµĞ¶
    """
    if platform == TaskPlatform.YOUTUBE:
        # YouTube Ğ¿Ñ–Ğ´Ğ¿Ğ¸ÑĞºĞ° - Ğ²Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ¾Ğ²ÑƒÑ”Ğ¼Ğ¾ Ñ‚Ğ°Ğ¹Ğ¼ĞµÑ€ + Ñ€ÑƒÑ‡Ğ½Ğ° Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ°
        return VerificationResult(verified=True, metadata={"method": "timer_based"})

    elif platform == TaskPlatform.TWITTER:
        # Twitter Ğ¿Ñ–Ğ´Ğ¿Ğ¸ÑĞºĞ° - Ğ²Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ¾Ğ²ÑƒÑ”Ğ¼Ğ¾ Ñ‚Ğ°Ğ¹Ğ¼ĞµÑ€ + Ñ€ÑƒÑ‡Ğ½Ğ° Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ°
        return VerificationResult(verified=True, metadata={"method": "timer_based"})

    elif platform == TaskPlatform.DISCORD:
        # Discord - Ğ²Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ¾Ğ²ÑƒÑ”Ğ¼Ğ¾ Ñ‚Ğ°Ğ¹Ğ¼ĞµÑ€ + Ñ€ÑƒÑ‡Ğ½Ğ° Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ°
        return VerificationResult(verified=True, metadata={"method": "timer_based"})

    else:
        return VerificationResult(
            verified=False,
            error_message=f"Ğ’ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ Ğ´Ğ»Ñ {platform.value} Ğ½Ğµ Ğ¿Ñ–Ğ´Ñ‚Ñ€Ğ¸Ğ¼ÑƒÑ”Ñ‚ÑŒÑÑ"
        )
```

**Timer-Based Verification:**
```python
class VerificationTimer:
    def __init__(self, telegram_id: str, task_id: str, duration: int):
        self.telegram_id = telegram_id
        self.task_id = task_id
        self.started_at = datetime.now()
        self.duration = duration  # seconds

    def is_completed(self) -> bool:
        elapsed = (datetime.now() - self.started_at).total_seconds()
        return elapsed >= self.duration

    def time_remaining(self) -> int:
        elapsed = (datetime.now() - self.started_at).total_seconds()
        return max(0, self.duration - int(elapsed))

# ĞœĞµĞ½ĞµĞ´Ğ¶ĞµÑ€ Ñ‚Ğ°Ğ¹Ğ¼ĞµÑ€Ñ–Ğ²
verification_timers: Dict[str, VerificationTimer] = {}

def start_verification_timer(telegram_id: str, task_id: str, timer_seconds: int):
    timer_key = f"{telegram_id}:{task_id}"
    verification_timers[timer_key] = VerificationTimer(
        telegram_id, task_id, timer_seconds
    )
```

**Verification Queue Management:**
```python
async def process_verification_queue():
    """
    Ğ¤Ğ¾Ğ½Ğ¾Ğ²Ğ¸Ğ¹ Ğ¿Ñ€Ğ¾Ñ†ĞµÑ Ğ¾Ğ±Ñ€Ğ¾Ğ±ĞºĞ¸ Ñ‡ĞµÑ€Ğ³Ğ¸ Ğ²ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ—
    """
    while True:
        try:
            # ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ… Ñ‚Ğ°Ğ¹Ğ¼ĞµÑ€Ñ–Ğ²
            completed_timers = [
                timer_key for timer_key, timer in verification_timers.items()
                if timer.is_completed()
            ]

            # ĞĞ±Ñ€Ğ¾Ğ±ĞºĞ° Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ¸Ñ… Ğ²ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ğ¹
            for timer_key in completed_timers:
                timer = verification_timers.pop(timer_key)
                await auto_complete_verification(timer.telegram_id, timer.task_id)

            await asyncio.sleep(10)  # ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° ĞºĞ¾Ğ¶Ğ½Ñ– 10 ÑĞµĞºÑƒĞ½Ğ´

        except Exception as e:
            logger.error(f"Verification queue processing error: {e}")
            await asyncio.sleep(30)  # ĞŸÑ€Ğ¸ Ğ¿Ğ¾Ğ¼Ğ¸Ğ»Ñ†Ñ– - Ğ´Ğ¾Ğ²ÑˆĞ° Ğ·Ğ°Ñ‚Ñ€Ğ¸Ğ¼ĞºĞ°
```

**Ğ’Ğ·Ğ°Ñ”Ğ¼Ğ¾Ğ´Ñ–Ñ—:**
- â†—ï¸ Tasks Controller: ĞŸÑ€Ğ¾Ñ†ĞµÑ Ğ²ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ— Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½ÑŒ
- â†—ï¸ Telegram Service: ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Telegram Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½ÑŒ
- â†—ï¸ Transaction Service: Ğ’Ğ¸Ğ´Ğ°Ñ‡Ğ° Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´ Ğ¿Ñ–ÑĞ»Ñ Ğ²ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ—
- â†—ï¸ Analytics: Ğ›Ğ¾Ğ³ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ–Ğ² Ğ²ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ—

---

## ğŸ® CONTROLLERS LAYER - API Coordination

### `controllers/__init__.py` - Controllers Manager
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: Ğ¦ĞµĞ½Ñ‚Ñ€Ğ°Ğ»Ñ–Ğ·Ğ¾Ğ²Ğ°Ğ½Ğµ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»Ñ–Ğ½Ğ½Ñ ĞºĞ¾Ğ½Ñ‚Ñ€Ğ¾Ğ»ĞµÑ€Ğ°Ğ¼Ğ¸
```
**Ğ“Ğ¾Ğ»Ğ¾Ğ²Ğ½Ñ– Ñ„ÑƒĞ½ĞºÑ†Ñ–Ñ—:**
- ğŸ“‹ Registration and initialization of all controllers
- ğŸ¥ Health checking across controllers
- âš ï¸ Error handling coordination
- ğŸ”„ Fallback mechanism when controllers fail

**Controllers Status Tracking:**
```python
controllers_status: Dict[str, Dict[str, Any]] = {
    'analytics': {'loaded': True, 'error': None},
    'auth': {'loaded': True, 'error': None},
    'daily': {'loaded': True, 'error': None},
    'flex': {'loaded': True, 'error': None},
    'tasks': {'loaded': True, 'error': None},
    'transaction': {'loaded': True, 'error': None},
    'user': {'loaded': True, 'error': None},
    'verification': {'loaded': True, 'error': None},
    'wallet': {'loaded': True, 'error': None}
}
```

---

### `controllers/auth_controller.py` - Authentication Controller
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: Telegram WebApp Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ğ·Ğ°Ñ†Ñ–Ñ Ñ‚Ğ° JWT ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»Ñ–Ğ½Ğ½Ñ
```

**Ğ“Ğ¾Ğ»Ğ¾Ğ²Ğ½Ñ– Ñ„ÑƒĞ½ĞºÑ†Ñ–Ñ—:**
```python
def validate_telegram_route():
    # POST /api/auth/validate-telegram
    # Ğ’Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ Telegram WebApp initData Ñ‚Ğ° ÑÑ‚Ğ²Ğ¾Ñ€ĞµĞ½Ğ½Ñ JWT Ñ‚Ğ¾ĞºĞµĞ½Ñƒ

def refresh_token_route():
    # POST /api/auth/refresh-token
    # ĞĞ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ JWT Ñ‚Ğ¾ĞºĞµĞ½Ñƒ

def validate_token_route():
    # GET /api/auth/validate-token
    # ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ñ‡Ğ¸Ğ½Ğ½Ğ¾ÑÑ‚Ñ– JWT Ñ‚Ğ¾ĞºĞµĞ½Ñƒ

def logout_route():
    # POST /api/auth/logout
    # Ğ’Ğ¸Ñ…Ñ–Ğ´ Ğ· ÑĞ¸ÑÑ‚ĞµĞ¼Ğ¸ (Ñ–Ğ½Ğ²Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ Ñ‚Ğ¾ĞºĞµĞ½Ñƒ)
```

**Authentication Flow:**
```python
def validate_telegram_route():
    """
    ĞŸĞ¾Ğ²Ğ½Ğ¸Ğ¹ Ğ¿Ñ€Ğ¾Ñ†ĞµÑ Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ğ·Ğ°Ñ†Ñ–Ñ— Ñ‡ĞµÑ€ĞµĞ· Telegram WebApp
    """
    try:
        # 1. ĞÑ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ Ñ‚Ğ° Ğ²Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ initData
        request_data = request.get_json()
        init_data = request_data.get('initData')

        if not init_data:
            return error_response("initData is required", 400)

        # 2. Ğ’Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ Ñ‡ĞµÑ€ĞµĞ· Telegram Service
        validation_result = telegram_service.validate_webapp_data(init_data)

        if not validation_result['valid']:
            return error_response("Invalid Telegram data", 401)

        # 3. ĞĞ±Ñ€Ğ¾Ğ±ĞºĞ° Ğ´Ğ°Ğ½Ğ¸Ñ… ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ°
        user_data = validation_result['user']
        telegram_id = str(user_data['id'])
        username = user_data.get('username', '')

        # 4. ĞÑ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ Ğ°Ğ±Ğ¾ ÑÑ‚Ğ²Ğ¾Ñ€ĞµĞ½Ğ½Ñ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ°
        user = get_user(telegram_id)
        if not user:
            # Ğ¡Ñ‚Ğ²Ğ¾Ñ€ĞµĞ½Ğ½Ñ Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ°
            referrer_id = request_data.get('referrer_id')
            user = create_user(telegram_id, username, referrer_id)

            if user:
                # Ğ’Ñ–Ñ‚Ğ°Ğ»ÑŒĞ½Ğ¸Ğ¹ Ğ±Ğ¾Ğ½ÑƒÑ Ğ´Ğ»Ñ Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ°
                welcome_bonus = transaction_service.process_welcome_bonus(telegram_id)
                asyncio.create_task(
                    analytics_db.save_event(AnalyticsEvent(
                        user_id=telegram_id,
                        event_type=EventType.AUTH,
                        event_data={"action": "new_user_created", "welcome_bonus": welcome_bonus}
                    ))
                )

        # 5. Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ñ–Ñ JWT Ñ‚Ğ¾ĞºĞµĞ½Ñƒ
        token_payload = {
            'user_id': user['id'],
            'telegram_id': telegram_id,
            'username': username,
            'exp': datetime.utcnow() + timedelta(days=7)
        }

        jwt_token = generate_jwt_token(token_payload)

        # 6. Ğ›Ğ¾Ğ³ÑƒĞ²Ğ°Ğ½Ğ½Ñ ÑƒÑĞ¿Ñ–ÑˆĞ½Ğ¾Ñ— Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ğ·Ğ°Ñ†Ñ–Ñ—
        asyncio.create_task(
            analytics_db.save_event(AnalyticsEvent(
                user_id=telegram_id,
                event_type=EventType.AUTH,
                event_data={"action": "login_success", "method": "telegram_webapp"}
            ))
        )

        # 7. Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´ÑŒ Ğ· Ğ´Ğ°Ğ½Ğ¸Ğ¼Ğ¸ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ° Ñ‚Ğ° Ñ‚Ğ¾ĞºĞµĞ½Ğ¾Ğ¼
        return success_response({
            'token': jwt_token,
            'user': {
                'id': user['id'],
                'telegram_id': telegram_id,
                'username': username,
                'balance': {
                    'winix': user.get('winix', 0),
                    'tickets': user.get('tickets', 0)
                },
                'level': user.get('level', 1),
                'created_at': user.get('created_at')
            },
            'expires_in': 604800  # 7 Ğ´Ğ½Ñ–Ğ² Ñƒ ÑĞµĞºÑƒĞ½Ğ´Ğ°Ñ…
        })

    except Exception as e:
        logger.error(f"Authentication error: {e}", exc_info=True)
        return error_response("Authentication failed", 500)
```

**JWT Token Management:**
```python
def generate_jwt_token(payload: Dict) -> str:
    """
    Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ñ–Ñ JWT Ñ‚Ğ¾ĞºĞµĞ½Ñƒ Ğ· Ğ¿Ñ–Ğ´Ğ¿Ğ¸ÑĞ¾Ğ¼
    """
    secret_key = os.getenv('JWT_SECRET_KEY')
    algorithm = 'HS256'

    return jwt.encode(payload, secret_key, algorithm=algorithm)

def decode_jwt_token(token: str) -> Dict[str, Any]:
    """
    Ğ”ĞµĞºĞ¾Ğ´ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ñ‚Ğ° Ğ²Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ JWT Ñ‚Ğ¾ĞºĞµĞ½Ñƒ
    """
    try:
        secret_key = os.getenv('JWT_SECRET_KEY')
        payload = jwt.decode(token, secret_key, algorithms=['HS256'])
        return {'valid': True, 'payload': payload}
    except jwt.ExpiredSignatureError:
        return {'valid': False, 'error': 'Token expired'}
    except jwt.InvalidTokenError:
        return {'valid': False, 'error': 'Invalid token'}
```

**Ğ’Ğ·Ğ°Ñ”Ğ¼Ğ¾Ğ´Ñ–Ñ—:**
- â†—ï¸ Telegram Service: Ğ’Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ WebApp Ğ´Ğ°Ğ½Ğ¸Ñ…
- â†—ï¸ User Model: Ğ¡Ñ‚Ğ²Ğ¾Ñ€ĞµĞ½Ğ½Ñ/Ğ¾Ñ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ñ–Ğ²
- â†—ï¸ Transaction Service: Ğ’Ñ–Ñ‚Ğ°Ğ»ÑŒĞ½Ñ– Ğ±Ğ¾Ğ½ÑƒÑĞ¸
- â†—ï¸ Analytics: Ğ›Ğ¾Ğ³ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ğ·Ğ°Ñ†Ñ–Ñ—

---

### `controllers/daily_controller.py` - Daily Bonus Controller
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: Ğ£Ğ¿Ñ€Ğ°Ğ²Ğ»Ñ–Ğ½Ğ½Ñ Ñ‰Ğ¾Ğ´ĞµĞ½Ğ½Ğ¸Ğ¼Ğ¸ Ğ±Ğ¾Ğ½ÑƒÑĞ°Ğ¼Ğ¸ Ğ· Transaction Service Ñ–Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ñ–Ñ”Ñ
```

**Ğ“Ğ¾Ğ»Ğ¾Ğ²Ğ½Ñ– Ñ„ÑƒĞ½ĞºÑ†Ñ–Ñ—:**
```python
def get_daily_status_route():
    # GET /api/daily/status/{telegram_id}
    # ĞÑ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ Ğ¿Ğ¾Ñ‚Ğ¾Ñ‡Ğ½Ğ¾Ğ³Ğ¾ ÑÑ‚Ğ°Ñ‚ÑƒÑÑƒ Ñ‰Ğ¾Ğ´ĞµĞ½Ğ½Ğ¸Ñ… Ğ±Ğ¾Ğ½ÑƒÑÑ–Ğ²

def claim_daily_bonus_route():
    # POST /api/daily/claim/{telegram_id}
    # ĞÑ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ Ñ‰Ğ¾Ğ´ĞµĞ½Ğ½Ğ¾Ğ³Ğ¾ Ğ±Ğ¾Ğ½ÑƒÑÑƒ Ñ‡ĞµÑ€ĞµĞ· Transaction Service

def get_daily_history_route():
    # GET /api/daily/history/{telegram_id}
    # Ğ†ÑÑ‚Ğ¾Ñ€Ñ–Ñ Ğ¾Ñ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ Ñ‰Ğ¾Ğ´ĞµĞ½Ğ½Ğ¸Ñ… Ğ±Ğ¾Ğ½ÑƒÑÑ–Ğ²

def calculate_reward_for_day_route():
    # GET /api/daily/preview/{telegram_id}
    # ĞŸĞ¾Ğ¿ĞµÑ€ĞµĞ´Ğ½Ñ–Ğ¹ Ğ¿ĞµÑ€ĞµĞ³Ğ»ÑĞ´ Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ¸ Ğ½Ğ° Ğ½Ğ°ÑÑ‚ÑƒĞ¿Ğ½Ñ– Ğ´Ğ½Ñ–
```

**Ğ”ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ğ° Ñ€ĞµĞ°Ğ»Ñ–Ğ·Ğ°Ñ†Ñ–Ñ claim_daily_bonus:**
```python
def claim_daily_bonus_route():
    """
    ĞÑĞ½Ğ¾Ğ²Ğ½Ğ° Ñ„ÑƒĞ½ĞºÑ†Ñ–Ñ Ğ¾Ñ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ Ñ‰Ğ¾Ğ´ĞµĞ½Ğ½Ğ¾Ğ³Ğ¾ Ğ±Ğ¾Ğ½ÑƒÑÑƒ
    """
    try:
        # 1. Ğ’Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ°
        telegram_id = request.view_args.get('telegram_id')
        validated_id = validate_telegram_id(telegram_id)

        if not validated_id:
            return error_response("Invalid telegram_id", 400)

        # 2. ĞÑ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ ÑÑ‚Ğ°Ñ‚ÑƒÑÑƒ Ñ‰Ğ¾Ğ´ĞµĞ½Ğ½Ğ¸Ñ… Ğ±Ğ¾Ğ½ÑƒÑÑ–Ğ²
        daily_status = daily_bonus_manager.get_user_status(validated_id)

        if not daily_status.can_claim:
            time_remaining = daily_status.time_until_next_claim()
            return error_response(
                f"Cannot claim yet. Wait {time_remaining}", 400
            )

        # 3. Ğ Ğ¾Ğ·Ñ€Ğ°Ñ…ÑƒĞ½Ğ¾Ğº Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ¸
        user = get_user(validated_id)
        if not user:
            return error_response("User not found", 404)

        reward = reward_calculator.calculate_daily_bonus(
            day_number=daily_status.current_day_number,
            current_streak=daily_status.current_streak,
            user_level=user.get('level', 1),
            bonus_multiplier=1.0
        )

        # 4. ĞĞ±Ñ€Ğ¾Ğ±ĞºĞ° Ñ‡ĞµÑ€ĞµĞ· Transaction Service (PREFERRED METHOD)
        if transaction_service:
            transaction_result = transaction_service.process_daily_bonus(
                telegram_id=str(validated_id),
                winix_amount=reward.winix,
                tickets_amount=reward.tickets,
                day_number=daily_status.current_day_number,
                streak=daily_status.current_streak
            )

            if transaction_result['success']:
                # ĞĞ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ ÑÑ‚Ğ°Ñ‚ÑƒÑÑƒ Ñ‰Ğ¾Ğ´ĞµĞ½Ğ½Ğ¸Ñ… Ğ±Ğ¾Ğ½ÑƒÑÑ–Ğ²
                daily_bonus_manager.mark_claimed(validated_id)

                # ĞÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ğµ Ğ»Ğ¾Ğ³ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ°Ğ½Ğ°Ğ»Ñ–Ñ‚Ğ¸ĞºĞ¸
                asyncio.create_task(
                    analytics_db.save_event(AnalyticsEvent(
                        user_id=str(validated_id),
                        event_type=EventType.DAILY,
                        event_data={
                            "action": "daily_bonus_claimed",
                            "day_number": daily_status.current_day_number,
                            "streak": daily_status.current_streak,
                            "reward": reward.__dict__,
                            "method": "transaction_service"
                        }
                    ))
                )

                return success_response({
                    'claimed': True,
                    'reward': {
                        'winix': reward.winix,
                        'tickets': reward.tickets
                    },
                    'new_balance': transaction_result['new_balance'],
                    'day_number': daily_status.current_day_number + 1,
                    'streak': daily_status.current_streak + 1,
                    'transaction_id': transaction_result['transaction_id']
                })
            else:
                return error_response(
                    f"Transaction failed: {transaction_result['error']}", 500
                )

        # 5. Fallback Ğ´Ğ¾ Ğ¿Ñ€ÑĞ¼Ğ¸Ñ… DB Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ñ–Ğ¹
        else:
            logger.warning("Transaction Service Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¸Ğ¹, Ğ²Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ¾Ğ²ÑƒÑ”Ğ¼Ğ¾ fallback")

            success_operations = []

            # ĞŸÑ€ÑĞ¼Ñ– Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ñ–Ñ— Ğ· Ğ±Ğ°Ğ·Ğ¾Ñ Ğ´Ğ°Ğ½Ğ¸Ñ…
            if reward.winix > 0:
                winix_updated = update_balance(validated_id, reward.winix)
                if winix_updated:
                    success_operations.append(f"WINIX +{reward.winix}")

            if reward.tickets > 0:
                tickets_updated = update_coins(validated_id, reward.tickets)
                if tickets_updated:
                    success_operations.append(f"Tickets +{reward.tickets}")

            if success_operations:
                # ĞĞ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ ÑÑ‚Ğ°Ñ‚ÑƒÑÑƒ
                daily_bonus_manager.mark_claimed(validated_id)

                # Ğ¡Ñ‚Ğ²Ğ¾Ñ€ĞµĞ½Ğ½Ñ Ğ·Ğ°Ğ¿Ğ¸ÑÑƒ Ğ² Ñ–ÑÑ‚Ğ¾Ñ€Ñ–Ñ—
                daily_bonus_manager.create_history_entry(
                    validated_id, daily_status.current_day_number, reward
                )

                return success_response({
                    'claimed': True,
                    'reward': {'winix': reward.winix, 'tickets': reward.tickets},
                    'operations': success_operations,
                    'day_number': daily_status.current_day_number + 1,
                    'method': 'fallback'
                })
            else:
                return error_response("Failed to process reward", 500)

    except Exception as e:
        logger.error(f"Daily bonus claim error: {e}", exc_info=True)
        return error_response("Internal server error", 500)
```

**Ğ’Ğ·Ğ°Ñ”Ğ¼Ğ¾Ğ´Ñ–Ñ—:**
- â†—ï¸ Daily Bonus Model: Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑĞ¸ Ñ‚Ğ° ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»Ñ–Ğ½Ğ½Ñ
- â†—ï¸ Reward Calculator: Ğ Ğ¾Ğ·Ñ€Ğ°Ñ…ÑƒĞ½ĞºĞ¸ Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´
- â†—ï¸ Transaction Service: ĞÑ‚Ğ¾Ğ¼Ğ°Ñ€Ğ½Ğµ Ğ½Ğ°Ñ€Ğ°Ñ…ÑƒĞ²Ğ°Ğ½Ğ½Ñ (preferred)
- â†—ï¸ Analytics: Ğ›Ğ¾Ğ³ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ¿Ğ¾Ğ´Ñ–Ğ¹
- â†—ï¸ Supabase: Fallback Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ñ–Ñ—

---

### `controllers/flex_controller.py` - FLEX Rewards Controller
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: FLEX Ñ‚Ğ¾ĞºĞµĞ½Ğ¸, Ñ€Ñ–Ğ²Ğ½Ñ– Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´, TON blockchain Ñ–Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ñ–Ñ
```

**Ğ“Ğ¾Ğ»Ğ¾Ğ²Ğ½Ñ– Ñ„ÑƒĞ½ĞºÑ†Ñ–Ñ—:**
```python
def get_flex_balance_route():
    # GET /api/flex/balance/{telegram_id}
    # ĞÑ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ Ğ¿Ğ¾Ñ‚Ğ¾Ñ‡Ğ½Ğ¾Ğ³Ğ¾ Ğ±Ğ°Ğ»Ğ°Ğ½ÑÑƒ FLEX Ñ‚Ğ¾ĞºĞµĞ½Ñ–Ğ² Ğ· blockchain

def check_flex_levels_route():
    # GET /api/flex/levels/{telegram_id}
    # ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¸Ñ… Ñ€Ñ–Ğ²Ğ½Ñ–Ğ² Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´

def claim_flex_reward_route():
    # POST /api/flex/claim/{telegram_id}
    # ĞÑ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ¸ Ğ·Ğ° FLEX Ñ€Ñ–Ğ²ĞµĞ½ÑŒ

def get_flex_history_route():
    # GET /api/flex/history/{telegram_id}
    # Ğ†ÑÑ‚Ğ¾Ñ€Ñ–Ñ Ğ¾Ñ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ FLEX Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´
```

**Ğ ĞµĞ°Ğ»Ñ–Ğ·Ğ°Ñ†Ñ–Ñ claim_flex_reward:**
```python
def claim_flex_reward_route():
    """
    ĞÑ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ¸ Ğ·Ğ° FLEX Ñ€Ñ–Ğ²ĞµĞ½ÑŒ
    """
    try:
        # 1. Ğ’Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ Ğ²Ñ…Ñ–Ğ´Ğ½Ğ¸Ñ… Ğ´Ğ°Ğ½Ğ¸Ñ…
        telegram_id = request.view_args.get('telegram_id')
        validated_id = validate_telegram_id(telegram_id)

        request_data = request.get_json()
        requested_level = request_data.get('level')

        if not requested_level or requested_level not in flex_rewards_model.LEVELS:
            return error_response("Invalid FLEX level", 400)

        # 2. ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ¿Ñ–Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ½Ñ Ğ³Ğ°Ğ¼Ğ°Ğ½Ñ†Ñ
        user = get_user(validated_id)
        if not user:
            return error_response("User not found", 404)

        wallet_info = get_user_wallet_info(validated_id)
        if not wallet_info or wallet_info.get('status') != 'connected':
            return error_response("Wallet not connected", 400)

        # 3. ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° FLEX Ğ±Ğ°Ğ»Ğ°Ğ½ÑÑƒ Ñ‡ĞµÑ€ĞµĞ· TON Connect
        wallet_address = wallet_info['address']

        if ton_connect_service:
            try:
                ton_balance = await ton_connect_service.get_flex_balance(wallet_address)

                # ĞĞ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ ĞºĞµÑˆĞ¾Ğ²Ğ°Ğ½Ğ¾Ğ³Ğ¾ Ğ±Ğ°Ğ»Ğ°Ğ½ÑÑƒ
                flex_rewards_model.update_flex_balance(
                    validated_id, ton_balance, wallet_address
                )

            except Exception as e:
                logger.error(f"TON Connect error: {e}")
                # Ğ’Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ¾Ğ²ÑƒÑ”Ğ¼Ğ¾ ĞºĞµÑˆĞ¾Ğ²Ğ°Ğ½Ğ¸Ğ¹ Ğ±Ğ°Ğ»Ğ°Ğ½Ñ
                ton_balance = flex_rewards_model.get_cached_balance(validated_id)
        else:
            # Fallback Ğ´Ğ¾ ĞºĞµÑˆĞ¾Ğ²Ğ°Ğ½Ğ¾Ğ³Ğ¾ Ğ±Ğ°Ğ»Ğ°Ğ½ÑÑƒ
            ton_balance = flex_rewards_model.get_cached_balance(validated_id)

        # 4. Ğ’Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ Ğ¿Ñ€Ğ°Ğ²Ğ° Ğ½Ğ° Ğ¾Ñ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ
        level_config = flex_rewards_model.LEVELS[requested_level]

        if ton_balance < level_config.required_flex:
            return error_response(
                f"Insufficient FLEX. Required: {level_config.required_flex}, "
                f"Current: {ton_balance}", 400
            )

        # ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° cooldown
        can_claim, cooldown_remaining = flex_rewards_model.can_claim_level(
            validated_id, requested_level
        )

        if not can_claim:
            return error_response(
                f"Cooldown active. Wait {cooldown_remaining}", 400
            )

        # 5. ĞĞ±Ñ€Ğ¾Ğ±ĞºĞ° Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ¸ Ñ‡ĞµÑ€ĞµĞ· Transaction Service
        if transaction_service:
            transaction_result = transaction_service.process_flex_reward(
                telegram_id=str(validated_id),
                winix_amount=level_config.reward_winix,
                tickets_amount=level_config.reward_tickets,
                flex_level=requested_level,
                flex_balance=ton_balance
            )

            if transaction_result['success']:
                # Ğ’ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ cooldown
                flex_rewards_model.set_level_cooldown(validated_id, requested_level)

                # Ğ›Ğ¾Ğ³ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ² flex_claims
                flex_rewards_model.create_claim_record(
                    validated_id, requested_level, ton_balance, level_config
                )

                # ĞĞ½Ğ°Ğ»Ñ–Ñ‚Ğ¸ĞºĞ°
                asyncio.create_task(
                    analytics_db.save_event(AnalyticsEvent(
                        user_id=str(validated_id),
                        event_type=EventType.FLEX,
                        event_data={
                            "action": "flex_reward_claimed",
                            "level": requested_level,
                            "flex_balance": ton_balance,
                            "reward": {
                                "winix": level_config.reward_winix,
                                "tickets": level_config.reward_tickets
                            }
                        }
                    ))
                )

                return success_response({
                    'claimed': True,
                    'level': requested_level,
                    'reward': {
                        'winix': level_config.reward_winix,
                        'tickets': level_config.reward_tickets
                    },
                    'flex_balance': ton_balance,
                    'new_balance': transaction_result['new_balance'],
                    'cooldown_until': flex_rewards_model.get_cooldown_end(
                        validated_id, requested_level
                    )
                })
            else:
                return error_response(
                    f"Transaction failed: {transaction_result['error']}", 500
                )

        # 6. Fallback Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ñ–Ñ—
        else:
            # ĞŸÑ€ÑĞ¼Ñ– DB Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ñ–Ñ— ÑĞº fallback
            reward_given = False

            if level_config.reward_winix > 0:
                winix_updated = update_balance(validated_id, level_config.reward_winix)
                reward_given = winix_updated

            if level_config.reward_tickets > 0:
                tickets_updated = update_coins(validated_id, level_config.reward_tickets)
                reward_given = reward_given or tickets_updated

            if reward_given:
                flex_rewards_model.set_level_cooldown(validated_id, requested_level)
                return success_response({
                    'claimed': True,
                    'level': requested_level,
                    'method': 'fallback'
                })
            else:
                return error_response("Failed to process FLEX reward", 500)

    except Exception as e:
        logger.error(f"FLEX claim error: {e}", exc_info=True)
        return error_response("Internal server error", 500)
```

**Ğ’Ğ·Ğ°Ñ”Ğ¼Ğ¾Ğ´Ñ–Ñ—:**
- â†—ï¸ FLEX Rewards Model: Ğ Ñ–Ğ²Ğ½Ñ– Ñ‚Ğ° ÑÑ‚Ğ°Ñ‚ÑƒÑĞ¸
- â†—ï¸ TON Connect Service: Blockchain Ğ±Ğ°Ğ»Ğ°Ğ½ÑĞ¸
- â†—ï¸ Transaction Service: ĞÑ‚Ğ¾Ğ¼Ğ°Ñ€Ğ½Ğµ Ğ½Ğ°Ñ€Ğ°Ñ…ÑƒĞ²Ğ°Ğ½Ğ½Ñ
- â†—ï¸ Wallet Model: Ğ†Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ñ–Ñ Ğ¿Ñ€Ğ¾ Ğ³Ğ°Ğ¼Ğ°Ğ½ĞµÑ†ÑŒ
- â†—ï¸ Analytics: Ğ›Ğ¾Ğ³ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ¿Ğ¾Ğ´Ñ–Ğ¹

---

### `controllers/tasks_controller.py` - Tasks Management Controller
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: CRUD Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½ÑŒ, Ğ²ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ, Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡Ğ½Ğµ Ğ½Ğ°Ñ€Ğ°Ñ…ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´
```

**Ğ“Ğ¾Ğ»Ğ¾Ğ²Ğ½Ñ– Ñ„ÑƒĞ½ĞºÑ†Ñ–Ñ—:**
```python
def get_tasks_list_route():
    # GET /api/tasks/list/{telegram_id}
    # Ğ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¸Ñ… Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½ÑŒ Ğ· Ñ„Ñ–Ğ»ÑŒÑ‚Ñ€Ğ°Ñ†Ñ–Ñ”Ñ Ğ²Ğ¸ĞºĞ¾Ğ½Ğ°Ğ½Ğ¸Ñ…

def get_task_details_route():
    # GET /api/tasks/details/{task_id}
    # Ğ”ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ğ° Ñ–Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ñ–Ñ Ğ¿Ñ€Ğ¾ Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½Ğ½Ñ

def start_task_route():
    # POST /api/tasks/start/{telegram_id}/{task_id}
    # ĞŸĞ¾Ñ‡Ğ°Ñ‚Ğ¾Ğº Ğ²Ğ¸ĞºĞ¾Ğ½Ğ°Ğ½Ğ½Ñ Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½Ğ½Ñ

def verify_task_route():
    # POST /api/tasks/verify/{telegram_id}/{task_id}
    # Ğ’ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ Ğ²Ğ¸ĞºĞ¾Ğ½Ğ°Ğ½Ğ½Ñ + Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡Ğ½Ğ° Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ°

def get_user_task_progress_route():
    # GET /api/tasks/progress/{telegram_id}
    # ĞŸÑ€Ğ¾Ğ³Ñ€ĞµÑ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ° Ğ¿Ğ¾ Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½Ğ½ÑÑ…

def create_task_route():
    # POST /api/tasks/create (admin only)
    # Ğ¡Ñ‚Ğ²Ğ¾Ñ€ĞµĞ½Ğ½Ñ Ğ½Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½Ğ½Ñ
```

**Lifecycle Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½Ğ½Ñ - verify_task_route:**
```python
def verify_task_route():
    """
    Ğ’ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½Ğ½Ñ Ğ· Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡Ğ½Ğ¸Ğ¼ Ğ½Ğ°Ñ€Ğ°Ñ…ÑƒĞ²Ğ°Ğ½Ğ½ÑĞ¼ Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ¸
    """
    try:
        # 1. Ğ’Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ñ–Ğ²
        telegram_id = request.view_args.get('telegram_id')
        task_id = request.view_args.get('task_id')

        validated_id = validate_telegram_id(telegram_id)
        if not validated_id:
            return error_response("Invalid telegram_id", 400)

        # 2. ĞÑ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½Ğ½Ñ Ñ‚Ğ° Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ñ–ÑĞ½ÑƒĞ²Ğ°Ğ½Ğ½Ñ
        task = task_model.get_task_by_id(task_id)
        if not task:
            return error_response("Task not found", 404)

        # 3. ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ñ‡Ğ¸ Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½Ğ½Ñ Ğ²Ğ¶Ğµ Ğ²Ğ¸ĞºĞ¾Ğ½Ğ°Ğ½Ğ¾
        user_progress = task_model.get_user_task_progress(validated_id)
        completed_tasks = [p['task_id'] for p in user_progress if p['status'] == 'completed']

        if task_id in completed_tasks:
            return error_response("Task already completed", 400)

        # 4. ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ñ‡Ğ¸ Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½Ğ½Ñ Ğ±ÑƒĞ»Ğ¾ Ñ€Ğ¾Ğ·Ğ¿Ğ¾Ñ‡Ğ°Ñ‚Ğ¾
        task_progress = next(
            (p for p in user_progress if p['task_id'] == task_id), None
        )

        if not task_progress or task_progress['status'] != 'started':
            return error_response("Task not started", 400)

        # 5. Ğ’ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ Ñ‡ĞµÑ€ĞµĞ· Verification Service
        if verification_service:
            verification_result = await verification_service.complete_verification(
                telegram_id=str(validated_id),
                task_id=task_id
            )

            if not verification_result['verified']:
                # ĞĞ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ ÑÑ‚Ğ°Ñ‚ÑƒÑÑƒ ÑĞº failed
                task_model.update_task_progress(
                    validated_id, task_id, 'failed',
                    {'error': verification_result.get('error', 'Verification failed')}
                )

                return error_response(
                    verification_result.get('error', 'Task verification failed'), 400
                )

        # 6. Ğ’ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ Ğ¿Ñ€Ğ¾Ğ¹Ğ´ĞµĞ½Ğ¾ - Ğ½Ğ°Ñ€Ğ°Ñ…Ğ¾Ğ²ÑƒÑ”Ğ¼Ğ¾ Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ñƒ
        task_reward = task.get('reward', {})
        winix_reward = task_reward.get('winix', 0)
        tickets_reward = task_reward.get('tickets', 0)

        if transaction_service and (winix_reward > 0 or tickets_reward > 0):
            # ĞÑ‚Ğ¾Ğ¼Ğ°Ñ€Ğ½Ğµ Ğ½Ğ°Ñ€Ğ°Ñ…ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ñ‡ĞµÑ€ĞµĞ· Transaction Service
            reward_result = transaction_service.process_task_reward(
                telegram_id=str(validated_id),
                winix_amount=winix_reward,
                tickets_amount=tickets_reward,
                task_id=task_id,
                task_type=task.get('type', 'unknown')
            )

            if reward_result['success']:
                # ĞŸĞ¾Ğ·Ğ½Ğ°Ñ‡Ğ°Ñ”Ğ¼Ğ¾ Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½Ğ½Ñ ÑĞº Ğ²Ğ¸ĞºĞ¾Ğ½Ğ°Ğ½Ğµ
                task_model.update_task_progress(
                    validated_id, task_id, 'completed',
                    {
                        'completed_at': datetime.now().isoformat(),
                        'reward_given': True,
                        'transaction_id': reward_result['transaction_id']
                    }
                )

                # Ğ¡Ñ‚Ğ²Ğ¾Ñ€ĞµĞ½Ğ½Ñ Ğ·Ğ°Ğ¿Ğ¸ÑÑƒ Ğ² completed_tasks
                task_model.create_completed_task_record(
                    validated_id, task_id, task['type'], task_reward
                )

                # ĞĞ½Ğ°Ğ»Ñ–Ñ‚Ğ¸ĞºĞ°
                asyncio.create_task(
                    analytics_db.save_event(AnalyticsEvent(
                        user_id=str(validated_id),
                        event_type=EventType.TASK,
                        event_data={
                            "action": "task_completed",
                            "task_id": task_id,
                            "task_type": task['type'],
                            "reward": task_reward,
                            "verification_method": verification_result.get('method', 'unknown')
                        }
                    ))
                )

                return success_response({
                    'verified': True,
                    'completed': True,
                    'reward': task_reward,
                    'new_balance': reward_result['new_balance'],
                    'transaction_id': reward_result['transaction_id']
                })
            else:
                # Ğ¢Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ñ–Ñ Ğ½Ğµ Ğ¿Ñ€Ğ¾Ğ¹ÑˆĞ»Ğ°, Ğ°Ğ»Ğµ Ğ²ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ ÑƒÑĞ¿Ñ–ÑˆĞ½Ğ°
                task_model.update_task_progress(
                    validated_id, task_id, 'completed',
                    {
                        'completed_at': datetime.now().isoformat(),
                        'reward_given': False,
                        'error': f"Reward failed: {reward_result['error']}"
                    }
                )

                return success_response({
                    'verified': True,
                    'completed': True,
                    'reward_given': False,
                    'error': 'Reward processing failed'
                })

        # 7. Ğ—Ğ°Ğ²Ğ´Ğ°Ğ½Ğ½Ñ Ğ±ĞµĞ· Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ¸ Ğ°Ğ±Ğ¾ fallback
        else:
            # ĞŸĞ¾Ğ·Ğ½Ğ°Ñ‡Ğ°Ñ”Ğ¼Ğ¾ ÑĞº Ğ²Ğ¸ĞºĞ¾Ğ½Ğ°Ğ½Ğµ Ğ±ĞµĞ· Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ¸
            task_model.update_task_progress(
                validated_id, task_id, 'completed',
                {'completed_at': datetime.now().isoformat()}
            )

            return success_response({
                'verified': True,
                'completed': True,
                'reward': task_reward if task_reward else None
            })

    except Exception as e:
        logger.error(f"Task verification error: {e}", exc_info=True)
        return error_response("Internal server error", 500)
```

**Ğ’Ğ·Ğ°Ñ”Ğ¼Ğ¾Ğ´Ñ–Ñ—:**
- â†—ï¸ Task Model: CRUD Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ñ–Ñ— Ğ· Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½Ğ½ÑĞ¼Ğ¸
- â†—ï¸ Verification Service: ĞŸÑ€Ğ¾Ñ†ĞµÑ Ğ²ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ—
- â†—ï¸ Transaction Service: ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡Ğ½Ñ– Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ¸
- â†—ï¸ Analytics: Ğ›Ğ¾Ğ³ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½ÑŒ Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½ÑŒ

---

### `controllers/user_controller.py` - User Management Controller
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: ĞŸÑ€Ğ¾Ñ„Ñ–Ğ»Ñ– ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ñ–Ğ², Ğ±Ğ°Ğ»Ğ°Ğ½ÑĞ¸, ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°
```

**Ğ“Ğ¾Ğ»Ğ¾Ğ²Ğ½Ñ– Ñ„ÑƒĞ½ĞºÑ†Ñ–Ñ—:**
```python
def get_user_profile_route():
    # GET /api/user/profile/{telegram_id}
    # ĞŸĞ¾Ğ²Ğ½Ğ¸Ğ¹ Ğ¿Ñ€Ğ¾Ñ„Ñ–Ğ»ÑŒ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ° Ğ· Ğ²ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ”Ñ Ñ‡ĞµÑ€ĞµĞ· Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ñ–Ñ—

def get_user_balance_route():
    # GET /api/user/balance/{telegram_id}
    # Ğ‘Ğ°Ğ»Ğ°Ğ½ÑĞ¸ Ğ· cross-verification Ñ‡ĞµÑ€ĞµĞ· Transaction Service

def update_user_balance_route():
    # PUT /api/user/balance/{telegram_id}
    # ĞĞ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ Ğ±Ğ°Ğ»Ğ°Ğ½ÑÑƒ Ñ‡ĞµÑ€ĞµĞ· Transaction Service

def get_user_stats_route():
    # GET /api/user/stats/{telegram_id}
    # Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° Ğ· Ğ°Ğ½Ğ°Ğ»Ñ–Ñ‚Ğ¸ĞºĞ¸ Ñ‚Ğ° Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ñ–Ğ¹
```

**Integration Pattern Ğ· Transaction Service:**
```python
def get_user_balance_route():
    """
    ĞÑ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ Ğ±Ğ°Ğ»Ğ°Ğ½ÑÑƒ Ğ· cross-verification
    """
    try:
        telegram_id = request.view_args.get('telegram_id')
        validated_id = validate_telegram_id(telegram_id)

        # 1. ĞÑ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ Ğ±Ğ°Ğ·Ğ¾Ğ²Ğ¸Ñ… Ğ´Ğ°Ğ½Ğ¸Ñ… ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ°
        user = get_user(validated_id)
        if not user:
            return error_response("User not found", 404)

        # 2. Cross-verification Ñ‡ĞµÑ€ĞµĞ· Transaction Service
        balance_from_db = {
            'winix': user.get('winix', 0),
            'tickets': user.get('tickets', 0)
        }

        if transaction_service:
            # ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ±Ğ°Ğ»Ğ°Ğ½ÑÑƒ Ñ‡ĞµÑ€ĞµĞ· Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ñ–Ñ—
            transaction_balance = transaction_service.get_user_balance_summary(
                str(validated_id)
            )

            # ĞŸĞ¾Ñ€Ñ–Ğ²Ğ½ÑĞ½Ğ½Ñ Ñ‚Ğ° Ğ²Ğ¸ÑĞ²Ğ»ĞµĞ½Ğ½Ñ Ñ€Ğ¾Ğ·Ğ±Ñ–Ğ¶Ğ½Ğ¾ÑÑ‚ĞµĞ¹
            discrepancies = {}
            if balance_from_db['winix'] != transaction_balance.get('winix', 0):
                discrepancies['winix'] = {
                    'db': balance_from_db['winix'],
                    'transactions': transaction_balance.get('winix', 0)
                }

            if balance_from_db['tickets'] != transaction_balance.get('tickets', 0):
                discrepancies['tickets'] = {
                    'db': balance_from_db['tickets'],
                    'transactions': transaction_balance.get('tickets', 0)
                }

            if discrepancies:
                # Ğ›Ğ¾Ğ³ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ñ€Ğ¾Ğ·Ğ±Ñ–Ğ¶Ğ½Ğ¾ÑÑ‚ĞµĞ¹ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ´Ğ°Ğ»ÑŒÑˆĞ¾Ñ— ĞºĞ¾Ñ€ĞµĞºÑ†Ñ–Ñ—
                logger.warning(
                    f"Balance discrepancy for user {validated_id}: {discrepancies}"
                )

                # ĞĞ½Ğ°Ğ»Ñ–Ñ‚Ğ¸Ñ‡Ğ½Ğ° Ğ¿Ğ¾Ğ´Ñ–Ñ Ğ¿Ñ€Ğ¾ Ñ€Ğ¾Ğ·Ğ±Ñ–Ğ¶Ğ½Ñ–ÑÑ‚ÑŒ
                asyncio.create_task(
                    analytics_db.save_event(AnalyticsEvent(
                        user_id=str(validated_id),
                        event_type=EventType.ERROR,
                        event_data={
                            "action": "balance_discrepancy_detected",
                            "discrepancies": discrepancies
                        },
                        severity=EventSeverity.WARNING
                    ))
                )

        # 3. ĞŸĞ¾Ğ²ĞµÑ€Ğ½ĞµĞ½Ğ½Ñ Ğ±Ğ°Ğ»Ğ°Ğ½ÑÑƒ (Ğ· DB ÑĞº primary source)
        return success_response({
            'telegram_id': validated_id,
            'balance': balance_from_db,
            'verified': discrepancies == {} if transaction_service else None,
            'last_updated': user.get('updated_at')
        })

    except Exception as e:
        logger.error(f"Balance retrieval error: {e}", exc_info=True)
        return error_response("Internal server error", 500)
```

**Ğ’Ğ·Ğ°Ñ”Ğ¼Ğ¾Ğ´Ñ–Ñ—:**
- â†—ï¸ User Model: ĞŸÑ€Ğ¾Ñ„Ñ–Ğ»ÑŒĞ½Ñ– Ğ´Ğ°Ğ½Ñ–
- â†—ï¸ Transaction Service: Ğ’ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ Ğ±Ğ°Ğ»Ğ°Ğ½ÑÑ–Ğ²
- â†—ï¸ Analytics: Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ°
- â†—ï¸ Supabase: CRUD Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ñ–Ñ—

---

### `controllers/wallet_controller.py` - TON Wallet Controller
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: TON Ğ³Ğ°Ğ¼Ğ°Ğ½Ñ†Ñ– Ğ· Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡Ğ½Ğ¸Ğ¼Ğ¸ Ğ±Ğ¾Ğ½ÑƒÑĞ°Ğ¼Ğ¸
```

**Ğ“Ğ¾Ğ»Ğ¾Ğ²Ğ½Ñ– Ñ„ÑƒĞ½ĞºÑ†Ñ–Ñ—:**
```python
def check_wallet_status_route():
    # GET /api/wallet/status/{telegram_id}
    # Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ Ğ¿Ñ–Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ½Ñ TON Ğ³Ğ°Ğ¼Ğ°Ğ½Ñ†Ñ

def connect_wallet_route():
    # POST /api/wallet/connect/{telegram_id}
    # ĞŸÑ–Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ½Ñ Ğ³Ğ°Ğ¼Ğ°Ğ½Ñ†Ñ + Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡Ğ½Ğ¸Ğ¹ Ğ±Ğ¾Ğ½ÑƒÑ

def disconnect_wallet_route():
    # DELETE /api/wallet/disconnect/{telegram_id}
    # Ğ’Ñ–Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ½Ñ Ğ³Ğ°Ğ¼Ğ°Ğ½Ñ†Ñ

def verify_wallet_route():
    # POST /api/wallet/verify/{telegram_id}
    # Ğ’ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ Ğ¿Ñ–Ğ´Ğ¿Ğ¸ÑÑƒ Ğ³Ğ°Ğ¼Ğ°Ğ½Ñ†Ñ
```

**Workflow Ğ¿Ñ–Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ½Ñ Ğ· Ğ±Ğ¾Ğ½ÑƒÑĞ°Ğ¼Ğ¸:**
```python
def connect_wallet_route():
    """
    ĞŸÑ–Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ½Ñ TON Ğ³Ğ°Ğ¼Ğ°Ğ½Ñ†Ñ Ğ· Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡Ğ½Ğ¸Ğ¼ Ğ±Ğ¾Ğ½ÑƒÑĞ¾Ğ¼
    """
    try:
        # 1. Ğ’Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ° Ñ‚Ğ° Ğ´Ğ°Ğ½Ğ¸Ñ…
        telegram_id = request.view_args.get('telegram_id')
        validated_id = validate_telegram_id(telegram_id)

        wallet_data = request.get_json()
        wallet_address = sanitize_string(wallet_data.get('address', '').strip())
        provider = wallet_data.get('provider', 'unknown')
        signature = wallet_data.get('signature', '')

        # 2. Ğ’Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ Ğ°Ğ´Ñ€ĞµÑĞ¸ Ñ‡ĞµÑ€ĞµĞ· TON Connect
        if ton_connect_service:
            is_valid_address = await ton_connect_service.validate_wallet_address(
                wallet_address
            )
            if not is_valid_address:
                return error_response("Invalid TON wallet address", 400)

            # Ğ’ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ Ğ¿Ñ–Ğ´Ğ¿Ğ¸ÑÑƒ (ÑĞºÑ‰Ğ¾ Ğ½Ğ°Ğ´Ğ°Ğ½Ğ¾)
            if signature:
                is_signature_valid = await ton_connect_service.verify_wallet_ownership(
                    wallet_address, signature, f"Connect to WINIX {validated_id}"
                )
                if not is_signature_valid:
                    return error_response("Invalid wallet signature", 400)

        # 3. ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ñ‡Ğ¸ Ñ†Ğµ Ğ¿ĞµÑ€ÑˆĞµ Ğ¿Ñ–Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ½Ñ
        existing_wallet = wallet_model.get_wallet_info(validated_id)
        is_first_connection = not existing_wallet or existing_wallet.get('status') == 'disconnected'

        # 4. Ğ—Ğ±ĞµÑ€ĞµĞ¶ĞµĞ½Ğ½Ñ Ğ¿Ñ–Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ½Ñ
        connection_success = wallet_model.create_wallet_connection(
            validated_id, {
                'address': wallet_address,
                'provider': provider,
                'status': 'connected',
                'connected_at': datetime.now().isoformat(),
                'signature_verified': bool(signature)
            }
        )

        if not connection_success:
            return error_response("Failed to save wallet connection", 500)

        # 5. ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡Ğ½Ğ¸Ğ¹ Ğ±Ğ¾Ğ½ÑƒÑ Ğ·Ğ° Ğ¿Ñ–Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ½Ñ
        bonus_result = None
        if is_first_connection and transaction_service:
            bonus_result = transaction_service.process_wallet_connection_bonus(
                telegram_id=str(validated_id),
                wallet_address=wallet_address,
                is_first_connection=True
            )

            if bonus_result['success']:
                # Ğ›Ğ¾Ğ³ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ¿Ğ¾Ğ´Ñ–Ñ— Ğ±Ğ¾Ğ½ÑƒÑÑƒ
                wallet_model.log_wallet_event(
                    validated_id, 'connection_bonus_given',
                    {
                        'bonus': bonus_result['amount_added'],
                        'transaction_id': bonus_result['transaction_id']
                    }
                )

        # 6. ĞÑ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ Ğ±Ğ°Ğ»Ğ°Ğ½ÑÑ–Ğ² Ğ· blockchain
        blockchain_balances = {}
        if ton_connect_service:
            try:
                ton_balance = await ton_connect_service.get_wallet_balance(wallet_address)
                blockchain_balances = {
                    'ton': ton_balance.ton_balance,
                    'flex': ton_balance.flex_balance,
                    'last_updated': ton_balance.last_updated.isoformat()
                }
            except Exception as e:
                logger.warning(f"Failed to get blockchain balances: {e}")

        # 7. Ğ›Ğ¾Ğ³ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ°Ğ½Ğ°Ğ»Ñ–Ñ‚Ğ¸ĞºĞ¸
        asyncio.create_task(
            analytics_db.save_event(AnalyticsEvent(
                user_id=str(validated_id),
                event_type=EventType.WALLET,
                event_data={
                    "action": "wallet_connected",
                    "provider": provider,
                    "address": wallet_address[:10] + "...",  # ĞĞ±Ñ€Ñ–Ğ·Ğ°Ğ½Ğ° Ğ°Ğ´Ñ€ĞµÑĞ° Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¸Ğ²Ğ°Ñ‚Ğ½Ğ¾ÑÑ‚Ñ–
                    "first_connection": is_first_connection,
                    "bonus_given": bonus_result['success'] if bonus_result else False
                }
            ))
        )

        # 8. Ğ£ÑĞ¿Ñ–ÑˆĞ½Ğ° Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´ÑŒ
        response_data = {
            'connected': True,
            'address': wallet_address,
            'provider': provider,
            'status': 'connected',
            'first_connection': is_first_connection,
            'blockchain_balances': blockchain_balances
        }

        if bonus_result and bonus_result['success']:
            response_data['bonus_received'] = {
                'winix': bonus_result['amount_added']['winix'],
                'tickets': bonus_result['amount_added']['tickets'],
                'transaction_id': bonus_result['transaction_id']
            }

        return success_response(response_data)

    except Exception as e:
        logger.error(f"Wallet connection error: {e}", exc_info=True)
        return error_response("Internal server error", 500)
```

**Ğ’Ğ·Ğ°Ñ”Ğ¼Ğ¾Ğ´Ñ–Ñ—:**
- â†—ï¸ Wallet Model: Ğ—Ğ±ĞµÑ€ĞµĞ¶ĞµĞ½Ğ½Ñ Ğ¿Ñ–Ğ´ĞºĞ»ÑÑ‡ĞµĞ½ÑŒ
- â†—ï¸ TON Connect Service: Blockchain Ğ²Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ
- â†—ï¸ Transaction Service: ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡Ğ½Ñ– Ğ±Ğ¾Ğ½ÑƒÑĞ¸
- â†—ï¸ Analytics: Ğ›Ğ¾Ğ³ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ¿Ğ¾Ğ´Ñ–Ğ¹

---

### `controllers/transaction_controller.py` - Transaction Controller
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: Ğ¦ĞµĞ½Ñ‚Ñ€Ğ°Ğ»Ñ–Ğ·Ğ¾Ğ²Ğ°Ğ½Ğµ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»Ñ–Ğ½Ğ½Ñ Ñ„Ñ–Ğ½Ğ°Ğ½ÑĞ¾Ğ²Ğ¸Ğ¼Ğ¸ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ñ–ÑĞ¼Ğ¸
```

**Ğ“Ğ¾Ğ»Ğ¾Ğ²Ğ½Ñ– Ñ„ÑƒĞ½ĞºÑ†Ñ–Ñ—:**
```python
def process_user_reward_route():
    # POST /api/transactions/reward
    # Ğ¦ĞµĞ½Ñ‚Ñ€Ğ°Ğ»Ñ–Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ° Ğ¾Ğ±Ñ€Ğ¾Ğ±ĞºĞ° Ğ±ÑƒĞ´ÑŒ-ÑĞºĞ¾Ñ— Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ¸

def process_user_spending_route():
    # POST /api/transactions/spend
    # ĞĞ±Ñ€Ğ¾Ğ±ĞºĞ° Ğ²Ğ¸Ñ‚Ñ€Ğ°Ñ‚ Ğ· Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ¾Ñ Ğ±Ğ°Ğ»Ğ°Ğ½ÑÑƒ

def get_user_transaction_history_route():
    # GET /api/transactions/user/{telegram_id}/history
    # ĞŸĞ¾Ğ²Ğ½Ğ° Ñ–ÑÑ‚Ğ¾Ñ€Ñ–Ñ Ñ„Ñ–Ğ½Ğ°Ğ½ÑĞ¾Ğ²Ğ¸Ñ… Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ñ–Ğ¹

def get_user_balance_summary_route():
    # GET /api/transactions/user/{telegram_id}/summary
    # Ğ—Ğ²ĞµĞ´ĞµĞ½Ğ½Ñ Ğ±Ğ°Ğ»Ğ°Ğ½ÑÑƒ Ğ· Ğ°Ğ½Ğ°Ğ»Ñ–Ñ‚Ğ¸ĞºĞ¾Ñ
```

---

### `controllers/analytics_controller.py` - Analytics Controller
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: Ğ—Ğ±Ñ–Ñ€ Ñ‚Ğ° Ğ¾Ğ±Ñ€Ğ¾Ğ±ĞºĞ° Ğ°Ğ½Ğ°Ğ»Ñ–Ñ‚Ğ¸Ñ‡Ğ½Ğ¸Ñ… Ğ´Ğ°Ğ½Ğ¸Ñ…
```

**Ğ“Ğ¾Ğ»Ğ¾Ğ²Ğ½Ñ– Ñ„ÑƒĞ½ĞºÑ†Ñ–Ñ—:**
```python
def track_event_route():
    # POST /api/analytics/event
    # Ğ’Ñ–Ğ´ÑÑ‚ĞµĞ¶ĞµĞ½Ğ½Ñ Ğ¾ĞºÑ€ĞµĞ¼Ğ¾Ñ— Ğ°Ğ½Ğ°Ğ»Ñ–Ñ‚Ğ¸Ñ‡Ğ½Ğ¾Ñ— Ğ¿Ğ¾Ğ´Ñ–Ñ—

def track_batch_events_route():
    # POST /api/analytics/batch
    # ĞŸĞ°ĞºĞµÑ‚Ğ½Ğµ Ğ²Ñ–Ğ´ÑÑ‚ĞµĞ¶ĞµĞ½Ğ½Ñ Ğ¿Ğ¾Ğ´Ñ–Ğ¹

def get_user_analytics_route():
    # GET /api/analytics/user/{telegram_id}
    # ĞĞ½Ğ°Ğ»Ñ–Ñ‚Ğ¸ĞºĞ° ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ğ¾Ğ³Ğ¾ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ°

def get_summary_stats_route():
    # GET /api/analytics/summary
    # Ğ—Ğ°Ğ³Ğ°Ğ»ÑŒĞ½Ğ° ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° ÑĞ¸ÑÑ‚ĞµĞ¼Ğ¸
```

---

### `controllers/verification_controller.py` - Verification Controller
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: Ğ’ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ ÑĞ¾Ñ†Ñ–Ğ°Ğ»ÑŒĞ½Ğ¸Ñ… Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½ÑŒ
```

**Ğ“Ğ¾Ğ»Ğ¾Ğ²Ğ½Ñ– Ñ„ÑƒĞ½ĞºÑ†Ñ–Ñ—:**
```python
def start_verification_route():
    # POST /api/verification/start
    # ĞŸĞ¾Ñ‡Ğ°Ñ‚Ğ¾Ğº Ğ¿Ñ€Ğ¾Ñ†ĞµÑÑƒ Ğ²ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ—

def check_verification_status_route():
    # GET /api/verification/status/{telegram_id}/{task_id}
    # ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° ÑÑ‚Ğ°Ñ‚ÑƒÑÑƒ Ğ²ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ—

def complete_verification_route():
    # POST /api/verification/complete
    # Ğ ÑƒÑ‡Ğ½Ğµ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ½Ñ Ğ²ĞµÑ€Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ—
```

---

## ğŸ›£ï¸ ROUTES LAYER - HTTP API Endpoints

### `routes/__init__.py` - Routes Coordinator
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: Ğ¦ĞµĞ½Ñ‚Ñ€Ğ°Ğ»Ñ–Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ° Ñ€ĞµÑ”ÑÑ‚Ñ€Ğ°Ñ†Ñ–Ñ Ğ²ÑÑ–Ñ… Ğ¼Ğ°Ñ€ÑˆÑ€ÑƒÑ‚Ñ–Ğ²
```

**Blueprint Registration:**
```python
def register_all_routes(app: Flask):
    """
    Ğ ĞµÑ”ÑÑ‚Ñ€Ğ°Ñ†Ñ–Ñ Ğ²ÑÑ–Ñ… blueprints Ñƒ Flask Ğ´Ğ¾Ğ´Ğ°Ñ‚ĞºÑƒ
    """
    app.register_blueprint(auth_routes, url_prefix='/api/auth')
    app.register_blueprint(user_routes, url_prefix='/api/user')
    app.register_blueprint(daily_routes, url_prefix='/api/daily')
    app.register_blueprint(flex_routes, url_prefix='/api/flex')
    app.register_blueprint(tasks_routes, url_prefix='/api/tasks')
    app.register_blueprint(wallet_routes, url_prefix='/api/wallet')
    app.register_blueprint(transaction_routes, url_prefix='/api/transactions')
    app.register_blueprint(analytics_routes, url_prefix='/api/analytics')
    app.register_blueprint(verification_routes, url_prefix='/api/verification')
```

---

### `routes/auth_routes.py` - Authentication Routes
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: HTTP Ğ¼Ğ°Ñ€ÑˆÑ€ÑƒÑ‚Ñ– Ğ´Ğ»Ñ Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ğ·Ğ°Ñ†Ñ–Ñ—
```

**ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚Ğ¸:**
```python
from flask import Blueprint
from ..controllers.auth_controller import *

auth_routes = Blueprint('auth', __name__)

@auth_routes.route('/validate-telegram', methods=['POST'])
@public_endpoint(max_requests=20)
@validate_json(required_fields=['initData'])
def validate_telegram():
    return validate_telegram_route()

@auth_routes.route('/refresh-token', methods=['POST'])
@require_auth
@rate_limit(max_requests=10, window_seconds=300)
def refresh_token():
    return refresh_token_route()

@auth_routes.route('/validate-token', methods=['GET'])
@require_auth
def validate_token():
    return validate_token_route()

@auth_routes.route('/logout', methods=['POST'])
@require_auth
def logout():
    return logout_route()

@auth_routes.route('/status', methods=['GET'])
@public_endpoint(max_requests=50)
def auth_status():
    return get_auth_status_route()
```

---

### `routes/daily_routes.py` - Daily Bonus Routes
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: API Ğ´Ğ»Ñ Ñ‰Ğ¾Ğ´ĞµĞ½Ğ½Ğ¸Ñ… Ğ±Ğ¾Ğ½ÑƒÑÑ–Ğ²
```

**ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚Ğ¸:**
```python
daily_routes = Blueprint('daily', __name__)

@daily_routes.route('/status/<telegram_id>', methods=['GET'])
@secure_endpoint(max_requests=30)
@validate_telegram_id
def get_daily_status(telegram_id):
    return get_daily_status_route()

@daily_routes.route('/claim/<telegram_id>', methods=['POST'])
@secure_endpoint(max_requests=5)
@validate_telegram_id
def claim_daily_bonus(telegram_id):
    return claim_daily_bonus_route()

@daily_routes.route('/history/<telegram_id>', methods=['GET'])
@secure_endpoint(max_requests=20)
@validate_telegram_id
def get_daily_history(telegram_id):
    return get_daily_history_route()

@daily_routes.route('/preview/<telegram_id>', methods=['GET'])
@secure_endpoint(max_requests=30)
@validate_telegram_id
def get_reward_preview(telegram_id):
    return calculate_reward_for_day_route()
```

---

### `routes/tasks_routes.py` - Tasks Routes
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: API Ğ´Ğ»Ñ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ¸ Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½ÑŒ
```

**ĞœĞ°Ñ€ÑˆÑ€ÑƒÑ‚Ğ¸:**
```python
tasks_routes = Blueprint('tasks', __name__)

@tasks_routes.route('/list/<telegram_id>', methods=['GET'])
@secure_endpoint(max_requests=50)
@validate_telegram_id
def get_tasks_list(telegram_id):
    return get_tasks_list_route()

@tasks_routes.route('/details/<task_id>', methods=['GET'])
@secure_endpoint(max_requests=100)
def get_task_details(task_id):
    return get_task_details_route()

@tasks_routes.route('/start/<telegram_id>/<task_id>', methods=['POST'])
@secure_endpoint(max_requests=20)
@validate_telegram_id
def start_task(telegram_id, task_id):
    return start_task_route()

@tasks_routes.route('/verify/<telegram_id>/<task_id>', methods=['POST'])
@secure_endpoint(max_requests=10)
@validate_telegram_id
def verify_task(telegram_id, task_id):
    return verify_task_route()

@tasks_routes.route('/progress/<telegram_id>', methods=['GET'])
@secure_endpoint(max_requests=30)
@validate_telegram_id
def get_task_progress(telegram_id):
    return get_user_task_progress_route()

@tasks_routes.route('/create', methods=['POST'])
@admin_required
@validate_json(required_fields=['title', 'type', 'reward'])
def create_task():
    return create_task_route()
```

---

## ğŸ› ï¸ UTILS LAYER - Cross-cutting Concerns

### `utils/__init__.py` - Utils Coordinator
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: Ğ†Ğ½Ñ–Ñ†Ñ–Ğ°Ğ»Ñ–Ğ·Ğ°Ñ†Ñ–Ñ ÑƒÑ‚Ğ¸Ğ»Ñ–Ñ‚
```

---

### `utils/constants.py` - System Constants
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: Ğ¦ĞµĞ½Ñ‚Ñ€Ğ°Ğ»Ñ–Ğ·Ğ¾Ğ²Ğ°Ğ½Ñ– ĞºĞ¾Ğ½ÑÑ‚Ğ°Ğ½Ñ‚Ğ¸ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ¸
```

**ĞšĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ñ–Ñ— ĞºĞ¾Ğ½ÑÑ‚Ğ°Ğ½Ñ‚:**
```python
# Environment Configuration
ENVIRONMENT = os.getenv('ENVIRONMENT', 'development')
DEBUG = ENVIRONMENT == 'development'
PRODUCTION = ENVIRONMENT == 'production'

# Database Configuration
SUPABASE_URL = os.getenv('SUPABASE_URL')
SUPABASE_ANON_KEY = os.getenv('SUPABASE_ANON_KEY')
SUPABASE_SERVICE_KEY = os.getenv('SUPABASE_SERVICE_KEY')

# Security & JWT
JWT_SECRET_KEY = os.getenv('JWT_SECRET_KEY')
JWT_EXPIRATION_DAYS = 7
SECRET_KEY = os.getenv('SECRET_KEY')

# Telegram Configuration
TELEGRAM_BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
TELEGRAM_BOT_USERNAME = os.getenv('TELEGRAM_BOT_USERNAME')
TELEGRAM_WEBHOOK_SECRET = os.getenv('TELEGRAM_WEBHOOK_SECRET')

# TON Blockchain
TON_API_KEY = os.getenv('TON_API_KEY')
TON_NETWORK = os.getenv('TON_NETWORK', 'mainnet')
FLEX_CONTRACT_ADDRESS = os.getenv('FLEX_CONTRACT_ADDRESS')

# FLEX System Configuration
FLEX_LEVELS_CONFIG = {
    "Bronze": {"required_flex": 10000, "reward_winix": 25, "reward_tickets": 1},
    "Silver": {"required_flex": 50000, "reward_winix": 75, "reward_tickets": 2},
    "Gold": {"required_flex": 100000, "reward_winix": 150, "reward_tickets": 4},
    "Platinum": {"required_flex": 250000, "reward_winix": 300, "reward_tickets": 8},
    "Diamond": {"required_flex": 500000, "reward_winix": 500, "reward_tickets": 15}
}

# Daily Bonus Configuration
DAILY_BONUS_BASE_WINIX = 20
DAILY_BONUS_SPECIAL_DAYS = {7: 1, 14: 2, 21: 3, 30: 10}  # day: tickets
DAILY_BONUS_COOLDOWN_HOURS = 20
DAILY_BONUS_MAX_STREAK_RESET_HOURS = 44

# Task Rewards Configuration
TASK_REWARDS_CONFIG = {
    'telegram_subscribe': {'winix': 50, 'tickets': 2},
    'youtube_subscribe': {'winix': 75, 'tickets': 3},
    'twitter_follow': {'winix': 40, 'tickets': 1},
    'discord_join': {'winix': 60, 'tickets': 2},
    'partner': {'winix': 100, 'tickets': 5}
}

# Wallet Configuration
WALLET_CONNECTION_BONUS_WINIX = 100
WALLET_CONNECTION_BONUS_TICKETS = 5
WALLET_VERIFICATION_BONUS_WINIX = 50
WALLET_VERIFICATION_BONUS_TICKETS = 2

# Cache Configuration
CACHE_ENABLED = os.getenv('CACHE_ENABLED', 'true').lower() == 'true'
REDIS_HOST = os.getenv('REDIS_HOST', 'localhost')
REDIS_PORT = int(os.getenv('REDIS_PORT', 6379))
CACHE_DEFAULT_TTL = 300  # 5 minutes

# Rate Limiting
RATE_LIMIT_ENABLED = os.getenv('RATE_LIMIT_ENABLED', 'true').lower() == 'true'
RATE_LIMIT_STORAGE = os.getenv('RATE_LIMIT_STORAGE', 'memory')
DEFAULT_RATE_LIMIT = 100  # requests per minute

# Currency Configuration
CURRENCY_WINIX = "winix"
CURRENCY_TICKETS = "tickets"
CURRENCY_FLEX = "flex"

# Error Messages
ERROR_MESSAGES = {
    'INVALID_TELEGRAM_ID': 'Invalid Telegram ID format',
    'USER_NOT_FOUND': 'User not found',
    'INSUFFICIENT_BALANCE': 'Insufficient balance',
    'TASK_NOT_FOUND': 'Task not found',
    'TASK_ALREADY_COMPLETED': 'Task already completed',
    'WALLET_NOT_CONNECTED': 'Wallet not connected',
    'INVALID_WALLET_ADDRESS': 'Invalid wallet address',
    'COOLDOWN_ACTIVE': 'Cooldown period is active',
    'VERIFICATION_FAILED': 'Verification failed',
    'INTERNAL_SERVER_ERROR': 'Internal server error'
}

# API Configuration
API_VERSION = "v1"
MAX_PAGE_SIZE = 100
DEFAULT_PAGE_SIZE = 20
REQUEST_TIMEOUT = 30

# Logging Configuration
LOG_LEVEL = os.getenv('LOG_LEVEL', 'INFO')
LOG_FORMAT = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
LOG_FILE_MAX_SIZE = 10 * 1024 * 1024  # 10MB
LOG_FILE_BACKUP_COUNT = 5
```

---

### `utils/validators.py` - Data Validation
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: Ğ’Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ Ğ²ÑÑ–Ñ… Ñ‚Ğ¸Ğ¿Ñ–Ğ² Ğ´Ğ°Ğ½Ğ¸Ñ…
```

**ĞÑĞ½Ğ¾Ğ²Ğ½Ñ– Ñ„ÑƒĞ½ĞºÑ†Ñ–Ñ—:**
```python
import hashlib
import hmac
import re
from urllib.parse import parse_qsl
from typing import Dict, Any, Optional

def validate_telegram_webapp_data(init_data: str, bot_token: str) -> Dict[str, Any]:
    """
    Ğ’Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ Telegram WebApp initData Ğ· HMAC-SHA256 Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ¾Ñ
    """
    try:
        # ĞŸĞ°Ñ€ÑĞ¸Ğ½Ğ³ query string
        parsed_data = dict(parse_qsl(init_data))

        # ĞÑ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ hash Ğ· Ğ´Ğ°Ğ½Ğ¸Ñ…
        received_hash = parsed_data.pop('hash', '')
        if not received_hash:
            return {'valid': False, 'error': 'Hash not found'}

        # Ğ¡Ñ‚Ğ²Ğ¾Ñ€ĞµĞ½Ğ½Ñ data-check-string
        data_check_string = '\n'.join([
            f"{key}={value}" for key, value in sorted(parsed_data.items())
        ])

        # Ğ¡Ñ‚Ğ²Ğ¾Ñ€ĞµĞ½Ğ½Ñ secret key
        secret_key = hmac.new(
            "WebAppData".encode(),
            bot_token.encode(),
            hashlib.sha256
        ).digest()

        # ĞĞ±Ñ‡Ğ¸ÑĞ»ĞµĞ½Ğ½Ñ hash
        calculated_hash = hmac.new(
            secret_key,
            data_check_string.encode(),
            hashlib.sha256
        ).hexdigest()

        # ĞŸĞ¾Ñ€Ñ–Ğ²Ğ½ÑĞ½Ğ½Ñ hash
        if not hmac.compare_digest(received_hash, calculated_hash):
            return {'valid': False, 'error': 'Invalid hash'}

        # ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° auth_date (Ğ½Ğµ ÑÑ‚Ğ°Ñ€ÑˆĞµ 24 Ğ³Ğ¾Ğ´Ğ¸Ğ½)
        auth_date = int(parsed_data.get('auth_date', 0))
        current_time = time.time()

        if current_time - auth_date > 86400:  # 24 Ğ³Ğ¾Ğ´Ğ¸Ğ½Ğ¸
            return {'valid': False, 'error': 'Data too old'}

        # ĞŸĞ°Ñ€ÑĞ¸Ğ½Ğ³ user data
        user_data = json.loads(parsed_data.get('user', '{}'))

        return {
            'valid': True,
            'user': user_data,
            'auth_date': auth_date,
            'parsed_data': parsed_data
        }

    except Exception as e:
        return {'valid': False, 'error': f'Validation error: {str(e)}'}

def validate_telegram_id(telegram_id: Any) -> Optional[int]:
    """
    Ğ’Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ Telegram ID
    """
    try:
        # ĞšĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ°Ñ†Ñ–Ñ Ğ² int
        id_int = int(telegram_id)

        # ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ´Ñ–Ğ°Ğ¿Ğ°Ğ·Ğ¾Ğ½Ñƒ (Telegram IDs Ğ·Ğ°Ğ²Ğ¶Ğ´Ğ¸ Ğ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ¸Ğ²Ğ½Ñ–)
        if id_int <= 0:
            return None

        # ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ¼Ğ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ½Ñ
        if id_int > 2**63 - 1:  # int64 max
            return None

        return id_int

    except (ValueError, TypeError):
        return None

def validate_username(username: str) -> bool:
    """
    Ğ’Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ Telegram username
    """
    if not username:
        return True  # Username Ğ¼Ğ¾Ğ¶Ğµ Ğ±ÑƒÑ‚Ğ¸ Ğ¿Ğ¾Ñ€Ğ¾Ğ¶Ğ½Ñ–Ğ¼

    # Telegram username rules
    pattern = r'^[a-zA-Z0-9_]{5,32}
    return bool(re.match(pattern, username))

def validate_wallet_address(address: str) -> bool:
    """
    Ğ’Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ TON wallet address
    """
    if not address:
        return False

    # TON address format: EQ... Ğ°Ğ±Ğ¾ UQ... (48 ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ñ–Ğ² base64)
    if not (address.startswith('EQ') or address.startswith('UQ')):
        return False

    if len(address) != 48:
        return False

    # Ğ‘Ğ°Ğ·Ğ¾Ğ²Ğ° Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° base64
    try:
        import base64
        base64.b64decode(address[2:] + '==')  # Add padding
        return True
    except:
        return False

def validate_reward_amount(amount: Any, currency: str) -> bool:
    """
    Ğ’Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ ÑÑƒĞ¼Ğ¸ Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ¸
    """
    try:
        amount_int = int(amount)

        # ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ½Ğ° Ğ½ĞµĞ³Ğ°Ñ‚Ğ¸Ğ²Ğ½Ñ– Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ½Ñ
        if amount_int < 0:
            return False

        # ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ¼Ğ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¸Ñ… Ğ»Ñ–Ğ¼Ñ–Ñ‚Ñ–Ğ²
        if currency == CURRENCY_WINIX and amount_int > 1000000:  # 1M WINIX max
            return False

        if currency == CURRENCY_TICKETS and amount_int > 1000:  # 1K tickets max
            return False

        return True

    except (ValueError, TypeError):
        return False

def validate_task_type(task_type: str) -> bool:
    """
    Ğ’Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ Ñ‚Ğ¸Ğ¿Ñƒ Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½Ğ½Ñ
    """
    valid_types = [
        'telegram_subscribe', 'telegram_bot_start',
        'youtube_subscribe', 'twitter_follow',
        'discord_join', 'social_share',
        'limited_time', 'partner', 'daily_check'
    ]
    return task_type in valid_types

def validate_url(url: str) -> bool:
    """
    Ğ’Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ URL
    """
    url_pattern = re.compile(
        r'^https?://'  # http:// or https://
        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+[A-Z]{2,6}\.?|'  # domain...
        r'localhost|'  # localhost...
        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})'  # ...or ip
        r'(?::\d+)?'  # optional port
        r'(?:/?|[/?]\S+), re.IGNORECASE)

    return bool(url_pattern.match(url))

def sanitize_string(value: str, max_length: int = 255) -> str:
    """
    Ğ¡Ğ°Ğ½Ñ–Ñ‚Ğ¸Ğ·Ğ°Ñ†Ñ–Ñ Ñ€ÑĞ´ĞºĞ°
    """
    if not isinstance(value, str):
        return ""

    # Ğ’Ğ¸Ğ´Ğ°Ğ»ĞµĞ½Ğ½Ñ Ğ½ĞµĞ±ĞµĞ·Ğ¿ĞµÑ‡Ğ½Ğ¸Ñ… ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ñ–Ğ²
    sanitized = re.sub(r'[<>"\']', '', value)

    # ĞĞ±Ñ€Ñ–Ğ·Ğ°Ğ½Ğ½Ñ Ğ´Ğ¾ Ğ¼Ğ°ĞºÑĞ¸Ğ¼Ğ°Ğ»ÑŒĞ½Ğ¾Ñ— Ğ´Ğ¾Ğ²Ğ¶Ğ¸Ğ½Ğ¸
    sanitized = sanitized[:max_length]

    # Ğ’Ğ¸Ğ´Ğ°Ğ»ĞµĞ½Ğ½Ñ Ğ·Ğ°Ğ¹Ğ²Ğ¸Ñ… Ğ¿Ñ€Ğ¾Ğ±Ñ–Ğ»Ñ–Ğ²
    sanitized = sanitized.strip()

    return sanitized

def validate_json_schema(data: Dict[str, Any], required_fields: List[str]) -> Dict[str, Any]:
    """
    Ğ’Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ JSON schema
    """
    errors = []

    for field in required_fields:
        if field not in data:
            errors.append(f"Missing required field: {field}")
        elif data[field] is None:
            errors.append(f"Field cannot be null: {field}")

    return {
        'valid': len(errors) == 0,
        'errors': errors
    }
```

---

### `utils/decorators.py` - Security & Validation Decorators
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: Ğ”ĞµĞºĞ¾Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ¸ Ğ´Ğ»Ñ Ğ±ĞµĞ·Ğ¿ĞµĞºĞ¸, Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ğ·Ğ°Ñ†Ñ–Ñ— Ñ‚Ğ° Ğ²Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ—
```

**ĞÑĞ½Ğ¾Ğ²Ğ½Ñ– Ğ´ĞµĞºĞ¾Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ¸:**
```python
import functools
import time
import jwt
from flask import request, jsonify, g
from typing import List, Optional, Callable, Dict, Any

def require_auth(validate_ip: bool = False, require_fresh_token: bool = False):
    """
    Ğ”ĞµĞºĞ¾Ñ€Ğ°Ñ‚Ğ¾Ñ€ Ğ´Ğ»Ñ Ğ¾Ğ±Ğ¾Ğ²'ÑĞ·ĞºĞ¾Ğ²Ğ¾Ñ— Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ğ·Ğ°Ñ†Ñ–Ñ—
    """
    def decorator(f):
        @functools.wraps(f)
        def decorated_function(*args, **kwargs):
            # ĞÑ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ Ñ‚Ğ¾ĞºĞµĞ½Ñƒ Ğ· Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²ĞºĞ°
            auth_header = request.headers.get('Authorization')
            if not auth_header or not auth_header.startswith('Bearer '):
                return jsonify({'error': 'Authorization header required'}), 401

            token = auth_header.split(' ')[1]

            # Ğ”ĞµĞºĞ¾Ğ´ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ñ‚Ğ° Ğ²Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ Ñ‚Ğ¾ĞºĞµĞ½Ñƒ
            token_result = decode_jwt_token(token)
            if not token_result['valid']:
                return jsonify({'error': token_result['error']}), 401

            payload = token_result['payload']

            # ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° ÑĞ²Ñ–Ğ¶Ğ¾ÑÑ‚Ñ– Ñ‚Ğ¾ĞºĞµĞ½Ñƒ
            if require_fresh_token:
                issued_at = payload.get('iat', 0)
                if time.time() - issued_at > 3600:  # 1 Ğ³Ğ¾Ğ´Ğ¸Ğ½Ğ°
                    return jsonify({'error': 'Token too old, refresh required'}), 401

            # Ğ’Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ IP (ÑĞºÑ‰Ğ¾ ÑƒĞ²Ñ–Ğ¼ĞºĞ½ĞµĞ½Ğ¾)
            if validate_ip:
                stored_ip = payload.get('ip')
                current_ip = request.remote_addr
                if stored_ip and stored_ip != current_ip:
                    return jsonify({'error': 'IP address mismatch'}), 401

            # Ğ—Ğ±ĞµÑ€ĞµĞ¶ĞµĞ½Ğ½Ñ Ğ´Ğ°Ğ½Ğ¸Ñ… ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ° Ğ² ĞºĞ¾Ğ½Ñ‚ĞµĞºÑÑ‚Ñ–
            g.current_user = {
                'user_id': payload.get('user_id'),
                'telegram_id': payload.get('telegram_id'),
                'username': payload.get('username')
            }

            return f(*args, **kwargs)
        return decorated_function
    return decorator

def optional_auth(f):
    """
    Ğ”ĞµĞºĞ¾Ñ€Ğ°Ñ‚Ğ¾Ñ€ Ğ´Ğ»Ñ Ğ¾Ğ¿Ñ†Ñ–Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾Ñ— Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ¸Ğ·Ğ°Ñ†Ñ–Ñ—
    """
    @functools.wraps(f)
    def decorated_function(*args, **kwargs):
        auth_header = request.headers.get('Authorization')

        if auth_header and auth_header.startswith('Bearer '):
            token = auth_header.split(' ')[1]
            token_result = decode_jwt_token(token)

            if token_result['valid']:
                g.current_user = {
                    'user_id': token_result['payload'].get('user_id'),
                    'telegram_id': token_result['payload'].get('telegram_id'),
                    'username': token_result['payload'].get('username')
                }
            else:
                g.current_user = None
        else:
            g.current_user = None

        return f(*args, **kwargs)
    return decorated_function

def rate_limit(max_requests: int = 60, window_seconds: int = 60, scope: str = 'ip'):
    """
    Ğ”ĞµĞºĞ¾Ñ€Ğ°Ñ‚Ğ¾Ñ€ Ğ´Ğ»Ñ rate limiting
    """
    def decorator(f):
        @functools.wraps(f)
        def decorated_function(*args, **kwargs):
            # Ğ’Ğ¸Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ½Ñ ĞºĞ»ÑÑ‡Ğ° Ğ´Ğ»Ñ rate limiting
            if scope == 'ip':
                key = f"rate_limit:{request.remote_addr}:{f.__name__}"
            elif scope == 'user' and hasattr(g, 'current_user') and g.current_user:
                key = f"rate_limit:user:{g.current_user['telegram_id']}:{f.__name__}"
            else:
                key = f"rate_limit:global:{f.__name__}"

            # ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° rate limit Ñ‡ĞµÑ€ĞµĞ· cache
            current_count = cache_manager.get(key, 0)

            if current_count >= max_requests:
                return jsonify({
                    'error': 'Rate limit exceeded',
                    'retry_after': window_seconds
                }), 429

            # Ğ†Ğ½ĞºÑ€ĞµĞ¼ĞµĞ½Ñ‚ Ğ»Ñ–Ñ‡Ğ¸Ğ»ÑŒĞ½Ğ¸ĞºĞ°
            cache_manager.set(key, current_count + 1, window_seconds)

            return f(*args, **kwargs)
        return decorated_function
    return decorator

def validate_json(required_fields: List[str] = None, optional_fields: List[str] = None):
    """
    Ğ”ĞµĞºĞ¾Ñ€Ğ°Ñ‚Ğ¾Ñ€ Ğ´Ğ»Ñ Ğ²Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ— JSON Ğ´Ğ°Ğ½Ğ¸Ñ…
    """
    def decorator(f):
        @functools.wraps(f)
        def decorated_function(*args, **kwargs):
            if not request.is_json:
                return jsonify({'error': 'Content-Type must be application/json'}), 400

            data = request.get_json()
            if not data:
                return jsonify({'error': 'Invalid JSON data'}), 400

            # ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ¾Ğ±Ğ¾Ğ²'ÑĞ·ĞºĞ¾Ğ²Ğ¸Ñ… Ğ¿Ğ¾Ğ»Ñ–Ğ²
            if required_fields:
                missing_fields = [field for field in required_fields if field not in data]
                if missing_fields:
                    return jsonify({
                        'error': 'Missing required fields',
                        'missing_fields': missing_fields
                    }), 400

            # Ğ’Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ Ñ‚Ğ¸Ğ¿Ñ–Ğ² Ğ´Ğ°Ğ½Ğ¸Ñ… (ÑĞºÑ‰Ğ¾ Ğ·Ğ°Ğ´Ğ°Ğ½Ğ¾)
            for field in required_fields or []:
                if field in data and data[field] is None:
                    return jsonify({
                        'error': f'Field {field} cannot be null'
                    }), 400

            return f(*args, **kwargs)
        return decorated_function
    return decorator

def validate_telegram_id(f):
    """
    Ğ”ĞµĞºĞ¾Ñ€Ğ°Ñ‚Ğ¾Ñ€ Ğ´Ğ»Ñ Ğ²Ğ°Ğ»Ñ–Ğ´Ğ°Ñ†Ñ–Ñ— Telegram ID Ğ² URL Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€Ğ°Ñ…
    """
    @functools.wraps(f)
    def decorated_function(*args, **kwargs):
        telegram_id = request.view_args.get('telegram_id')

        if telegram_id:
            validated_id = validate_telegram_id(telegram_id)
            if not validated_id:
                return jsonify({'error': 'Invalid telegram_id format'}), 400

            # Ğ—Ğ°Ğ¼Ñ–Ğ½Ğ° Ğ² kwargs Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ´Ğ°Ğ»ÑŒÑˆĞ¾Ğ³Ğ¾ Ğ²Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ°Ğ½Ğ½Ñ
            kwargs['telegram_id'] = validated_id

        return f(*args, **kwargs)
    return decorated_function

def handle_errors(f):
    """
    Ğ”ĞµĞºĞ¾Ñ€Ğ°Ñ‚Ğ¾Ñ€ Ğ´Ğ»Ñ Ñ†ĞµĞ½Ñ‚Ñ€Ğ°Ğ»Ñ–Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ¾Ñ— Ğ¾Ğ±Ñ€Ğ¾Ğ±ĞºĞ¸ Ğ¿Ğ¾Ğ¼Ğ¸Ğ»Ğ¾Ğº
    """
    @functools.wraps(f)
    def decorated_function(*args, **kwargs):
        try:
            return f(*args, **kwargs)
        except ValidationError as e:
            return jsonify({'error': str(e)}), 400
        except AuthenticationError as e:
            return jsonify({'error': str(e)}), 401
        except AuthorizationError as e:
            return jsonify({'error': str(e)}), 403
        except NotFoundError as e:
            return jsonify({'error': str(e)}), 404
        except Exception as e:
            logger.error(f"Unhandled error in {f.__name__}: {e}", exc_info=True)
            return jsonify({'error': 'Internal server error'}), 500
    return decorated_function

def security_headers(f):
    """
    Ğ”ĞµĞºĞ¾Ñ€Ğ°Ñ‚Ğ¾Ñ€ Ğ´Ğ»Ñ Ğ´Ğ¾Ğ´Ğ°Ğ²Ğ°Ğ½Ğ½Ñ security headers
    """
    @functools.wraps(f)
    def decorated_function(*args, **kwargs):
        response = make_response(f(*args, **kwargs))

        response.headers['X-Content-Type-Options'] = 'nosniff'
        response.headers['X-Frame-Options'] = 'DENY'
        response.headers['X-XSS-Protection'] = '1; mode=block'
        response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'
        response.headers['Content-Security-Policy'] = "default-src 'self'"

        return response
    return decorated_function

# ĞšĞ¾Ğ¼Ğ±Ñ–Ğ½Ğ¾Ğ²Ğ°Ğ½Ñ– Ğ´ĞµĞºĞ¾Ñ€Ğ°Ñ‚Ğ¾Ñ€Ğ¸ Ğ´Ğ»Ñ Ğ·Ñ€ÑƒÑ‡Ğ½Ğ¾ÑÑ‚Ñ–
def secure_endpoint(max_requests: int = 30, window_seconds: int = 60, require_fresh_token: bool = False):
    """
    ĞšĞ¾Ğ¼Ğ±Ñ–Ğ½Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¹ Ğ´ĞµĞºĞ¾Ñ€Ğ°Ñ‚Ğ¾Ñ€ Ğ´Ğ»Ñ Ğ·Ğ°Ñ…Ğ¸Ñ‰ĞµĞ½Ğ¸Ñ… endpoint'Ñ–Ğ²
    """
    def decorator(f):
        @security_headers
        @handle_errors
        @rate_limit(max_requests, window_seconds)
        @require_auth(require_fresh_token=require_fresh_token)
        @functools.wraps(f)
        def decorated_function(*args, **kwargs):
            return f(*args, **kwargs)
        return decorated_function
    return decorator

def public_endpoint(max_requests: int = 60, window_seconds: int = 60):
    """
    ĞšĞ¾Ğ¼Ğ±Ñ–Ğ½Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¹ Ğ´ĞµĞºĞ¾Ñ€Ğ°Ñ‚Ğ¾Ñ€ Ğ´Ğ»Ñ Ğ¿ÑƒĞ±Ğ»Ñ–Ñ‡Ğ½Ğ¸Ñ… endpoint'Ñ–Ğ²
    """
    def decorator(f):
        @security_headers
        @handle_errors
        @rate_limit(max_requests, window_seconds)
        @optional_auth
        @functools.wraps(f)
        def decorated_function(*args, **kwargs):
            return f(*args, **kwargs)
        return decorated_function
    return decorator
```

---

### `utils/cache.py` - Caching System
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: Ğ‘Ğ°Ğ³Ğ°Ñ‚Ğ¾Ñ€Ñ–Ğ²Ğ½ĞµĞ²Ğµ ĞºĞµÑˆÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ· Ğ¿Ñ–Ğ´Ñ‚Ñ€Ğ¸Ğ¼ĞºĞ¾Ñ Redis Ñ‚Ğ° Memory
```

**ĞÑ€Ñ…Ñ–Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ° ĞºĞµÑˆÑƒĞ²Ğ°Ğ½Ğ½Ñ:**
```python
import time
import json
import redis
from typing import Any, Optional, Dict
from enum import Enum

class CacheType(Enum):
    MEMORY = "memory"
    REDIS = "redis"
    HYBRID = "hybrid"

class CachePolicy(Enum):
    LRU = "lru"          # Least Recently Used
    LFU = "lfu"          # Least Frequently Used
    TTL = "ttl"          # Time To Live
    FIFO = "fifo"        # First In First Out

class CacheManager:
    """
    Ğ¦ĞµĞ½Ñ‚Ñ€Ğ°Ğ»Ñ–Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¹ Ğ¼ĞµĞ½ĞµĞ´Ğ¶ĞµÑ€ ĞºĞµÑˆÑƒĞ²Ğ°Ğ½Ğ½Ñ
    """
    def __init__(self):
        self.memory_cache = MemoryCache()
        self.redis_cache = RedisCache() if CACHE_ENABLED else None

    def get(self, key: str, default: Any = None, cache_type: CacheType = CacheType.HYBRID) -> Any:
        """
        ĞÑ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ½Ñ Ğ· ĞºĞµÑˆÑƒ
        """
        if cache_type in [CacheType.MEMORY, CacheType.HYBRID]:
            # Ğ¡Ğ¿Ñ€Ğ¾Ğ±Ğ° Ğ¾Ñ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ Ğ· memory cache
            value = self.memory_cache.get(key)
            if value is not None:
                return value

        if cache_type in [CacheType.REDIS, CacheType.HYBRID] and self.redis_cache:
            # Ğ¡Ğ¿Ñ€Ğ¾Ğ±Ğ° Ğ¾Ñ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ Ğ· Redis
            value = self.redis_cache.get(key)
            if value is not None:
                # Ğ—Ğ±ĞµÑ€ĞµĞ¶ĞµĞ½Ğ½Ñ Ğ² memory cache Ğ´Ğ»Ñ ÑˆĞ²Ğ¸Ğ´ÑˆĞ¾Ğ³Ğ¾ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ñƒ
                if cache_type == CacheType.HYBRID:
                    self.memory_cache.set(key, value, ttl=60)  # 1 Ñ…Ğ²Ğ¸Ğ»Ğ¸Ğ½Ğ° Ğ² memory
                return value

        return default

    def set(self, key: str, value: Any, ttl: int = 300, cache_type: CacheType = CacheType.HYBRID) -> bool:
        """
        Ğ—Ğ±ĞµÑ€ĞµĞ¶ĞµĞ½Ğ½Ñ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ½Ñ Ğ² ĞºĞµÑˆ
        """
        success = True

        if cache_type in [CacheType.MEMORY, CacheType.HYBRID]:
            success &= self.memory_cache.set(key, value, ttl)

        if cache_type in [CacheType.REDIS, CacheType.HYBRID] and self.redis_cache:
            success &= self.redis_cache.set(key, value, ttl)

        return success

    def delete(self, key: str, cache_type: CacheType = CacheType.HYBRID) -> bool:
        """
        Ğ’Ğ¸Ğ´Ğ°Ğ»ĞµĞ½Ğ½Ñ ĞºĞ»ÑÑ‡Ğ° Ğ· ĞºĞµÑˆÑƒ
        """
        success = True

        if cache_type in [CacheType.MEMORY, CacheType.HYBRID]:
            success &= self.memory_cache.delete(key)

        if cache_type in [CacheType.REDIS, CacheType.HYBRID] and self.redis_cache:
            success &= self.redis_cache.delete(key)

        return success

    def clear_pattern(self, pattern: str) -> int:
        """
        ĞÑ‡Ğ¸Ñ‰ĞµĞ½Ğ½Ñ Ğ²ÑÑ–Ñ… ĞºĞ»ÑÑ‡Ñ–Ğ² Ğ·Ğ° ÑˆĞ°Ğ±Ğ»Ğ¾Ğ½Ğ¾Ğ¼
        """
        cleared = 0
        cleared += self.memory_cache.clear_pattern(pattern)

        if self.redis_cache:
            cleared += self.redis_cache.clear_pattern(pattern)

        return cleared

class MemoryCache:
    """
    In-memory ĞºĞµÑˆ Ğ· LRU policy
    """
    def __init__(self, max_size: int = 1000):
        self.max_size = max_size
        self.cache: Dict[str, Dict] = {}
        self.access_order: List[str] = []

    def get(self, key: str) -> Any:
        if key not in self.cache:
            return None

        item = self.cache[key]

        # ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° TTL
        if item['expires_at'] and time.time() > item['expires_at']:
            self.delete(key)
            return None

        # ĞĞ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ Ğ¿Ğ¾Ñ€ÑĞ´ĞºÑƒ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ñƒ (LRU)
        self.access_order.remove(key)
        self.access_order.append(key)

        return item['value']

    def set(self, key: str, value: Any, ttl: int = 300) -> bool:
        try:
            expires_at = time.time() + ttl if ttl > 0 else None

            # Ğ¯ĞºÑ‰Ğ¾ ĞºĞµÑˆ Ğ¿Ğ¾Ğ²Ğ½Ğ¸Ğ¹, Ğ²Ğ¸Ğ´Ğ°Ğ»ÑÑ”Ğ¼Ğ¾ Ğ½Ğ°Ğ¹ÑÑ‚Ğ°Ñ€Ñ–ÑˆĞ¸Ğ¹ ĞµĞ»ĞµĞ¼ĞµĞ½Ñ‚
            if len(self.cache) >= self.max_size and key not in self.cache:
                oldest_key = self.access_order.pop(0)
                del self.cache[oldest_key]

            # Ğ—Ğ±ĞµÑ€ĞµĞ¶ĞµĞ½Ğ½Ñ
            self.cache[key] = {
                'value': value,
                'created_at': time.time(),
                'expires_at': expires_at
            }

            # ĞĞ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ Ğ¿Ğ¾Ñ€ÑĞ´ĞºÑƒ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ñƒ
            if key in self.access_order:
                self.access_order.remove(key)
            self.access_order.append(key)

            return True
        except Exception as e:
            logger.error(f"Memory cache set error: {e}")
            return False

    def delete(self, key: str) -> bool:
        if key in self.cache:
            del self.cache[key]
            if key in self.access_order:
                self.access_order.remove(key)
            return True
        return False

    def clear_pattern(self, pattern: str) -> int:
        """
        ĞÑ‡Ğ¸Ñ‰ĞµĞ½Ğ½Ñ ĞºĞ»ÑÑ‡Ñ–Ğ² Ğ·Ğ° ÑˆĞ°Ğ±Ğ»Ğ¾Ğ½Ğ¾Ğ¼ (Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¸Ğ¹ wildcard)
        """
        import fnmatch
        cleared = 0

        keys_to_delete = [
            key for key in self.cache.keys()
            if fnmatch.fnmatch(key, pattern)
        ]

        for key in keys_to_delete:
            if self.delete(key):
                cleared += 1

        return cleared

class RedisCache:
    """
    Redis ĞºĞµÑˆ Ğ´Ğ»Ñ Ñ€Ğ¾Ğ·Ğ¿Ğ¾Ğ´Ñ–Ğ»ĞµĞ½Ğ¾Ğ³Ğ¾ Ğ·Ğ±ĞµÑ€Ñ–Ğ³Ğ°Ğ½Ğ½Ñ
    """
    def __init__(self):
        try:
            self.redis_client = redis.Redis(
                host=REDIS_HOST,
                port=REDIS_PORT,
                db=0,
                decode_responses=True,
                socket_timeout=5,
                socket_connect_timeout=5
            )
            # Ğ¢ĞµÑÑ‚ Ğ¿Ñ–Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ½Ñ
            self.redis_client.ping()
            self.available = True
        except Exception as e:
            logger.error(f"Redis connection failed: {e}")
            self.redis_client = None
            self.available = False

    def get(self, key: str) -> Any:
        if not self.available:
            return None

        try:
            value = self.redis_client.get(key)
            if value:
                return json.loads(value)
            return None
        except Exception as e:
            logger.error(f"Redis get error for key {key}: {e}")
            return None

    def set(self, key: str, value: Any, ttl: int = 300) -> bool:
        if not self.available:
            return False

        try:
            serialized_value = json.dumps(value, default=str)
            return self.redis_client.setex(key, ttl, serialized_value)
        except Exception as e:
            logger.error(f"Redis set error for key {key}: {e}")
            return False

    def delete(self, key: str) -> bool:
        if not self.available:
            return False

        try:
            return bool(self.redis_client.delete(key))
        except Exception as e:
            logger.error(f"Redis delete error for key {key}: {e}")
            return False

    def clear_pattern(self, pattern: str) -> int:
        if not self.available:
            return 0

        try:
            keys = self.redis_client.keys(pattern)
            if keys:
                return self.redis_client.delete(*keys)
            return 0
        except Exception as e:
            logger.error(f"Redis clear pattern error: {e}")
            return 0

# Ğ“Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ğ¸Ğ¹ Ñ–Ğ½ÑÑ‚Ğ°Ğ½Ñ ĞºĞµÑˆ Ğ¼ĞµĞ½ĞµĞ´Ğ¶ĞµÑ€Ğ°
cache_manager = CacheManager()

# Ğ”ĞµĞºĞ¾Ñ€Ğ°Ñ‚Ğ¾Ñ€ Ğ´Ğ»Ñ ĞºĞµÑˆÑƒĞ²Ğ°Ğ½Ğ½Ñ Ñ„ÑƒĞ½ĞºÑ†Ñ–Ğ¹
def cached(timeout: int = 300, cache_type: CacheType = CacheType.HYBRID, key_prefix: str = ""):
    """
    Ğ”ĞµĞºĞ¾Ñ€Ğ°Ñ‚Ğ¾Ñ€ Ğ´Ğ»Ñ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡Ğ½Ğ¾Ğ³Ğ¾ ĞºĞµÑˆÑƒĞ²Ğ°Ğ½Ğ½Ñ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ–Ğ² Ñ„ÑƒĞ½ĞºÑ†Ñ–Ğ¹
    """
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ñ–Ñ ĞºĞ»ÑÑ‡Ğ° ĞºĞµÑˆÑƒ
            key_parts = [key_prefix or func.__name__]

            # Ğ”Ğ¾Ğ´Ğ°Ğ²Ğ°Ğ½Ğ½Ñ Ğ°Ñ€Ğ³ÑƒĞ¼ĞµĞ½Ñ‚Ñ–Ğ² Ğ´Ğ¾ ĞºĞ»ÑÑ‡Ğ°
            for arg in args:
                key_parts.append(str(arg))

            for k, v in sorted(kwargs.items()):
                key_parts.append(f"{k}:{v}")

            cache_key = ":".join(key_parts)

            # Ğ¡Ğ¿Ñ€Ğ¾Ğ±Ğ° Ğ¾Ñ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ Ğ· ĞºĞµÑˆÑƒ
            cached_result = cache_manager.get(cache_key, cache_type=cache_type)
            if cached_result is not None:
                return cached_result

            # Ğ’Ğ¸ĞºĞ¾Ğ½Ğ°Ğ½Ğ½Ñ Ñ„ÑƒĞ½ĞºÑ†Ñ–Ñ— Ñ‚Ğ° ĞºĞµÑˆÑƒĞ²Ğ°Ğ½Ğ½Ñ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñƒ
            result = func(*args, **kwargs)
            cache_manager.set(cache_key, result, timeout, cache_type)

            return result
        return wrapper
    return decorator

# Ğ¤ÑƒĞ½ĞºÑ†Ñ–Ñ— Ğ´Ğ»Ñ Ğ¾Ñ‡Ğ¸Ñ‰ĞµĞ½Ğ½Ñ ĞºĞµÑˆÑƒ
def clear_user_cache(telegram_id: str):
    """
    ĞÑ‡Ğ¸Ñ‰ĞµĞ½Ğ½Ñ Ğ²ÑÑŒĞ¾Ğ³Ğ¾ ĞºĞµÑˆÑƒ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ°
    """
    patterns = [
        f"*user:{telegram_id}*",
        f"*{telegram_id}*",
        f"*telegram_id:{telegram_id}*"
    ]

    for pattern in patterns:
        cache_manager.clear_pattern(pattern)

def clear_winix_cache(telegram_id: str = None):
    """
    ĞÑ‡Ğ¸Ñ‰ĞµĞ½Ğ½Ñ ĞºĞµÑˆÑƒ WINIX ÑĞ¸ÑÑ‚ĞµĞ¼Ğ¸
    """
    if telegram_id:
        patterns = [
            f"daily_bonus:{telegram_id}*",
            f"flex_balance:{telegram_id}*",
            f"task_progress:{telegram_id}*",
            f"wallet_info:{telegram_id}*"
        ]
    else:
        patterns = [
            "daily_bonus:*",
            "flex_balance:*",
            "task_progress:*",
            "wallet_info:*"
        ]

    for pattern in patterns:
        cache_manager.clear_pattern(pattern)
```

---

Ğ¦Ñ Ğ°Ñ€Ñ…Ñ–Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ° Ğ·Ğ°Ğ±ĞµĞ·Ğ¿ĞµÑ‡ÑƒÑ” Ğ½Ğ°Ğ´Ñ–Ğ¹Ğ½Ñƒ, Ğ¼Ğ°ÑÑˆÑ‚Ğ°Ğ±Ğ¾Ğ²Ğ°Ğ½Ñƒ Ñ‚Ğ° Ğ±ĞµĞ·Ğ¿ĞµÑ‡Ğ½Ñƒ Ñ€Ğ¾Ğ±Ğ¾Ñ‚Ñƒ backend ÑĞ¸ÑÑ‚ĞµĞ¼Ğ¸ Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½ÑŒ WINIX Ğ· Ğ¿Ğ¾Ğ²Ğ½Ğ¾Ñ Ğ¿Ñ–Ğ´Ñ‚Ñ€Ğ¸Ğ¼ĞºĞ¾Ñ Ğ²ÑÑ–Ñ… Ñ„ÑƒĞ½ĞºÑ†Ñ–Ğ¹: Ğ°Ğ½Ğ°Ğ»Ñ–Ñ‚Ğ¸ĞºĞ¸, Ñ‰Ğ¾Ğ´ĞµĞ½Ğ½Ğ¸Ñ… Ğ±Ğ¾Ğ½ÑƒÑÑ–Ğ², FLEX Ñ‚Ğ¾ĞºĞµĞ½Ñ–Ğ², Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½ÑŒ, Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ñ–Ğ¹ Ñ‚Ğ° TON Ğ³Ğ°Ğ¼Ğ°Ğ½Ñ†Ñ–Ğ²! ğŸš€

---

## ğŸ›¡ï¸ MIDDLEWARE LAYER - Cross-cutting Infrastructure

### `middleware/__init__.py` - Middleware Coordinator
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: Ğ¦ĞµĞ½Ñ‚Ñ€Ğ°Ğ»Ñ–Ğ·Ğ¾Ğ²Ğ°Ğ½Ğµ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»Ñ–Ğ½Ğ½Ñ middleware ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ğ°Ğ¼Ğ¸
```

**Ğ¤ÑƒĞ½ĞºÑ†Ñ–Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ:**
- ğŸ“‹ Middleware registration and initialization
- ğŸ¥ Health monitoring for middleware services
- âš™ï¸ Configuration management
- ğŸ”„ Request/response pipeline coordination

---

### `middleware/logger.py` - Advanced Logging System
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ¾Ğ²Ğ°Ğ½Ğµ Ğ»Ğ¾Ğ³ÑƒĞ²Ğ°Ğ½Ğ½Ñ, Ğ¼ĞµÑ‚Ñ€Ğ¸ĞºĞ¸, Ğ¼Ğ¾Ğ½Ñ–Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³
```

**ĞÑ€Ñ…Ñ–Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ° Ğ»Ğ¾Ğ³ÑƒĞ²Ğ°Ğ½Ğ½Ñ:**
```python
import logging
import json
import time
import psutil
import asyncio
from datetime import datetime
from typing import Dict, Any, Optional
from prometheus_client import Counter, Histogram, Gauge

class StructuredLogger:
    """
    Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğ¹ JSON logger Ğ· ĞºĞ¾Ğ½Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ¼
    """
    def __init__(self, name: str):
        self.logger = logging.getLogger(name)
        self.context: Dict[str, Any] = {}

        # JSON Formatter
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )

        # File Handler Ğ· Ñ€Ğ¾Ñ‚Ğ°Ñ†Ñ–Ñ”Ñ
        from logging.handlers import RotatingFileHandler
        file_handler = RotatingFileHandler(
            'logs/winix.log',
            maxBytes=LOG_FILE_MAX_SIZE,
            backupCount=LOG_FILE_BACKUP_COUNT
        )
        file_handler.setFormatter(formatter)

        # Console Handler
        console_handler = logging.StreamHandler()
        console_handler.setFormatter(formatter)

        self.logger.addHandler(file_handler)
        self.logger.addHandler(console_handler)
        self.logger.setLevel(getattr(logging, LOG_LEVEL))

    def set_context(self, **kwargs):
        """Ğ’ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ ĞºĞ¾Ğ½Ñ‚ĞµĞºÑÑ‚Ñƒ Ğ´Ğ»Ñ Ğ²ÑÑ–Ñ… Ğ½Ğ°ÑÑ‚ÑƒĞ¿Ğ½Ğ¸Ñ… Ğ»Ğ¾Ğ³Ñ–Ğ²"""
        self.context.update(kwargs)

    def clear_context(self):
        """ĞÑ‡Ğ¸Ñ‰ĞµĞ½Ğ½Ñ ĞºĞ¾Ğ½Ñ‚ĞµĞºÑÑ‚Ñƒ"""
        self.context.clear()

    def _format_message(self, message: str, extra: Dict[str, Any] = None) -> str:
        """Ğ¤Ğ¾Ñ€Ğ¼Ğ°Ñ‚ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ½Ñ Ğ² JSON"""
        log_data = {
            'timestamp': datetime.utcnow().isoformat(),
            'message': message,
            'context': self.context.copy()
        }

        if extra:
            log_data['extra'] = extra

        return json.dumps(log_data, default=str)

    def info(self, message: str, **kwargs):
        self.logger.info(self._format_message(message, kwargs))

    def warning(self, message: str, **kwargs):
        self.logger.warning(self._format_message(message, kwargs))

    def error(self, message: str, **kwargs):
        self.logger.error(self._format_message(message, kwargs))

    def debug(self, message: str, **kwargs):
        self.logger.debug(self._format_message(message, kwargs))

class MetricsCollector:
    """
    Ğ—Ğ±Ğ¸Ñ€Ğ°Ñ‡ Ğ¼ĞµÑ‚Ñ€Ğ¸Ğº Prometheus
    """
    def __init__(self):
        # Request metrics
        self.request_count = Counter(
            'winix_requests_total',
            'Total HTTP requests',
            ['method', 'endpoint', 'status']
        )

        self.request_duration = Histogram(
            'winix_request_duration_seconds',
            'HTTP request duration',
            ['method', 'endpoint']
        )

        # Business metrics
        self.daily_bonus_claims = Counter(
            'winix_daily_bonus_claims_total',
            'Total daily bonus claims'
        )

        self.task_completions = Counter(
            'winix_task_completions_total',
            'Total task completions',
            ['task_type']
        )

        self.flex_claims = Counter(
            'winix_flex_claims_total',
            'Total FLEX claims',
            ['level']
        )

        # System metrics
        self.active_users = Gauge(
            'winix_active_users',
            'Number of active users'
        )

        self.system_cpu = Gauge(
            'winix_system_cpu_percent',
            'System CPU usage percent'
        )

        self.system_memory = Gauge(
            'winix_system_memory_percent',
            'System memory usage percent'
        )

    def record_request(self, method: str, endpoint: str, status: int, duration: float):
        """Ğ—Ğ°Ğ¿Ğ¸Ñ Ğ¼ĞµÑ‚Ñ€Ğ¸ĞºĞ¸ HTTP Ğ·Ğ°Ğ¿Ğ¸Ñ‚Ñƒ"""
        self.request_count.labels(method=method, endpoint=endpoint, status=status).inc()
        self.request_duration.labels(method=method, endpoint=endpoint).observe(duration)

    def record_daily_bonus_claim(self):
        """Ğ—Ğ°Ğ¿Ğ¸Ñ Ğ¾Ñ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ Ñ‰Ğ¾Ğ´ĞµĞ½Ğ½Ğ¾Ğ³Ğ¾ Ğ±Ğ¾Ğ½ÑƒÑÑƒ"""
        self.daily_bonus_claims.inc()

    def record_task_completion(self, task_type: str):
        """Ğ—Ğ°Ğ¿Ğ¸Ñ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ½Ñ Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½Ğ½Ñ"""
        self.task_completions.labels(task_type=task_type).inc()

    def record_flex_claim(self, level: str):
        """Ğ—Ğ°Ğ¿Ğ¸Ñ Ğ¾Ñ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ FLEX Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´Ğ¸"""
        self.flex_claims.labels(level=level).inc()

    def update_system_metrics(self):
        """ĞĞ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ½Ğ¸Ñ… Ğ¼ĞµÑ‚Ñ€Ğ¸Ğº"""
        self.system_cpu.set(psutil.cpu_percent())
        self.system_memory.set(psutil.virtual_memory().percent)

class AlertManager:
    """
    ĞœĞµĞ½ĞµĞ´Ğ¶ĞµÑ€ Ğ°Ğ»ĞµÑ€Ñ‚Ñ–Ğ² Ñ‚Ğ° Ğ½Ğ¾Ñ‚Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ğ¹
    """
    def __init__(self):
        self.alerts: Dict[str, Dict] = {}
        self.alert_rules = {
            'high_error_rate': {
                'threshold': 0.1,  # 10% error rate
                'window': 300,     # 5 minutes
                'severity': 'critical'
            },
            'high_cpu_usage': {
                'threshold': 80,   # 80% CPU
                'window': 300,
                'severity': 'warning'
            },
            'slow_requests': {
                'threshold': 5.0,  # 5 seconds
                'window': 300,
                'severity': 'warning'
            }
        }

    def check_alert_conditions(self, metrics: Dict[str, float]):
        """ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° ÑƒĞ¼Ğ¾Ğ² Ğ°Ğ»ĞµÑ€Ñ‚Ñ–Ğ²"""
        for rule_name, rule in self.alert_rules.items():
            if self._should_trigger_alert(rule_name, metrics, rule):
                self._trigger_alert(rule_name, metrics[rule_name], rule)

    def _should_trigger_alert(self, rule_name: str, metrics: Dict, rule: Dict) -> bool:
        """ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ñ‡Ğ¸ Ñ‚Ñ€ĞµĞ±Ğ° Ñ‚Ñ€Ğ¸Ğ³ĞµÑ€Ğ¸Ñ‚Ğ¸ Ğ°Ğ»ĞµÑ€Ñ‚"""
        current_value = metrics.get(rule_name, 0)
        return current_value > rule['threshold']

    def _trigger_alert(self, rule_name: str, value: float, rule: Dict):
        """Ğ¢Ñ€Ğ¸Ğ³ĞµÑ€ Ğ°Ğ»ĞµÑ€Ñ‚Ñƒ"""
        alert_data = {
            'rule': rule_name,
            'value': value,
            'threshold': rule['threshold'],
            'severity': rule['severity'],
            'timestamp': time.time()
        }

        # Ğ—Ğ±ĞµÑ€ĞµĞ¶ĞµĞ½Ğ½Ñ Ğ°Ğ»ĞµÑ€Ñ‚Ñƒ
        self.alerts[rule_name] = alert_data

        # Ğ›Ğ¾Ğ³ÑƒĞ²Ğ°Ğ½Ğ½Ñ
        logger.error(f"ALERT TRIGGERED: {rule_name}", extra=alert_data)

        # Ğ’Ñ–Ğ´Ğ¿Ñ€Ğ°Ğ²ĞºĞ° Ğ½Ğ¾Ñ‚Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ— (webhook, email, etc.)
        asyncio.create_task(self._send_alert_notification(alert_data))

    async def _send_alert_notification(self, alert_data: Dict):
        """Ğ’Ñ–Ğ´Ğ¿Ñ€Ğ°Ğ²ĞºĞ° Ğ°Ğ»ĞµÑ€Ñ‚Ñƒ"""
        try:
            # Webhook notification
            webhook_url = os.getenv('ALERT_WEBHOOK_URL')
            if webhook_url:
                async with aiohttp.ClientSession() as session:
                    await session.post(webhook_url, json=alert_data)
        except Exception as e:
            logger.error(f"Failed to send alert notification: {e}")

class MonitoringManager:
    """
    Ğ¦ĞµĞ½Ñ‚Ñ€Ğ°Ğ»ÑŒĞ½Ğ¸Ğ¹ Ğ¼ĞµĞ½ĞµĞ´Ğ¶ĞµÑ€ Ğ¼Ğ¾Ğ½Ñ–Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³Ñƒ
    """
    def __init__(self):
        self.logger = StructuredLogger('winix.monitoring')
        self.metrics = MetricsCollector()
        self.alerts = AlertManager()
        self.health_checks: Dict[str, Callable] = {}

    def register_health_check(self, name: str, check_func: Callable):
        """Ğ ĞµÑ”ÑÑ‚Ñ€Ğ°Ñ†Ñ–Ñ health check Ñ„ÑƒĞ½ĞºÑ†Ñ–Ñ—"""
        self.health_checks[name] = check_func

    async def run_health_checks(self) -> Dict[str, Any]:
        """Ğ’Ğ¸ĞºĞ¾Ğ½Ğ°Ğ½Ğ½Ñ Ğ²ÑÑ–Ñ… health checks"""
        results = {}

        for name, check_func in self.health_checks.items():
            try:
                start_time = time.time()
                result = await check_func() if asyncio.iscoroutinefunction(check_func) else check_func()
                duration = time.time() - start_time

                results[name] = {
                    'status': 'healthy' if result else 'unhealthy',
                    'duration': duration,
                    'timestamp': time.time()
                }
            except Exception as e:
                results[name] = {
                    'status': 'error',
                    'error': str(e),
                    'timestamp': time.time()
                }

        return results

    def get_system_status(self) -> Dict[str, Any]:
        """ĞÑ‚Ñ€Ğ¸Ğ¼Ğ°Ğ½Ğ½Ñ Ğ·Ğ°Ğ³Ğ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ ÑÑ‚Ğ°Ñ‚ÑƒÑÑƒ ÑĞ¸ÑÑ‚ĞµĞ¼Ğ¸"""
        return {
            'uptime': time.time() - self.start_time,
            'cpu_percent': psutil.cpu_percent(),
            'memory_percent': psutil.virtual_memory().percent,
            'disk_percent': psutil.disk_usage('/').percent,
            'active_alerts': len(self.alerts.alerts)
        }

# Request Logging Middleware
class RequestLoggingMiddleware:
    """
    Middleware Ğ´Ğ»Ñ Ğ»Ğ¾Ğ³ÑƒĞ²Ğ°Ğ½Ğ½Ñ HTTP Ğ·Ğ°Ğ¿Ğ¸Ñ‚Ñ–Ğ²
    """
    def __init__(self, app):
        self.app = app
        self.logger = StructuredLogger('winix.requests')
        self.metrics = MetricsCollector()

    def __call__(self, environ, start_response):
        start_time = time.time()

        # Ğ—Ğ±Ñ–Ñ€ Ñ–Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ñ–Ñ— Ğ¿Ñ€Ğ¾ Ğ·Ğ°Ğ¿Ğ¸Ñ‚
        method = environ['REQUEST_METHOD']
        path = environ['PATH_INFO']
        remote_addr = environ.get('REMOTE_ADDR', 'unknown')
        user_agent = environ.get('HTTP_USER_AGENT', 'unknown')

        # Ğ’ÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ ĞºĞ¾Ğ½Ñ‚ĞµĞºÑÑ‚Ñƒ Ğ»Ğ¾Ğ³ÑƒĞ²Ğ°Ğ½Ğ½Ñ
        self.logger.set_context(
            method=method,
            path=path,
            remote_addr=remote_addr,
            user_agent=user_agent
        )

        def new_start_response(status, response_headers, exc_info=None):
            # Ğ›Ğ¾Ğ³ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ñ–
            duration = time.time() - start_time
            status_code = int(status.split()[0])

            # ĞœĞµÑ‚Ñ€Ğ¸ĞºĞ¸
            self.metrics.record_request(method, path, status_code, duration)

            # Ğ›Ğ¾Ğ³ÑƒĞ²Ğ°Ğ½Ğ½Ñ
            log_level = 'error' if status_code >= 400 else 'info'
            getattr(self.logger, log_level)(
                f"{method} {path} - {status}",
                duration=duration,
                status_code=status_code
            )

            return start_response(status, response_headers, exc_info)

        return self.app(environ, new_start_response)

# Ğ“Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ñ– Ñ–Ğ½ÑÑ‚Ğ°Ğ½ÑĞ¸
logger = StructuredLogger('winix')
monitoring_manager = MonitoringManager()
```

**Health Checks Registration:**
```python
# Ğ ĞµÑ”ÑÑ‚Ñ€Ğ°Ñ†Ñ–Ñ health checks
async def database_health_check():
    """ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ·Ğ´Ğ¾Ñ€Ğ¾Ğ²'Ñ Ğ±Ğ°Ğ·Ğ¸ Ğ´Ğ°Ğ½Ğ¸Ñ…"""
    try:
        result = supabase.table('winix').select('id').limit(1).execute()
        return len(result.data) >= 0
    except:
        return False

async def redis_health_check():
    """ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Redis"""
    try:
        return cache_manager.redis_cache.redis_client.ping()
    except:
        return False

async def external_services_health_check():
    """ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ·Ğ¾Ğ²Ğ½Ñ–ÑˆĞ½Ñ–Ñ… ÑĞµÑ€Ğ²Ñ–ÑÑ–Ğ²"""
    try:
        # Telegram API
        telegram_ok = await telegram_service.health_check()

        # TON API
        ton_ok = await ton_connect_service.health_check()

        return telegram_ok and ton_ok
    except:
        return False

# Ğ ĞµÑ”ÑÑ‚Ñ€Ğ°Ñ†Ñ–Ñ
monitoring_manager.register_health_check('database', database_health_check)
monitoring_manager.register_health_check('redis', redis_health_check)
monitoring_manager.register_health_check('external_services', external_services_health_check)
```

---

### `middleware/rate_limiter.py` - Advanced Rate Limiting
```python
Ğ’Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ğ°Ğ»ÑŒĞ½Ñ–ÑÑ‚ÑŒ: Ğ Ğ¾Ğ·Ğ¿Ğ¾Ğ´Ñ–Ğ»ĞµĞ½Ğµ rate limiting Ğ· Ñ€Ñ–Ğ·Ğ½Ğ¸Ğ¼Ğ¸ ÑÑ‚Ñ€Ğ°Ñ‚ĞµĞ³Ñ–ÑĞ¼Ğ¸
```

**ĞÑ€Ñ…Ñ–Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ° Rate Limiting:**
```python
import time
import hashlib
from typing import Dict, Any, Optional, Tuple
from enum import Enum
from dataclasses import dataclass

class RateLimitStrategy(Enum):
    """Ğ¡Ñ‚Ñ€Ğ°Ñ‚ĞµĞ³Ñ–Ñ— rate limiting"""
    FIXED_WINDOW = "fixed_window"      # Ğ¤Ñ–ĞºÑĞ¾Ğ²Ğ°Ğ½Ğµ Ğ²Ñ–ĞºĞ½Ğ¾
    SLIDING_WINDOW = "sliding_window"  # ĞšĞ¾Ğ²Ğ·Ğ½Ğµ Ğ²Ñ–ĞºĞ½Ğ¾
    TOKEN_BUCKET = "token_bucket"      # Ğ¢Ğ¾ĞºĞµĞ½-Ğ±Ğ°ĞºĞµÑ‚
    LEAKY_BUCKET = "leaky_bucket"      # Ğ”Ñ–Ñ€ÑĞ²Ğ¸Ğ¹ Ğ±Ğ°ĞºĞµÑ‚
    ADAPTIVE = "adaptive"              # ĞĞ´Ğ°Ğ¿Ñ‚Ğ¸Ğ²Ğ½Ğµ Ğ¾Ğ±Ğ¼ĞµĞ¶ĞµĞ½Ğ½Ñ

class RateLimitScope(Enum):
    """ĞĞ±Ğ»Ğ°ÑÑ‚Ñ– Ğ·Ğ°ÑÑ‚Ğ¾ÑÑƒĞ²Ğ°Ğ½Ğ½Ñ rate limiting"""
    GLOBAL = "global"       # Ğ“Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ñ– Ğ»Ñ–Ğ¼Ñ–Ñ‚Ğ¸
    IP = "ip"              # ĞŸĞ¾ IP Ğ°Ğ´Ñ€ĞµÑÑ–
    USER = "user"          # ĞŸĞ¾ ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ñƒ
    ENDPOINT = "endpoint"  # ĞŸĞ¾ endpoint'Ñƒ
    CUSTOM = "custom"      # ĞšĞ°ÑÑ‚Ğ¾Ğ¼Ğ½Ñ– ĞºĞ»ÑÑ‡Ñ–

@dataclass
class RateLimitRule:
    """ĞŸÑ€Ğ°Ğ²Ğ¸Ğ»Ğ¾ rate limiting"""
    max_requests: int
    window_seconds: int
    strategy: RateLimitStrategy
    scope: RateLimitScope
    burst_allowance: int = 0  # Ğ”Ğ¾Ğ·Ğ²Ğ¾Ğ»ĞµĞ½Ñ– Ğ¿Ñ–ĞºĞ¾Ğ²Ñ– Ğ·Ğ°Ğ¿Ğ¸Ñ‚Ğ¸

class RateLimitResult:
    """Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚ Ğ¿ĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ¸ rate limit"""
    def __init__(self, allowed: bool, remaining: int = 0, reset_time: int = 0, retry_after: int = 0):
        self.allowed = allowed
        self.remaining = remaining
        self.reset_time = reset_time
        self.retry_after = retry_after

class MemoryRateLimiter:
    """
    In-memory rate limiter Ğ´Ğ»Ñ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ²Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ°Ğ½Ğ½Ñ
    """
    def __init__(self):
        self.storage: Dict[str, Dict] = {}
        self.cleanup_interval = 3600  # ĞÑ‡Ğ¸Ñ‰ĞµĞ½Ğ½Ñ ĞºĞ¾Ğ¶Ğ½Ñƒ Ğ³Ğ¾Ğ´Ğ¸Ğ½Ñƒ
        self.last_cleanup = time.time()

    def _cleanup_expired(self):
        """ĞÑ‡Ğ¸Ñ‰ĞµĞ½Ğ½Ñ Ğ·Ğ°ÑÑ‚Ğ°Ñ€Ñ–Ğ»Ğ¸Ñ… Ğ·Ğ°Ğ¿Ğ¸ÑÑ–Ğ²"""
        current_time = time.time()
        if current_time - self.last_cleanup < self.cleanup_interval:
            return

        expired_keys = []
        for key, data in self.storage.items():
            if data.get('expires_at', 0) < current_time:
                expired_keys.append(key)

        for key in expired_keys:
            del self.storage[key]

        self.last_cleanup = current_time

    def check_rate_limit(self, key: str, rule: RateLimitRule) -> RateLimitResult:
        """ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° rate limit"""
        self._cleanup_expired()
        current_time = time.time()

        if rule.strategy == RateLimitStrategy.FIXED_WINDOW:
            return self._fixed_window_check(key, rule, current_time)
        elif rule.strategy == RateLimitStrategy.SLIDING_WINDOW:
            return self._sliding_window_check(key, rule, current_time)
        elif rule.strategy == RateLimitStrategy.TOKEN_BUCKET:
            return self._token_bucket_check(key, rule, current_time)
        else:
            # Fallback Ğ´Ğ¾ fixed window
            return self._fixed_window_check(key, rule, current_time)

    def _fixed_window_check(self, key: str, rule: RateLimitRule, current_time: float) -> RateLimitResult:
        """Fixed window rate limiting"""
        window_start = int(current_time // rule.window_seconds) * rule.window_seconds
        window_key = f"{key}:{window_start}"

        if window_key not in self.storage:
            self.storage[window_key] = {
                'count': 0,
                'window_start': window_start,
                'expires_at': window_start + rule.window_seconds * 2
            }

        data = self.storage[window_key]

        if data['count'] >= rule.max_requests:
            reset_time = int(window_start + rule.window_seconds)
            retry_after = reset_time - int(current_time)
            return RateLimitResult(False, 0, reset_time, retry_after)

        # Ğ†Ğ½ĞºÑ€ĞµĞ¼ĞµĞ½Ñ‚ Ğ»Ñ–Ñ‡Ğ¸Ğ»ÑŒĞ½Ğ¸ĞºĞ°
        data['count'] += 1
        remaining = rule.max_requests - data['count']
        reset_time = int(window_start + rule.window_seconds)

        return RateLimitResult(True, remaining, reset_time, 0)

    def _sliding_window_check(self, key: str, rule: RateLimitRule, current_time: float) -> RateLimitResult:
        """Sliding window rate limiting"""
        if key not in self.storage:
            self.storage[key] = {
                'requests': [],
                'expires_at': current_time + rule.window_seconds * 2
            }

        data = self.storage[key]
        requests = data['requests']

        # Ğ’Ğ¸Ğ´Ğ°Ğ»ĞµĞ½Ğ½Ñ Ğ·Ğ°ÑÑ‚Ğ°Ñ€Ñ–Ğ»Ğ¸Ñ… Ğ·Ğ°Ğ¿Ğ¸Ñ‚Ñ–Ğ²
        cutoff_time = current_time - rule.window_seconds
        data['requests'] = [req_time for req_time in requests if req_time > cutoff_time]

        if len(data['requests']) >= rule.max_requests:
            oldest_request = min(data['requests'])
            retry_after = int(oldest_request + rule.window_seconds - current_time)
            return RateLimitResult(False, 0, 0, max(1, retry_after))

        # Ğ”Ğ¾Ğ´Ğ°Ğ²Ğ°Ğ½Ğ½Ñ Ğ¿Ğ¾Ñ‚Ğ¾Ñ‡Ğ½Ğ¾Ğ³Ğ¾ Ğ·Ğ°Ğ¿Ğ¸Ñ‚Ñƒ
        data['requests'].append(current_time)
        remaining = rule.max_requests - len(data['requests'])

        return RateLimitResult(True, remaining, 0, 0)

    def _token_bucket_check(self, key: str, rule: RateLimitRule, current_time: float) -> RateLimitResult:
        """Token bucket rate limiting"""
        if key not in self.storage:
            self.storage[key] = {
                'tokens': rule.max_requests,
                'last_refill': current_time,
                'expires_at': current_time + rule.window_seconds * 2
            }

        data = self.storage[key]

        # ĞŸĞ¾Ğ¿Ğ¾Ğ²Ğ½ĞµĞ½Ğ½Ñ Ñ‚Ğ¾ĞºĞµĞ½Ñ–Ğ²
        time_passed = current_time - data['last_refill']
        tokens_to_add = (time_passed / rule.window_seconds) * rule.max_requests
        data['tokens'] = min(rule.max_requests, data['tokens'] + tokens_to_add)
        data['last_refill'] = current_time

        if data['tokens'] < 1:
            retry_after = int((1 - data['tokens']) * rule.window_seconds / rule.max_requests)
            return RateLimitResult(False, 0, 0, max(1, retry_after))

        # Ğ’Ğ¸Ñ‚Ñ€Ğ°Ñ‚Ğ° Ñ‚Ğ¾ĞºĞµĞ½Ñƒ
        data['tokens'] -= 1

        return RateLimitResult(True, int(data['tokens']), 0, 0)

class RedisRateLimiter:
    """
    Redis-based rate limiter Ğ´Ğ»Ñ Ñ€Ğ¾Ğ·Ğ¿Ğ¾Ğ´Ñ–Ğ»ĞµĞ½Ğ¾Ğ³Ğ¾ Ğ²Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ°Ğ½Ğ½Ñ
    """
    def __init__(self, redis_client):
        self.redis = redis_client
        self.script_sha = None
        self._load_lua_scripts()

    def _load_lua_scripts(self):
        """Ğ—Ğ°Ğ²Ğ°Ğ½Ñ‚Ğ°Ğ¶ĞµĞ½Ğ½Ñ Lua ÑĞºÑ€Ğ¸Ğ¿Ñ‚Ñ–Ğ² Ğ´Ğ»Ñ Ğ°Ñ‚Ğ¾Ğ¼Ğ°Ñ€Ğ½Ğ¸Ñ… Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ñ–Ğ¹"""
        sliding_window_script = """
        local key = KEYS[1]
        local window = tonumber(ARGV[1])
        local limit = tonumber(ARGV[2])
        local current_time = tonumber(ARGV[3])

        -- Ğ’Ğ¸Ğ´Ğ°Ğ»ĞµĞ½Ğ½Ñ Ğ·Ğ°ÑÑ‚Ğ°Ñ€Ñ–Ğ»Ğ¸Ñ… Ğ·Ğ°Ğ¿Ğ¸ÑÑ–Ğ²
        redis.call('ZREMRANGEBYSCORE', key, '-inf', current_time - window)

        -- ĞŸÑ–Ğ´Ñ€Ğ°Ñ…ÑƒĞ½Ğ¾Ğº Ğ¿Ğ¾Ñ‚Ğ¾Ñ‡Ğ½Ğ¸Ñ… Ğ·Ğ°Ğ¿Ğ¸Ñ‚Ñ–Ğ²
        local current_requests = redis.call('ZCARD', key)

        if current_requests < limit then
            -- Ğ”Ğ¾Ğ´Ğ°Ğ²Ğ°Ğ½Ğ½Ñ Ğ¿Ğ¾Ñ‚Ğ¾Ñ‡Ğ½Ğ¾Ğ³Ğ¾ Ğ·Ğ°Ğ¿Ğ¸Ñ‚Ñƒ
            redis.call('ZADD', key, current_time, current_time)
            redis.call('EXPIRE', key, window)
            return {1, limit - current_requests - 1}
        else
            return {0, 0}
        end
        """

        try:
            self.script_sha = self.redis.script_load(sliding_window_script)
        except Exception as e:
            logger.error(f"Failed to load Redis Lua script: {e}")

    def check_rate_limit(self, key: str, rule: RateLimitRule) -> RateLimitResult:
        """ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° rate limit Ñ‡ĞµÑ€ĞµĞ· Redis"""
        try:
            if rule.strategy == RateLimitStrategy.SLIDING_WINDOW and self.script_sha:
                return self._redis_sliding_window_check(key, rule)
            else:
                return self._redis_fixed_window_check(key, rule)
        except Exception as e:
            logger.error(f"Redis rate limit check failed: {e}")
            # Fallback - Ğ´Ğ¾Ğ·Ğ²Ğ¾Ğ»ÑÑ”Ğ¼Ğ¾ Ğ·Ğ°Ğ¿Ğ¸Ñ‚ Ğ¿Ñ€Ğ¸ Ğ¿Ğ¾Ğ¼Ğ¸Ğ»Ñ†Ñ– Redis
            return RateLimitResult(True, rule.max_requests, 0, 0)

    def _redis_sliding_window_check(self, key: str, rule: RateLimitRule) -> RateLimitResult:
        """Sliding window Ñ‡ĞµÑ€ĞµĞ· Redis Lua script"""
        current_time = time.time()

        result = self.redis.evalsha(
            self.script_sha, 1, key,
            rule.window_seconds, rule.max_requests, current_time
        )

        allowed = bool(result[0])
        remaining = int(result[1])

        if not allowed:
            # ĞŸÑ–Ğ´Ñ€Ğ°Ñ…ÑƒĞ½Ğ¾Ğº retry_after
            oldest_request = self.redis.zrange(key, 0, 0, withscores=True)
            if oldest_request:
                retry_after = int(oldest_request[0][1] + rule.window_seconds - current_time)
            else:
                retry_after = rule.window_seconds

            return RateLimitResult(False, 0, 0, max(1, retry_after))

        return RateLimitResult(True, remaining, 0, 0)

    def _redis_fixed_window_check(self, key: str, rule: RateLimitRule) -> RateLimitResult:
        """Fixed window Ñ‡ĞµÑ€ĞµĞ· Redis"""
        current_time = time.time()
        window_start = int(current_time // rule.window_seconds) * rule.window_seconds
        window_key = f"{key}:{window_start}"

        pipe = self.redis.pipeline()
        pipe.incr(window_key)
        pipe.expire(window_key, rule.window_seconds)
        results = pipe.execute()

        current_count = results[0]

        if current_count > rule.max_requests:
            reset_time = int(window_start + rule.window_seconds)
            retry_after = reset_time - int(current_time)
            return RateLimitResult(False, 0, reset_time, max(1, retry_after))

        remaining = rule.max_requests - current_count
        reset_time = int(window_start + rule.window_seconds)

        return RateLimitResult(True, remaining, reset_time, 0)

class RateLimitManager:
    """
    Ğ¦ĞµĞ½Ñ‚Ñ€Ğ°Ğ»ÑŒĞ½Ğ¸Ğ¹ Ğ¼ĞµĞ½ĞµĞ´Ğ¶ĞµÑ€ rate limiting
    """
    def __init__(self):
        self.memory_limiter = MemoryRateLimiter()
        self.redis_limiter = RedisRateLimiter(cache_manager.redis_cache.redis_client) if cache_manager.redis_cache.available else None
        self.rules: Dict[str, RateLimitRule] = {}
        self.global_rules: List[RateLimitRule] = []

        # ĞĞ°Ğ»Ğ°ÑˆÑ‚ÑƒĞ²Ğ°Ğ½Ğ½Ñ ÑÑ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ½Ğ¸Ñ… Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»
        self._setup_default_rules()

    def _setup_default_rules(self):
        """ĞĞ°Ğ»Ğ°ÑˆÑ‚ÑƒĞ²Ğ°Ğ½Ğ½Ñ ÑÑ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ½Ğ¸Ñ… Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ» rate limiting"""
        self.rules.update({
            'auth_login': RateLimitRule(
                max_requests=5,
                window_seconds=300,  # 5 Ñ…Ğ²Ğ¸Ğ»Ğ¸Ğ½
                strategy=RateLimitStrategy.SLIDING_WINDOW,
                scope=RateLimitScope.IP
            ),
            'daily_bonus_claim': RateLimitRule(
                max_requests=2,
                window_seconds=86400,  # 24 Ğ³Ğ¾Ğ´Ğ¸Ğ½Ğ¸
                strategy=RateLimitStrategy.FIXED_WINDOW,
                scope=RateLimitScope.USER
            ),
            'task_verification': RateLimitRule(
                max_requests=10,
                window_seconds=3600,  # 1 Ğ³Ğ¾Ğ´Ğ¸Ğ½Ğ°
                strategy=RateLimitStrategy.SLIDING_WINDOW,
                scope=RateLimitScope.USER
            ),
            'wallet_connect': RateLimitRule(
                max_requests=3,
                window_seconds=300,  # 5 Ñ…Ğ²Ğ¸Ğ»Ğ¸Ğ½
                strategy=RateLimitStrategy.SLIDING_WINDOW,
                scope=RateLimitScope.USER
            ),
            'api_general': RateLimitRule(
                max_requests=100,
                window_seconds=60,  # 1 Ñ…Ğ²Ğ¸Ğ»Ğ¸Ğ½Ğ°
                strategy=RateLimitStrategy.SLIDING_WINDOW,
                scope=RateLimitScope.IP
            )
        })

    def add_rule(self, name: str, rule: RateLimitRule):
        """Ğ”Ğ¾Ğ´Ğ°Ğ²Ğ°Ğ½Ğ½Ñ ĞºĞ°ÑÑ‚Ğ¾Ğ¼Ğ½Ğ¾Ğ³Ğ¾ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»Ğ°"""
        self.rules[name] = rule

    def check_rate_limit(self, rule_name: str, identifier: str, custom_key: str = None) -> RateLimitResult:
        """
        ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° rate limit

        Args:
            rule_name: ĞĞ°Ğ·Ğ²Ğ° Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»Ğ°
            identifier: Ğ†Ğ´ĞµĞ½Ñ‚Ğ¸Ñ„Ñ–ĞºĞ°Ñ‚Ğ¾Ñ€ (IP, user_id, etc.)
            custom_key: ĞšĞ°ÑÑ‚Ğ¾Ğ¼Ğ½Ğ¸Ğ¹ ĞºĞ»ÑÑ‡ Ğ´Ğ»Ñ Ğ´Ğ¾Ğ´Ğ°Ñ‚ĞºĞ¾Ğ²Ğ¾Ñ— Ñ–Ğ´ĞµĞ½Ñ‚Ğ¸Ñ„Ñ–ĞºĞ°Ñ†Ñ–Ñ—
        """
        if rule_name not in self.rules:
            logger.warning(f"Unknown rate limit rule: {rule_name}")
            return RateLimitResult(True, 999, 0, 0)

        rule = self.rules[rule_name]

        # Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ñ–Ñ ĞºĞ»ÑÑ‡Ğ°
        key_parts = [rule_name, identifier]
        if custom_key:
            key_parts.append(custom_key)

        key = ":".join(key_parts)
        key_hash = hashlib.md5(key.encode()).hexdigest()

        # Ğ’Ğ¸Ğ±Ñ–Ñ€ rate limiter
        if self.redis_limiter and RATE_LIMIT_STORAGE == 'redis':
            return self.redis_limiter.check_rate_limit(key_hash, rule)
        else:
            return self.memory_limiter.check_rate_limit(key_hash, rule)

    def get_statistics(self) -> Dict[str, Any]:
        """Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° rate limiting"""
        return {
            'rules_count': len(self.rules),
            'active_limiters': {
                'memory': True,
                'redis': self.redis_limiter is not None
            },
            'rules': {name: {
                'max_requests': rule.max_requests,
                'window_seconds': rule.window_seconds,
                'strategy': rule.strategy.value,
                'scope': rule.scope.value
            } for name, rule in self.rules.items()}
        }

# Flask Middleware Ğ´Ğ»Ñ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡Ğ½Ğ¾Ğ³Ğ¾ rate limiting
class RateLimitMiddleware:
    """
    Flask middleware Ğ´Ğ»Ñ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡Ğ½Ğ¾Ğ³Ğ¾ Ğ·Ğ°ÑÑ‚Ğ¾ÑÑƒĞ²Ğ°Ğ½Ğ½Ñ rate limiting
    """
    def __init__(self, app, rate_limit_manager: RateLimitManager):
        self.app = app
        self.rate_limiter = rate_limit_manager

        # ĞœĞ°Ğ¿Ñ–Ğ½Ğ³ endpoint'Ñ–Ğ² Ğ½Ğ° Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»Ğ°
        self.endpoint_rules = {
            '/api/auth/validate-telegram': 'auth_login',
            '/api/daily/claim': 'daily_bonus_claim',
            '/api/tasks/verify': 'task_verification',
            '/api/wallet/connect': 'wallet_connect'
        }

    def __call__(self, environ, start_response):
        path = environ['PATH_INFO']
        method = environ['REQUEST_METHOD']
        remote_addr = environ.get('REMOTE_ADDR', 'unknown')

        # Ğ’Ğ¸Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ½Ñ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»Ğ° Ğ´Ğ»Ñ endpoint'Ñƒ
        rule_name = self.endpoint_rules.get(path, 'api_general')

        # ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° rate limit
        result = self.rate_limiter.check_rate_limit(rule_name, remote_addr)

        if not result.allowed:
            # Rate limit Ğ¿ĞµÑ€ĞµĞ²Ğ¸Ñ‰ĞµĞ½Ğ¾
            response_body = json.dumps({
                'error': 'Rate limit exceeded',
                'retry_after': result.retry_after
            }).encode()

            headers = [
                ('Content-Type', 'application/json'),
                ('Content-Length', str(len(response_body))),
                ('X-RateLimit-Limit', str(self.rate_limiter.rules[rule_name].max_requests)),
                ('X-RateLimit-Remaining', '0'),
                ('X-RateLimit-Reset', str(result.reset_time)),
                ('Retry-After', str(result.retry_after))
            ]

            start_response('429 Too Many Requests', headers)
            return [response_body]

        # Ğ”Ğ¾Ğ´Ğ°Ğ²Ğ°Ğ½Ğ½Ñ rate limit headers Ğ´Ğ¾ Ğ²Ñ–Ğ´Ğ¿Ğ¾Ğ²Ñ–Ğ´Ñ–
        def new_start_response(status, response_headers, exc_info=None):
            response_headers.extend([
                ('X-RateLimit-Limit', str(self.rate_limiter.rules[rule_name].max_requests)),
                ('X-RateLimit-Remaining', str(result.remaining)),
                ('X-RateLimit-Reset', str(result.reset_time))
            ])
            return start_response(status, response_headers, exc_info)

        return self.app(environ, new_start_response)

# Ğ“Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ğ¸Ğ¹ Ñ–Ğ½ÑÑ‚Ğ°Ğ½Ñ
rate_limit_manager = RateLimitManager()
```

---

## ğŸ”— ĞŸĞ¾Ğ²Ğ½Ñ– Ğ´Ñ–Ğ°Ğ³Ñ€Ğ°Ğ¼Ğ¸ Ğ²Ğ·Ğ°Ñ”Ğ¼Ğ¾Ğ´Ñ–Ğ¹ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ñ–Ğ²

### 1. **ĞŸĞ¾Ğ²Ğ½Ğ¸Ğ¹ User Journey Flow**
```mermaid
graph TD
    A[User Opens Mini App] --> B[Telegram WebApp Init]
    B --> C[POST /api/auth/validate-telegram]
    C --> D[auth_controller.validate_telegram()]
    D --> E[telegram_service.validate_webapp_data()]
    E --> F[UserQuest.get_or_create_user()]
    F --> G[JWT Token Generation]
    G --> H[Welcome Bonus via Transaction Service]
    H --> I[Analytics Event Logging]
    I --> J[Response: User + Token]

    J --> K[Daily Bonus Check]
    K --> L[GET /api/daily/status]
    L --> M[daily_controller.get_status()]
    M --> N[DailyBonusManager.get_user_status()]
    N --> O[RewardCalculator.preview_reward()]
    O --> P[Response: Can Claim Status]

    P --> Q[User Claims Bonus]
    Q --> R[POST /api/daily/claim]
    R --> S[daily_controller.claim_bonus()]
    S --> T[RewardCalculator.calculate_reward()]
    T --> U[TransactionService.process_daily_bonus()]
    U --> V[Supabase: Atomic Balance Update]
    V --> W[DailyBonusManager.mark_claimed()]
    W --> X[Analytics: Daily Claimed Event]
    X --> Y[Response: Reward + New Balance]

    Y --> Z[Task Execution Flow]
    Z --> AA[GET /api/tasks/list]
    AA --> BB[TasksController.get_list()]
    BB --> CC[TaskModel.get_available_tasks()]
    CC --> DD[Filter Completed Tasks]
    DD --> EE[Response: Available Tasks]

    EE --> FF[User Starts Task]
    FF --> GG[POST /api/tasks/start]
    GG --> HH[TasksController.start_task()]
    HH --> II[TaskModel.update_progress()]
    II --> JJ[VerificationService.schedule_check()]
    JJ --> KK[Response: Task Started + Timer]

    KK --> LL[User Completes Action]
    LL --> MM[POST /api/tasks/verify]
    MM --> NN[TasksController.verify_task()]
    NN --> OO[VerificationService.complete_verification()]
    OO --> PP{Verification Successful?}

    PP -->|Yes| QQ[TransactionService.process_task_reward()]
    PP -->|No| RR[Update Status: Failed]

    QQ --> SS[TaskModel.mark_completed()]
    SS --> TT[Analytics: Task Completed Event]
    TT --> UU[Response: Verified + Reward]

    UU --> VV[Wallet Connection Flow]
    VV --> WW[POST /api/wallet/connect]
    WW --> XX[WalletController.connect_wallet()]
    XX --> YY[TONConnectService.validate_address()]
    YY --> ZZ[WalletModel.create_connection()]
    ZZ --> AAA[TransactionService.wallet_bonus()]
    AAA --> BBB[TONConnectService.get_balances()]
    BBB --> CCC[Analytics: Wallet Connected Event]
    CCC --> DDD[Response: Connected + Bonus]

    DDD --> EEE[FLEX Rewards Flow]
    EEE --> FFF[GET /api/flex/levels]
    FFF --> GGG[FlexController.get_levels()]
    GGG --> HHH[TONConnectService.get_flex_balance()]
    HHH --> III[FlexRewards.calculate_available_levels()]
    III --> JJJ[Response: Available Levels]

    JJJ --> KKK[User Claims FLEX Reward]
    KKK --> LLL[POST /api/flex/claim]
    LLL --> MMM[FlexController.claim_reward()]
    MMM --> NNN[Validate FLEX Balance + Cooldown]
    NNN --> OOO[TransactionService.process_flex_reward()]
    OOO --> PPP[FlexRewards.set_cooldown()]
    PPP --> QQQ[Analytics: FLEX Claimed Event]
    QQQ --> RRR[Response: Claimed + Reward]
```

### 2. **Transaction Service Central Hub Architecture**
```mermaid
graph TD
    subgraph "Transaction Service Ecosystem"
        TS[Transaction Service Core]

        subgraph "Input Sources"
            DC[Daily Controller]
            FC[FLEX Controller]
            TC[Tasks Controller]
            WC[Wallet Controller]
            UC[User Controller]
        end

        subgraph "Core Methods"
            PR[process_reward()]
            PS[process_spending()]
            PDB[process_daily_bonus()]
            PFR[process_flex_reward()]
            PTR[process_task_reward()]
            PWB[process_wallet_bonus()]
        end

        subgraph "Data Layer"
            TM[Transaction Model]
            UM[User Model]
            DB[(Supabase Database)]
        end

        subgraph "Analytics & Monitoring"
            AE[Analytics Events]
            ML[Metrics Logging]
            AL[Audit Logging]
        end
    end

    DC --> PR
    FC --> PFR
    TC --> PTR
    WC --> PWB
    UC --> PS

    PR --> TM
    PFR --> TM
    PTR --> TM
    PWB --> TM
    PS --> TM

    TM --> DB
    UM --> DB

    TS --> AE
    TS --> ML
    TS --> AL

    style TS fill:#ff9999
    style DB fill:#99ccff
    style AE fill:#99ff99
```

### 3. **Security & Middleware Pipeline**
```mermaid
graph TD
    subgraph "Request Pipeline"
        A[HTTP Request] --> B[Rate Limiting Middleware]
        B --> C[Request Logging Middleware]
        C --> D[Security Headers Middleware]
        D --> E[CORS Middleware]
        E --> F[Flask Routes]

        F --> G[Route Decorators]
        G --> H[@secure_endpoint]
        H --> I[@validate_json]
        I --> J[@validate_telegram_id]
        J --> K[@require_auth]

        K --> L[JWT Token Validation]
        L --> M[Controller Function]
        M --> N[Business Logic]
        N --> O[Service Layer]
        O --> P[Model Layer]
        P --> Q[Database]

        Q --> R[Response]
        R --> S[Security Headers Added]
        S --> T[Metrics Recorded]
        T --> U[Request Logged]
        U --> V[HTTP Response]
    end

    subgraph "Security Validations"
        L --> AA[decode_jwt_token()]
        AA --> BB{Token Valid?}
        BB -->|Yes| CC[Extract User Context]
        BB -->|No| DD[401 Unauthorized]

        CC --> EE[IP Validation]
        EE --> FF[Fresh Token Check]
        FF --> MM[Set g.current_user]
    end

    subgraph "Rate Limiting"
        B --> GG[Determine Rule]
        GG --> HH[Generate Key]
        HH --> II[Check Limit]
        II --> JJ{Limit Exceeded?}
        JJ -->|Yes| KK[429 Too Many Requests]
        JJ -->|No| LL[Add Rate Headers]
    end

    style A fill:#ffcc99
    style V fill:#99ff99
    style DD fill:#ff9999
    style KK fill:#ff9999
```

### 4. **External Services Integration**
```mermaid
graph TD
    subgraph "WINIX Backend"
        subgraph "Services Layer"
            TS[Telegram Service]
            TON[TON Connect Service]
            VS[Verification Service]
            AS[Analytics Service]
        end

        subgraph "Controllers"
            AC[Auth Controller]
            TC[Tasks Controller]
            WC[Wallet Controller]
            FC[FLEX Controller]
        end
    end

    subgraph "External APIs"
        TG[Telegram Bot API]
        TB[TON Blockchain]
        FLEX[FLEX Smart Contract]
        YT[YouTube API]
        TW[Twitter API]
        DC[Discord API]
    end

    subgraph "Database & Cache"
        DB[(Supabase PostgreSQL)]
        RC[(Redis Cache)]
        MC[Memory Cache]
    end

    AC --> TS
    TS --> TG

    TC --> VS
    VS --> TS
    VS --> YT
    VS --> TW
    VS --> DC

    WC --> TON
    FC --> TON
    TON --> TB
    TON --> FLEX

    AS --> DB

    TS --> RC
    TON --> MC
    VS --> RC

    style TG fill:#0088cc
    style TB fill:#0066cc
    style FLEX fill:#00aa00
    style DB fill:#ff6600
    style RC fill:#cc0000
```

### 5. **Error Handling & Fallback Mechanisms**
```mermaid
graph TD
    subgraph "Primary Flow"
        A[Request] --> B[Controller]
        B --> C[Service Layer]
        C --> D[External API Call]
        D --> E{API Available?}
        E -->|Yes| F[Process Response]
        E -->|No| G[Trigger Fallback]

        F --> H[Update Database]
        H --> I[Success Response]
    end

    subgraph "Fallback Mechanisms"
        G --> J{Cache Available?}
        J -->|Yes| K[Use Cached Data]
        J -->|No| L[Use Default Values]

        K --> M[Partial Success Response]
        L --> N[Degraded Service Response]

        M --> O[Schedule Retry]
        N --> P[Log Error for Manual Review]
    end

    subgraph "Transaction Service Fallback"
        Q[Transaction Service Down] --> R[Use Direct DB Operations]
        R --> S[Manual Transaction Logging]
        S --> T[Queue for Later Sync]
        T --> U[Success with Warning]
    end

    subgraph "Database Fallback"
        V[Database Connection Lost] --> W[Switch to Read Replicas]
        W --> X{Replicas Available?}
        X -->|Yes| Y[Continue with Read-Only]
        X -->|No| Z[Cache-Only Mode]

        Y --> AA[Queue Write Operations]
        Z --> BB[Return Cached Responses]
    end

    style G fill:#ffaa00
    style Q fill:#ffaa00
    style V fill:#ff6600
    style I fill:#00aa00
    style U fill:#aaaa00
```

---

## ğŸš€ Deployment & Configuration

### **Environment Configuration**
```bash
# Production Environment Variables
ENVIRONMENT=production
DEBUG=false
SECRET_KEY=your-super-secret-key-here
JWT_SECRET_KEY=your-jwt-secret-key

# Database Configuration
SUPABASE_URL=https://your-project.supabase.co
SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_KEY=your-service-key

# Telegram Configuration
TELEGRAM_BOT_TOKEN=your-bot-token
TELEGRAM_BOT_USERNAME=your-bot-username

# TON Blockchain
TON_API_KEY=your-ton-api-key
TON_NETWORK=mainnet
FLEX_CONTRACT_ADDRESS=your-flex-contract-address

# Redis Configuration
REDIS_HOST=your-redis-host
REDIS_PORT=6379
REDIS_PASSWORD=your-redis-password

# Rate Limiting
RATE_LIMIT_ENABLED=true
RATE_LIMIT_STORAGE=redis

# Monitoring
LOG_LEVEL=INFO
ALERT_WEBHOOK_URL=your-alert-webhook

# Security
CORS_ORIGINS=https://your-frontend-domain.com
TRUSTED_PROXIES=10.0.0.0/8,172.16.0.0/12,192.168.0.0/16
```

### **Docker Configuration**
```dockerfile
# Dockerfile
FROM python:3.11-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    build-essential \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements and install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Create logs directory
RUN mkdir -p logs

# Set environment variables
ENV PYTHONPATH=/app
ENV FLASK_APP=main.py

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:5000/api/health || exit 1

# Expose port
EXPOSE 5000

# Run application
CMD ["gunicorn", "--bind", "0.0.0.0:5000", "--workers", "4", "--timeout", "120", "main:app"]
```

### **Docker Compose**
```yaml
# docker-compose.yml
version: '3.8'

services:
  winix-backend:
    build: .
    ports:
      - "5000:5000"
    environment:
      - ENVIRONMENT=production
      - REDIS_HOST=redis
    depends_on:
      - redis
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    restart: unless-stopped

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - winix-backend
    restart: unless-stopped

volumes:
  redis_data:
```

### **Production Monitoring Setup**
```python
# monitoring/prometheus.py
from prometheus_client import start_http_server, generate_latest
from flask import Response

def setup_prometheus_metrics(app):
    """ĞĞ°Ğ»Ğ°ÑˆÑ‚ÑƒĞ²Ğ°Ğ½Ğ½Ñ Prometheus Ğ¼ĞµÑ‚Ñ€Ğ¸Ğº"""

    @app.route('/metrics')
    def metrics():
        """Prometheus metrics endpoint"""
        return Response(
            generate_latest(),
            mimetype='text/plain'
        )

    # Ğ—Ğ°Ğ¿ÑƒÑĞº Prometheus HTTP ÑĞµÑ€Ğ²ĞµÑ€Ğ°
    start_http_server(8000)

# monitoring/grafana_dashboards.json
{
  "dashboard": {
    "title": "WINIX Backend Monitoring",
    "panels": [
      {
        "title": "Request Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(winix_requests_total[5m])",
            "legendFormat": "{{method}} {{endpoint}}"
          }
        ]
      },
      {
        "title": "Error Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(winix_requests_total{status=~'4..|5..'}[5m])",
            "legendFormat": "Errors"
          }
        ]
      },
      {
        "title": "Daily Bonus Claims",
        "type": "stat",
        "targets": [
          {
            "expr": "increase(winix_daily_bonus_claims_total[24h])",
            "legendFormat": "Claims Today"
          }
        ]
      }
    ]
  }
}
```

## ğŸ“ˆ Performance Optimization

### **Database Optimization**
```sql
-- ĞĞ¿Ñ‚Ğ¸Ğ¼Ñ–Ğ·Ğ°Ñ†Ñ–Ñ Ñ–Ğ½Ğ´ĞµĞºÑÑ–Ğ² Ğ´Ğ»Ñ Ñ‡Ğ°ÑÑ‚Ğ¸Ñ… Ğ·Ğ°Ğ¿Ğ¸Ñ‚Ñ–Ğ²
CREATE INDEX CONCURRENTLY idx_winix_telegram_id ON winix(telegram_id);
CREATE INDEX CONCURRENTLY idx_transactions_user_created ON transactions(telegram_id, created_at DESC);
CREATE INDEX CONCURRENTLY idx_daily_bonus_user_date ON daily_bonus_entries(telegram_id, claimed_at DESC);
CREATE INDEX CONCURRENTLY idx_task_progress_user_status ON task_progress(telegram_id, status);
CREATE INDEX CONCURRENTLY idx_analytics_events_user_time ON analytics_events(user_id, timestamp DESC);

-- ĞŸĞ°Ñ€Ñ‚Ğ¸Ñ†Ñ–Ğ¾Ğ½ÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ²ĞµĞ»Ğ¸ĞºĞ¸Ñ… Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†ÑŒ
CREATE TABLE analytics_events_y2024 PARTITION OF analytics_events
FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

-- Materialized views Ğ´Ğ»Ñ Ğ°Ğ½Ğ°Ğ»Ñ–Ñ‚Ğ¸ĞºĞ¸
CREATE MATERIALIZED VIEW user_daily_stats AS
SELECT
    telegram_id,
    DATE(created_at) as date,
    COUNT(*) as events_count,
    SUM(CASE WHEN event_type = 'daily' THEN 1 ELSE 0 END) as daily_claims
FROM analytics_events
GROUP BY telegram_id, DATE(created_at);

-- ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡Ğ½Ğµ Ğ¾Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ materialized views
CREATE OR REPLACE FUNCTION refresh_materialized_views()
RETURNS void AS $
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY user_daily_stats;
END;
$ LANGUAGE plpgsql;

-- Cronjob Ğ´Ğ»Ñ Ğ¾Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ½Ñ ĞºĞ¾Ğ¶Ğ½Ñ– 15 Ñ…Ğ²Ğ¸Ğ»Ğ¸Ğ½
SELECT cron.schedule('refresh-stats', '*/15 * * * *', 'SELECT refresh_materialized_views();');
```

### **Cache Warming Strategy**
```python
# cache_warming.py
async def warm_critical_caches():
    """ĞŸĞ¾Ğ¿ĞµÑ€ĞµĞ´Ğ½Ñ” Ğ·Ğ°Ğ²Ğ°Ğ½Ñ‚Ğ°Ğ¶ĞµĞ½Ğ½Ñ ĞºÑ€Ğ¸Ñ‚Ğ¸Ñ‡Ğ½Ğ¸Ñ… ĞºĞµÑˆÑ–Ğ²"""

    # Ğ¢Ğ¾Ğ¿-100 Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ğ¸Ñ… ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ñ–Ğ²
    active_users = await get_most_active_users(limit=100)

    for user in active_users:
        # Ğ—Ğ°Ğ²Ğ°Ğ½Ñ‚Ğ°Ğ¶ĞµĞ½Ğ½Ñ Ğ¾ÑĞ½Ğ¾Ğ²Ğ½Ğ¸Ñ… Ğ´Ğ°Ğ½Ğ¸Ñ… Ğ² ĞºĞµÑˆ
        asyncio.create_task(cache_user_data(user['telegram_id']))
        asyncio.create_task(cache_daily_status(user['telegram_id']))
        asyncio.create_task(cache_task_progress(user['telegram_id']))

        await asyncio.sleep(0.1)  # Throttling

async def cache_user_data(telegram_id: str):
    """ĞšĞµÑˆÑƒĞ²Ğ°Ğ½Ğ½Ñ Ğ´Ğ°Ğ½Ğ¸Ñ… ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ğ°"""
    user = get_user(telegram_id)
    if user:
        cache_manager.set(f"user:{telegram_id}", user, ttl=300)

# Ğ—Ğ°Ğ¿ÑƒÑĞº cache warming Ğ¿Ñ€Ğ¸ ÑÑ‚Ğ°Ñ€Ñ‚Ñ– Ğ´Ğ¾Ğ´Ğ°Ñ‚ĞºÑƒ
@app.before_first_request
def setup_cache_warming():
    asyncio.create_task(warm_critical_caches())
```

---

## ğŸ”§ Maintenance & Operations

### **Database Maintenance Scripts**
```python
# maintenance/db_cleanup.py
async def cleanup_old_data():
    """ĞÑ‡Ğ¸Ñ‰ĞµĞ½Ğ½Ñ Ğ·Ğ°ÑÑ‚Ğ°Ñ€Ñ–Ğ»Ğ¸Ñ… Ğ´Ğ°Ğ½Ğ¸Ñ…"""

    # Ğ’Ğ¸Ğ´Ğ°Ğ»ĞµĞ½Ğ½Ñ ÑÑ‚Ğ°Ñ€Ğ¸Ñ… analytics events (ÑÑ‚Ğ°Ñ€ÑˆĞµ 90 Ğ´Ğ½Ñ–Ğ²)
    cutoff_date = datetime.now() - timedelta(days=90)

    deleted_count = supabase.table('analytics_events')\
        .delete()\
        .lt('timestamp', cutoff_date.isoformat())\
        .execute()

    logger.info(f"Cleaned up {len(deleted_count.data)} old analytics events")

    # ĞÑ€Ñ…Ñ–Ğ²ÑƒĞ²Ğ°Ğ½Ğ½Ñ ÑÑ‚Ğ°Ñ€Ğ¸Ñ… Ñ‚Ñ€Ğ°Ğ½Ğ·Ğ°ĞºÑ†Ñ–Ğ¹
    await archive_old_transactions(cutoff_date)

    # ĞÑ‡Ğ¸Ñ‰ĞµĞ½Ğ½Ñ expired rate limit entries
    cache_manager.clear_pattern("rate_limit:*")

async def optimize_database():
    """ĞĞ¿Ñ‚Ğ¸Ğ¼Ñ–Ğ·Ğ°Ñ†Ñ–Ñ Ğ±Ğ°Ğ·Ğ¸ Ğ´Ğ°Ğ½Ğ¸Ñ…"""

    # Vacuum Ñ‚Ğ° reindex
    maintenance_queries = [
        "VACUUM ANALYZE winix;",
        "VACUUM ANALYZE transactions;",
        "VACUUM ANALYZE analytics_events;",
        "REINDEX TABLE CONCURRENTLY winix;",
        "UPDATE pg_stat_statements SET calls = 0, total_time = 0;"
    ]

    for query in maintenance_queries:
        try:
            await execute_maintenance_query(query)
            logger.info(f"Executed: {query}")
        except Exception as e:
            logger.error(f"Failed to execute {query}: {e}")

# Cron jobs
# 0 2 * * * python maintenance/db_cleanup.py
# 0 3 * * 0 python maintenance/db_optimize.py
```

### **Health Monitoring & Alerting**
```python
# monitoring/health_checks.py
class HealthMonitor:
    def __init__(self):
        self.checks = {
            'database': self.check_database,
            'redis': self.check_redis,
            'external_apis': self.check_external_apis,
            'disk_space': self.check_disk_space,
            'memory_usage': self.check_memory_usage
        }

    async def run_all_checks(self) -> Dict[str, Any]:
        """Ğ’Ğ¸ĞºĞ¾Ğ½Ğ°Ğ½Ğ½Ñ Ğ²ÑÑ–Ñ… health checks"""
        results = {}

        for name, check_func in self.checks.items():
            try:
                start_time = time.time()
                result = await check_func()
                duration = time.time() - start_time

                results[name] = {
                    'status': 'healthy' if result else 'unhealthy',
                    'duration': duration,
                    'timestamp': time.time()
                }
            except Exception as e:
                results[name] = {
                    'status': 'error',
                    'error': str(e),
                    'timestamp': time.time()
                }

        return results

    async def check_database(self) -> bool:
        """ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° ÑÑ‚Ğ°Ğ½Ñƒ Ğ±Ğ°Ğ·Ğ¸ Ğ´Ğ°Ğ½Ğ¸Ñ…"""
        try:
            result = supabase.table('winix').select('id').limit(1).execute()
            return len(result.data) >= 0
        except:
            return False

    async def check_external_apis(self) -> bool:
        """ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ·Ğ¾Ğ²Ğ½Ñ–ÑˆĞ½Ñ–Ñ… API"""
        try:
            telegram_ok = await telegram_service.health_check()
            ton_ok = await ton_connect_service.health_check()
            return telegram_ok and ton_ok
        except:
            return False

    def check_disk_space(self) -> bool:
        """ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ¼Ñ–ÑÑ†Ñ Ğ½Ğ° Ğ´Ğ¸ÑĞºÑƒ"""
        disk_usage = psutil.disk_usage('/')
        return disk_usage.percent < 90  # Alert if > 90%

    def check_memory_usage(self) -> bool:
        """ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° Ğ²Ğ¸ĞºĞ¾Ñ€Ğ¸ÑÑ‚Ğ°Ğ½Ğ½Ñ Ğ¿Ğ°Ğ¼'ÑÑ‚Ñ–"""
        memory = psutil.virtual_memory()
        return memory.percent < 85  # Alert if > 85%

# Automated alerting
async def monitor_and_alert():
    """ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡Ğ½Ğ¸Ğ¹ Ğ¼Ğ¾Ğ½Ñ–Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³ Ğ· Ğ°Ğ»ĞµÑ€Ñ‚Ğ°Ğ¼Ğ¸"""
    health_monitor = HealthMonitor()

    while True:
        try:
            health_results = await health_monitor.run_all_checks()

            # ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° ĞºÑ€Ğ¸Ñ‚Ğ¸Ñ‡Ğ½Ğ¸Ñ… Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼
            critical_issues = [
                name for name, result in health_results.items()
                if result['status'] in ['unhealthy', 'error']
            ]

            if critical_issues:
                await send_critical_alert(critical_issues, health_results)

            # Ğ›Ğ¾Ğ³ÑƒĞ²Ğ°Ğ½Ğ½Ñ ÑÑ‚Ğ°Ğ½Ñƒ
            logger.info("Health check completed", extra={
                'healthy_services': len([r for r in health_results.values() if r['status'] == 'healthy']),
                'total_services': len(health_results),
                'critical_issues': critical_issues
            })

        except Exception as e:
            logger.error(f"Health monitoring error: {e}")

        await asyncio.sleep(60)  # ĞŸĞµÑ€ĞµĞ²Ñ–Ñ€ĞºĞ° ĞºĞ¾Ğ¶Ğ½Ñƒ Ñ…Ğ²Ğ¸Ğ»Ğ¸Ğ½Ñƒ

async def send_critical_alert(issues: List[str], health_data: Dict):
    """Ğ’Ñ–Ğ´Ğ¿Ñ€Ğ°Ğ²ĞºĞ° ĞºÑ€Ğ¸Ñ‚Ğ¸Ñ‡Ğ½Ğ¾Ğ³Ğ¾ Ğ°Ğ»ĞµÑ€Ñ‚Ñƒ"""
    alert_data = {
        'severity': 'critical',
        'service': 'winix-backend',
        'issues': issues,
        'timestamp': time.time(),
        'health_data': health_data
    }

    # Ğ’Ñ–Ğ´Ğ¿Ñ€Ğ°Ğ²ĞºĞ° Ğ² Slack/Discord/Email
    webhook_url = os.getenv('ALERT_WEBHOOK_URL')
    if webhook_url:
        async with aiohttp.ClientSession() as session:
            await session.post(webhook_url, json=alert_data)
```

---

## ğŸ“Š Analytics & Business Intelligence

### **Advanced Analytics Models**
```python
# analytics/business_intelligence.py
class BusinessIntelligence:
    """Ğ Ğ¾Ğ·ÑˆĞ¸Ñ€ĞµĞ½Ğ° Ğ±Ñ–Ğ·Ğ½ĞµÑ-Ğ°Ğ½Ğ°Ğ»Ñ–Ñ‚Ğ¸ĞºĞ°"""

    def __init__(self):
        self.db = supabase_client

    async def get_user_engagement_metrics(self, days: int = 30) -> Dict:
        """ĞœĞµÑ‚Ñ€Ğ¸ĞºĞ¸ Ğ·Ğ°Ğ»ÑƒÑ‡ĞµĞ½Ğ¾ÑÑ‚Ñ– ĞºĞ¾Ñ€Ğ¸ÑÑ‚ÑƒĞ²Ğ°Ñ‡Ñ–Ğ²"""

        # Daily Active Users (DAU)
        dau_query = """
        SELECT DATE(timestamp) as date, COUNT(DISTINCT user_id) as dau
        FROM analytics_events
        WHERE timestamp >= NOW() - INTERVAL '%s days'
        GROUP BY DATE(timestamp)
        ORDER BY date DESC
        """ % days

        # Retention analysis
        retention_query = """
        WITH first_login AS (
            SELECT user_id, MIN(DATE(timestamp)) as first_date
            FROM analytics_events
            WHERE event_type = 'auth'
            GROUP BY user_id
        ),
        user_activity AS (
            SELECT
                fl.user_id,
                fl.first_date,
                DATE(ae.timestamp) as activity_date,
                DATE(ae.timestamp) - fl.first_date as days_since_first
            FROM first_login fl
            JOIN analytics_events ae ON fl.user_id = ae.user_id
            WHERE ae.timestamp >= NOW() - INTERVAL '%s days'
        )
        SELECT
            days_since_first,
            COUNT(DISTINCT user_id) as retained_users
        FROM user_activity
        WHERE days_since_first IN (1, 7, 14, 30)
        GROUP BY days_since_first
        ORDER BY days_since_first
        """ % days

        return {
            'dau': await self._execute_query(dau_query),
            'retention': await self._execute_query(retention_query)
        }

    async def get_revenue_analytics(self) -> Dict:
        """ĞĞ½Ğ°Ğ»Ñ–Ñ‚Ğ¸ĞºĞ° 'Ğ´Ğ¾Ñ…Ğ¾Ğ´Ñ–Ğ²' (Ğ²Ñ–Ñ€Ñ‚ÑƒĞ°Ğ»ÑŒĞ½Ğ¸Ñ… Ğ²Ğ¸Ğ½Ğ°Ğ³Ğ¾Ñ€Ğ¾Ğ´)"""

        revenue_query = """
        SELECT
            DATE(created_at) as date,
            transaction_type,
            SUM(winix_amount) as total_winix,
            SUM(tickets_amount) as total_tickets,
            COUNT(*) as transaction_count
        FROM transactions
        WHERE created_at >= NOW() - INTERVAL '30 days'
            AND winix_amount > 0
        GROUP BY DATE(created_at), transaction_type
        ORDER BY date DESC, transaction_type
        """

        top_earners_query = """
        SELECT
            telegram_id,
            SUM(winix_amount) as total_earned,
            COUNT(*) as transactions_count
        FROM transactions
        WHERE created_at >= NOW() - INTERVAL '30 days'
            AND winix_amount > 0
        GROUP BY telegram_id
        ORDER BY total_earned DESC
        LIMIT 50
        """

        return {
            'daily_revenue': await self._execute_query(revenue_query),
            'top_earners': await self._execute_query(top_earners_query)
        }

    async def get_task_performance_analytics(self) -> Dict:
        """ĞĞ½Ğ°Ğ»Ñ–Ñ‚Ğ¸ĞºĞ° Ğ¿Ñ€Ğ¾Ğ´ÑƒĞºÑ‚Ğ¸Ğ²Ğ½Ğ¾ÑÑ‚Ñ– Ğ·Ğ°Ğ²Ğ´Ğ°Ğ½ÑŒ"""

        task_completion_query = """
        SELECT
            task_type,
            COUNT(*) as total_attempts,
            SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as completed,
            AVG(CASE WHEN status = 'completed' THEN
                EXTRACT(EPOCH FROM (updated_at - created_at))/60
                ELSE NULL END) as avg_completion_time_minutes
        FROM task_progress
        WHERE created_at >= NOW() - INTERVAL '30 days'
        GROUP BY task_type
        ORDER BY total_attempts DESC
        """

        funnel_analysis_query = """
        WITH task_funnel AS (
            SELECT
                task_id,
                COUNT(CASE WHEN status = 'started' THEN 1 END) as started,
                COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed,
                COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed
            FROM task_progress
            WHERE created_at >= NOW() - INTERVAL '30 days'
            GROUP BY task_id
        )
        SELECT
            task_id,
            started,
            completed,
            failed,
            CASE WHEN started > 0 THEN
                ROUND((completed::FLOAT / started) * 100, 2)
                ELSE 0 END as completion_rate
        FROM task_funnel
        WHERE started > 10  -- Only tasks with significant attempts
        ORDER BY completion_rate DESC
        """

        return {
            'task_performance': await self._execute_query(task_completion_query),
            'conversion_funnel': await self._execute_query(funnel_analysis_query)
        }

# Automated reporting
async def generate_daily_report():
    """Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ñ–Ñ Ñ‰Ğ¾Ğ´ĞµĞ½Ğ½Ğ¾Ğ³Ğ¾ Ğ·Ğ²Ñ–Ñ‚Ñƒ"""
    bi = BusinessIntelligence()

    report_data = {
        'date': datetime.now().isoformat(),
        'engagement': await bi.get_user_engagement_metrics(7),
        'revenue': await bi.get_revenue_analytics(),
        'tasks': await bi.get_task_performance_analytics()
    }

    # Ğ—Ğ±ĞµÑ€ĞµĞ¶ĞµĞ½Ğ½Ñ Ğ·Ğ²Ñ–Ñ‚Ñƒ
    report_filename = f"reports/daily_report_{datetime.now().strftime('%Y%m%d')}.json"

    with open(report_filename, 'w') as f:
        json.dump(report_data, f, indent=2, default=str)

    logger.info(f"Daily report generated: {report_filename}")

    return report_data

# Cron job: 0 9 * * * python analytics/generate_reports.py
```

---

Ğ¦Ñ Ğ¿Ğ¾Ğ²Ğ½Ğ° Ğ°Ñ€Ñ…Ñ–Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ½Ğ° Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°Ñ†Ñ–Ñ Ğ½Ğ°Ğ´Ğ°Ñ” Ğ´ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ğ¸Ğ¹ Ğ¾Ğ³Ğ»ÑĞ´ ĞºĞ¾Ğ¶Ğ½Ğ¾Ğ³Ğ¾ ĞºĞ¾Ğ¼Ğ¿Ğ¾Ğ½ĞµĞ½Ñ‚Ğ° backend ÑĞ¸ÑÑ‚ĞµĞ¼Ğ¸ WINIX, Ğ²ĞºĞ»ÑÑ‡Ğ°ÑÑ‡Ğ¸ Ğ²Ğ·Ğ°Ñ”Ğ¼Ğ¾Ğ´Ñ–Ñ—, security patterns, deployment ÑÑ‚Ñ€Ğ°Ñ‚ĞµĞ³Ñ–Ñ—, Ğ¼Ğ¾Ğ½Ñ–Ñ‚Ğ¾Ñ€Ğ¸Ğ½Ğ³ Ñ‚Ğ° Ğ±Ñ–Ğ·Ğ½ĞµÑ-Ğ°Ğ½Ğ°Ğ»Ñ–Ñ‚Ğ¸ĞºÑƒ. Ğ¡Ğ¸ÑÑ‚ĞµĞ¼Ğ° Ğ¿Ğ¾Ğ±ÑƒĞ´Ğ¾Ğ²Ğ°Ğ½Ğ° Ğ· ÑƒÑ€Ğ°Ñ…ÑƒĞ²Ğ°Ğ½Ğ½ÑĞ¼ Ğ¼Ğ°ÑÑˆÑ‚Ğ°Ğ±Ğ¾Ğ²Ğ°Ğ½Ğ¾ÑÑ‚Ñ–, Ğ½Ğ°Ğ´Ñ–Ğ¹Ğ½Ğ¾ÑÑ‚Ñ– Ñ‚Ğ° Ğ¿Ñ–Ğ´Ñ‚Ñ€Ğ¸Ğ¼ÑƒĞ²Ğ°Ğ½Ğ¾ÑÑ‚Ñ–! ğŸš€