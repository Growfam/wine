# 🏗️ WINIX Backend - Детальна архітектура системи завдань

## 📋 Загальна схема архітектури

```
┌─────────────────────────────────────────────────────────────────┐
│                        CLIENT LAYER                             │
│     (Web App, Mobile App, Desktop App, Telegram Bot)           │
└─────────────────────────────────┬───────────────────────────────┘
                                  │ HTTP/HTTPS, WebSocket
┌─────────────────────────────────▼───────────────────────────────┐
│                      API GATEWAY                                │
│                    (Flask Application)                          │
│                       main.py                                   │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐               │
│  │   Logger    │ │Rate Limiter │ │  Security   │               │
│  │ Middleware  │ │ Middleware  │ │ Middleware  │               │
│  └─────────────┘ └─────────────┘ └─────────────┘               │
└─────────────────────────────────┬───────────────────────────────┘
                                  │
┌─────────────────────────────────▼───────────────────────────────┐
│                  WINIX QUESTS SYSTEM                            │
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐   │
│  │    ROUTES       │ │  CONTROLLERS    │ │    SERVICES     │   │
│  │                 │ │                 │ │                 │   │
│  │  API Endpoints  │ │ Business Logic  │ │  Core Services  │   │
│  └─────────────────┘ └─────────────────┘ └─────────────────┘   │
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐   │
│  │     MODELS      │ │     UTILS       │ │    VALIDATORS   │   │
│  │                 │ │                 │ │                 │   │
│  │  Data Models    │ │   Helpers       │ │   Validation    │   │
│  └─────────────────┘ └─────────────────┘ └─────────────────┘   │
└─────────────────────────────────┬───────────────────────────────┘
                                  │
┌─────────────────────────────────▼───────────────────────────────┐
│                    DATABASE LAYER                               │
│                  (Supabase Client)                              │
│              supabase_client.py                                 │
└─────────────────────────────────┬───────────────────────────────┘
                                  │
┌─────────────────────────────────▼───────────────────────────────┐
│                  EXTERNAL SERVICES                              │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐               │
│  │  Supabase   │ │  Telegram   │ │    TON      │               │
│  │  Database   │ │  Bot API    │ │ Blockchain  │               │
│  └─────────────┘ └─────────────┘ └─────────────┘               │
└─────────────────────────────────────────────────────────────────┘
```

## 🎯 Архітектурні шари та їх взаємодії

### 1. **ROUTES LAYER** - HTTP API Endpoints
```
┌─────────────────────────────────────────────────────────────┐
│                    ROUTES LAYER                             │
│                                                             │
│ auth_routes.py     → Авторизація та JWT токени             │
│ user_routes.py     → Управління користувачами              │
│ daily_routes.py    → Щоденні бонуси                        │
│ flex_routes.py     → FLEX токени та винагороди              │
│ tasks_routes.py    → Система завдань                        │
│ wallet_routes.py   → TON гаманці                           │
│ transaction_routes.py → Фінансові операції                 │
│ analytics_routes.py → Аналітика та метрики                 │
│                                                             │
│ Відповідальність:                                          │
│ • HTTP запити/відповіді                                    │
│ • Валідація вхідних даних                                  │
│ • Rate limiting                                            │
│ • Security декоратори                                      │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                 CONTROLLERS LAYER                           │
└─────────────────────────────────────────────────────────────┘
```

### 2. **CONTROLLERS LAYER** - Бізнес-логіка координація
```
┌─────────────────────────────────────────────────────────────┐
│                CONTROLLERS LAYER                            │
│                                                             │
│ AuthController        → Telegram WebApp валідація          │
│ UserController        → Профілі та баланси                 │
│ DailyController       → Щоденні бонуси + Transaction Srv   │
│ FlexController        → FLEX винагороди + TON інтеграція   │
│ TasksController       → Завдання + верифікація             │
│ WalletController      → TON гаманці + бонуси               │
│ TransactionController → Централізовані фінанси             │
│ AnalyticsController   → Аналітичні події                  │
│                                                             │
│ Паттерн взаємодії:                                         │
│ Controller → Services → Models → Database                  │
│ Controller → Analytics (async logging)                     │
│ Controller → Transaction Service (atomic operations)       │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                  SERVICES LAYER                             │
└─────────────────────────────────────────────────────────────┘
```

### 3. **SERVICES LAYER** - Domain Services
```
┌─────────────────────────────────────────────────────────────┐
│                    SERVICES LAYER                           │
│                                                             │
│ RewardCalculator     → Розрахунки винагород               │
│ TelegramService      → Telegram Bot API інтеграція        │
│ TONConnectService    → TON Blockchain інтеграція          │
│ TransactionService   → Атомарні фінансові операції        │
│ VerificationService  → Верифікація соціальних завдань     │
│                                                             │
│ Ключові особливості:                                       │
│ • Асинхронна обробка                                       │
│ • Retry логіка для зовнішніх API                          │
│ • Кешування результатів                                    │
│ • Fallback механізми                                       │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                   MODELS LAYER                              │
└─────────────────────────────────────────────────────────────┘
```

### 4. **MODELS LAYER** - Data Access
```
┌─────────────────────────────────────────────────────────────┐
│                     MODELS LAYER                            │
│                                                             │
│ UserQuest        → Користувачі, баланси, статуси          │
│ DailyBonus       → Щоденні бонуси, серії                  │
│ FlexRewards      → FLEX токени, рівні винагород           │
│ Task             → Завдання, типи, платформи              │
│ Transaction      → Фінансові операції, історія            │
│ Wallet           → TON гаманці, підключення               │
│ Analytics        → Події, сесії, статистика               │
│                                                             │
│ Data Flow:                                                  │
│ Models ↔ Supabase Client ↔ PostgreSQL Database            │
└─────────────────────────────────────────────────────────────┘
```

## 🔄 Детальні взаємодії між компонентами

### 💰 Transaction Service - Центральний HUB фінансових операцій

```
┌─────────────────────────────────────────────────────────────┐
│              TRANSACTION SERVICE ECOSYSTEM                  │
│                                                             │
│                 ┌─────────────────┐                        │
│                 │ Transaction     │                        │
│                 │ Service         │                        │
│                 │ (Core Hub)      │                        │
│                 └─────────────────┘                        │
│                          │                                  │
│        ┌─────────────────┼─────────────────┐               │
│        │                 │                 │               │
│        ▼                 ▼                 ▼               │
│ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐          │
│ │   Daily     │ │    FLEX     │ │   Tasks     │          │
│ │ Controller  │ │ Controller  │ │ Controller  │          │
│ └─────────────┘ └─────────────┘ └─────────────┘          │
│        │                 │                 │               │
│        ▼                 ▼                 ▼               │
│ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐          │
│ │   Wallet    │ │    User     │ │ Analytics   │          │
│ │ Controller  │ │ Controller  │ │ Events      │          │
│ └─────────────┘ └─────────────┘ └─────────────┘          │
│                                                             │
│ Всі фінансові операції проходять через Transaction Service │
│ Забезпечує: атомарність, аудит, консистентність           │
└─────────────────────────────────────────────────────────────┘
```

### 🎯 Система завдань - Детальний flow

```
1. СТВОРЕННЯ ЗАВДАННЯ (Admin Panel)
┌─────────────────────────────────────────┐
│ TasksController.create_task()           │
│ ↓                                       │
│ TaskModel.create_task()                 │
│ ↓                                       │
│ Supabase: INSERT into tasks            │
│ ↓                                       │
│ Analytics: log_task_created_event()     │
└─────────────────────────────────────────┘

2. ОТРИМАННЯ СПИСКУ ЗАВДАНЬ
┌─────────────────────────────────────────┐
│ GET /api/tasks/list/{telegram_id}       │
│ ↓                                       │
│ TasksController.get_tasks_list()        │
│ ↓                                       │
│ TaskModel.get_available_tasks()         │
│ ↓                                       │
│ UserQuest.get_completed_tasks()         │
│ ↓                                       │
│ Filter + Merge (available - completed)  │
│ ↓                                       │
│ Response: List[TaskWithStatus]          │
└─────────────────────────────────────────┘

3. ПОЧАТОК ВИКОНАННЯ ЗАВДАННЯ
┌─────────────────────────────────────────┐
│ POST /api/tasks/start/{id}/{task_id}    │
│ ↓                                       │
│ TasksController.start_task()            │
│ ↓                                       │
│ Validation: task exists, not completed  │
│ ↓                                       │
│ TaskModel.update_task_progress()        │
│ ↓                                       │
│ VerificationService.schedule_check()    │
│ ↓                                       │
│ Analytics: log_task_started_event()     │
│ ↓                                       │
│ Response: {status: "started", timer: X} │
└─────────────────────────────────────────┘

4. ВЕРИФІКАЦІЯ ЗАВДАННЯ
┌─────────────────────────────────────────┐
│ POST /api/tasks/verify/{id}/{task_id}   │
│ ↓                                       │
│ TasksController.verify_task()           │
│ ↓                                       │
│ VerificationService.verify_completion() │
│ ├─ Telegram: check_subscription()       │
│ ├─ YouTube: check_subscription()        │
│ ├─ Twitter: check_follow()              │
│ └─ Discord: check_membership()          │
│ ↓                                       │
│ IF verified = True:                     │
│   ├─ TaskModel.mark_completed()         │
│   ├─ TransactionService.process_reward()│
│   └─ Analytics: log_task_completed()    │
│ ELSE:                                   │
│   └─ Return verification_failed         │
│ ↓                                       │
│ Response: {verified, reward_given}      │
└─────────────────────────────────────────┘
```

### 🎁 Щоденні бонуси - Повний lifecycle

```
1. ПЕРЕВІРКА СТАТУСУ
┌─────────────────────────────────────────┐
│ GET /api/daily/status/{telegram_id}     │
│ ↓                                       │
│ DailyController.get_daily_status()      │
│ ↓                                       │
│ DailyBonusManager.get_user_status()     │
│ ↓                                       │
│ Calculate: can_claim, next_claim_time   │
│ ↓                                       │
│ RewardCalculator.preview_reward()       │
│ ↓                                       │
│ Response: {                             │
│   current_day: 5,                       │
│   current_streak: 5,                    │
│   can_claim: true,                      │
│   next_reward: {winix: 20, tickets: 0}, │
│   time_until_next: 0                    │
│ }                                       │
└─────────────────────────────────────────┘

2. ОТРИМАННЯ БОНУСУ
┌─────────────────────────────────────────┐
│ POST /api/daily/claim/{telegram_id}     │
│ ↓                                       │
│ DailyController.claim_daily_bonus()     │
│ ↓                                       │
│ Validation:                             │
│ ├─ User exists                          │
│ ├─ Can claim (20+ hours passed)         │
│ └─ Not already claimed today            │
│ ↓                                       │
│ RewardCalculator.calculate_reward()     │
│ ├─ Base reward: 20 WINIX                │
│ ├─ Day multipliers (7,14,21,30)         │
│ ├─ Streak bonuses                       │
│ └─ Special day tickets                  │
│ ↓                                       │
│ TransactionService.process_daily_bonus()│
│ ├─ Create transaction record            │
│ ├─ Update user balance (atomic)         │
│ ├─ Update daily_bonus_status            │
│ └─ Create daily_bonus_entry             │
│ ↓                                       │
│ Analytics.log_daily_bonus_claimed()     │
│ ↓                                       │
│ Response: {                             │
│   success: true,                        │
│   reward: {winix: 40, tickets: 1},      │
│   new_balance: {winix: 1250, ...},      │
│   next_claim_in: "20:15:30"             │
│ }                                       │
└─────────────────────────────────────────┘

3. РОЗРАХУНОК ВИНАГОРОД (RewardCalculator)
┌─────────────────────────────────────────┐
│ calculate_daily_bonus(day, streak, lvl) │
│ ↓                                       │
│ Base calculation:                       │
│ ├─ base_winix = 20                      │
│ ├─ tickets = 0                          │
│ └─ multiplier = 1.0                     │
│ ↓                                       │
│ Apply day-specific rules:               │
│ ├─ Day 7:  multiplier = 2.0, +1 ticket │
│ ├─ Day 14: multiplier = 2.5, +2 tickets│
│ ├─ Day 21: multiplier = 3.0, +3 tickets│
│ └─ Day 30: multiplier = 5.0, +10 tickets│
│ ↓                                       │
│ Apply streak bonus:                     │
│ ├─ 7+ days:  +10% WINIX                 │
│ ├─ 14+ days: +20% WINIX                 │
│ └─ 21+ days: +30% WINIX                 │
│ ↓                                       │
│ Apply user level bonus:                 │
│ └─ level > 1: +5% per level             │
│ ↓                                       │
│ Return: Reward(winix, tickets)          │
└─────────────────────────────────────────┘
```

### 💎 FLEX Система - TON Blockchain інтеграція

```
1. ПЕРЕВІРКА FLEX БАЛАНСУ
┌─────────────────────────────────────────┐
│ GET /api/flex/balance/{telegram_id}     │
│ ↓                                       │
│ FlexController.get_flex_balance()       │
│ ↓                                       │
│ UserQuest.get_wallet_address()          │
│ ↓                                       │
│ IF wallet_connected:                    │
│   ├─ TONConnectService.get_balance()    │
│   ├─ Cache: 5 min TTL                   │
│   └─ FlexRewards.update_balance()       │
│ ELSE:                                   │
│   └─ Return: wallet_not_connected       │
│ ↓                                       │
│ FlexRewards.calculate_available_levels()│
│ ↓                                       │
│ Response: {                             │
│   flex_balance: 75000,                  │
│   available_levels: ["Bronze","Silver"],│
│   can_claim: {                          │
│     "Bronze": true,                     │
│     "Silver": false                     │
│   }                                     │
│ }                                       │
└─────────────────────────────────────────┘

2. ОТРИМАННЯ FLEX ВИНАГОРОДИ
┌─────────────────────────────────────────┐
│ POST /api/flex/claim/{telegram_id}      │
│ Body: {level: "Silver"}                 │
│ ↓                                       │
│ FlexController.claim_flex_reward()      │
│ ↓                                       │
│ Validation:                             │
│ ├─ Level exists in config               │
│ ├─ User has enough FLEX                 │
│ ├─ Cooldown expired (24h)               │
│ └─ Not already claimed for this level   │
│ ↓                                       │
│ TONConnectService.verify_balance()      │
│ ├─ Real-time blockchain check           │
│ └─ Confirm sufficient FLEX              │
│ ↓                                       │
│ FlexRewards.get_level_config()          │
│ ├─ Silver: 50,000 FLEX required         │
│ └─ Reward: 75 WINIX + 2 tickets         │
│ ↓                                       │
│ TransactionService.process_flex_reward()│
│ ├─ Create FLEX transaction              │
│ ├─ Update balances                      │
│ └─ Set cooldown timer                   │
│ ↓                                       │
│ FlexRewards.log_claim()                 │
│ ↓                                       │
│ Analytics.log_flex_claim_event()        │
│ ↓                                       │
│ Response: {                             │
│   claimed: true,                        │
│   level: "Silver",                      │
│   reward: {winix: 75, tickets: 2},      │
│   next_claim_in: "23:59:45"             │
│ }                                       │
└─────────────────────────────────────────┘

3. FLEX РІВНІ КОНФІГУРАЦІЯ
┌─────────────────────────────────────────┐
│ FLEX_LEVELS_CONFIG = {                  │
│   "Bronze": {                           │
│     required_flex: 10000,               │
│     reward_winix: 25,                   │
│     reward_tickets: 1                   │
│   },                                    │
│   "Silver": {                           │
│     required_flex: 50000,               │
│     reward_winix: 75,                   │
│     reward_tickets: 2                   │
│   },                                    │
│   "Gold": {                             │
│     required_flex: 100000,              │
│     reward_winix: 150,                  │
│     reward_tickets: 4                   │
│   },                                    │
│   "Platinum": {                         │
│     required_flex: 250000,              │
│     reward_winix: 300,                  │
│     reward_tickets: 8                   │
│   },                                    │
│   "Diamond": {                          │
│     required_flex: 500000,              │
│     reward_winix: 500,                  │
│     reward_tickets: 15                  │
│   }                                     │
│ }                                       │
└─────────────────────────────────────────┘
```

### 💼 TON Wallet Integration

```
1. ПІДКЛЮЧЕННЯ ГАМАНЦЯ
┌─────────────────────────────────────────┐
│ POST /api/wallet/connect/{telegram_id}  │
│ Body: {                                 │
│   address: "EQD...",                    │
│   provider: "TonKeeper",                │
│   signature: "..."                      │
│ }                                       │
│ ↓                                       │
│ WalletController.connect_wallet()       │
│ ↓                                       │
│ Validation:                             │
│ ├─ TONConnectService.validate_address() │
│ ├─ Signature verification               │
│ └─ Provider compatibility check         │
│ ↓                                       │
│ WalletModel.create_connection()         │
│ ├─ Save wallet info                     │
│ ├─ Set status: connected                │
│ └─ Record connection time               │
│ ↓                                       │
│ Check: first_connection_bonus           │
│ IF first_time:                          │
│   ├─ TransactionService.process_bonus() │
│   └─ Reward: 100 WINIX + 5 tickets      │
│ ↓                                       │
│ TONConnectService.start_monitoring()    │
│ ├─ Periodic balance checks              │
│ └─ Transaction monitoring               │
│ ↓                                       │
│ Analytics.log_wallet_connected()        │
│ ↓                                       │
│ Response: {                             │
│   connected: true,                      │
│   address: "EQD...",                    │
│   bonus_received: true,                 │
│   ton_balance: 1.5,                     │
│   flex_balance: 25000                   │
│ }                                       │
└─────────────────────────────────────────┘

2. МОНІТОРИНГ БАЛАНСІВ
┌─────────────────────────────────────────┐
│ TONConnectService Background Process    │
│ ↓                                       │
│ Every 5 minutes:                        │
│ ├─ Get all connected wallets            │
│ ├─ Fetch TON balance                    │
│ ├─ Fetch FLEX balance                   │
│ └─ Update cache                         │
│ ↓                                       │
│ Cache strategy:                         │
│ ├─ Memory: 1 min TTL                    │
│ ├─ Redis: 5 min TTL                     │
│ └─ Database: 30 min update              │
│ ↓                                       │
│ On significant balance change:          │
│ ├─ Trigger FLEX level recalculation     │
│ ├─ Send notification (if enabled)       │
│ └─ Log analytics event                  │
└─────────────────────────────────────────┘
```

## 🔐 Security & Authentication Layer

### JWT Authentication Flow
```
1. TELEGRAM WEBAPP AUTHENTICATION
┌─────────────────────────────────────────┐
│ Frontend: Telegram WebApp               │
│ ↓                                       │
│ initData = Telegram.WebApp.initData     │
│ ↓                                       │
│ POST /api/auth/validate-telegram        │
│ Body: {initData: "query_string..."}     │
│ ↓                                       │
│ AuthController.validate_telegram()      │
│ ↓                                       │
│ TelegramService.validate_webapp_data()  │
│ ├─ Parse query string                   │
│ ├─ Verify HMAC-SHA256 signature         │
│ ├─ Check timestamp (not older than 24h) │
│ └─ Validate bot token                   │
│ ↓                                       │
│ UserQuest.get_or_create_user()          │
│ ├─ Get existing user OR                 │
│ └─ Create new user with referral        │
│ ↓                                       │
│ JWT.generate_token()                    │
│ ├─ Payload: {user_id, telegram_id, exp} │
│ ├─ Sign with SECRET_KEY                 │
│ └─ Set expiration: 7 days               │
│ ↓                                       │
│ Analytics.log_auth_success()            │
│ ↓                                       │
│ Response: {                             │
│   token: "eyJ0eXAiOiJKV1QiLCJhbGciOiJS│
│   user: {id, username, balance, ...},   │
│   expires_in: 604800                    │
│ }                                       │
└─────────────────────────────────────────┘

2. REQUEST AUTHORIZATION
┌─────────────────────────────────────────┐
│ Frontend: API Request                   │
│ Header: Authorization: Bearer {token}   │
│ ↓                                       │
│ @require_auth decorator                 │
│ ↓                                       │
│ JWT.decode_token()                      │
│ ├─ Verify signature                     │
│ ├─ Check expiration                     │
│ └─ Extract user data                    │
│ ↓                                       │
│ Rate Limiting Check:                    │
│ ├─ IP-based: 100 req/min               │
│ ├─ User-based: 50 req/min               │
│ └─ Endpoint-based: varies               │
│ ↓                                       │
│ Security Validations:                   │
│ ├─ @validate_telegram_id                │
│ ├─ @validate_json                       │
│ └─ @security_headers                    │
│ ↓                                       │
│ Controller function execution           │
└─────────────────────────────────────────┘
```

## 📊 Analytics & Monitoring System

### Event Tracking Architecture
```
┌─────────────────────────────────────────┐
│           ANALYTICS ECOSYSTEM           │
│                                         │
│ ┌─────────────────┐ ┌─────────────────┐ │
│ │ Analytics       │ │ Metrics         │ │
│ │ Events          │ │ Collector       │ │
│ │                 │ │                 │ │
│ │ • User actions  │ │ • Performance   │ │
│ │ • System events │ │ • Health checks │ │
│ │ • Error logs    │ │ • Usage stats   │ │
│ └─────────────────┘ └─────────────────┘ │
│          │                   │          │
│          ▼                   ▼          │
│ ┌─────────────────────────────────────┐ │
│ │        Analytics Database           │ │
│ │                                     │ │
│ │ • analytics_events                  │ │
│ │ • user_analytics_stats              │ │
│ │ • user_sessions                     │ │
│ │ • system_metrics                    │ │
│ └─────────────────────────────────────┘ │
│                    │                    │
│                    ▼                    │
│ ┌─────────────────────────────────────┐ │
│ │      Monitoring Dashboard           │ │
│ │                                     │ │
│ │ • Real-time metrics                 │ │
│ │ • Alerts and notifications          │ │
│ │ • Performance analytics             │ │
│ │ • User behavior insights            │ │
│ └─────────────────────────────────────┘ │
└─────────────────────────────────────────┘

Event Types:
• AUTH: login, logout, token_refresh
• TASK: started, completed, failed
• DAILY: claimed, missed, streak_broken
• FLEX: claimed, level_up, balance_updated
• WALLET: connected, disconnected, verified
• TRANSACTION: created, failed, reversed
• SYSTEM: error, warning, info, debug
```

## 🔄 Data Flow Patterns

### Complete User Journey Example

```
🌟 НОВИЙ КОРИСТУВАЧ - ПОВНИЙ JOURNEY

1. ПЕРШИЙ ВХІД
┌─────────────────────────────────────────┐
│ User clicks Telegram mini-app           │
│ ↓                                       │
│ TelegramWebApp.initData generated       │
│ ↓                                       │
│ POST /api/auth/validate-telegram        │
│ ↓                                       │
│ AuthController validates + creates user │
│ ↓                                       │
│ UserQuest.create_user() + referral      │
│ ↓                                       │
│ TransactionService.welcome_bonus()      │
│ ↓                                       │
│ Analytics.log_new_user_event()          │
│ ↓                                       │
│ JWT token generated                     │
│ ↓                                       │
│ Response: Welcome package               │
└─────────────────────────────────────────┘

2. ПЕРШИЙ ЩОДЕННИЙ БОНУС
┌─────────────────────────────────────────┐
│ GET /api/daily/status/{id}              │
│ ↓                                       │
│ DailyController.get_status()            │
│ ├─ Day 1, Streak 0, Can claim: true     │
│ └─ Preview: 20 WINIX                    │
│ ↓                                       │
│ POST /api/daily/claim/{id}              │
│ ↓                                       │
│ RewardCalculator.calculate()            │
│ ├─ Base: 20 WINIX                       │
│ └─ Total: 20 WINIX                      │
│ ↓                                       │
│ TransactionService.process_daily()      │
│ ├─ Transaction created                  │
│ ├─ Balance: 0 → 20 WINIX                │
│ └─ Daily status updated                 │
│ ↓                                       │
│ Analytics.log_daily_claimed()           │
└─────────────────────────────────────────┘

3. ПЕРШЕ ЗАВДАННЯ
┌─────────────────────────────────────────┐
│ GET /api/tasks/list/{id}                │
│ ↓                                       │
│ TasksController.get_list()              │
│ ├─ Available: Join Telegram Channel     │
│ ├─ Reward: 50 WINIX + 2 tickets         │
│ └─ Type: telegram_subscribe             │
│ ↓                                       │
│ POST /api/tasks/start/{id}/telegram_1   │
│ ↓                                       │
│ TasksController.start_task()            │
│ ├─ Status: in_progress                  │
│ ├─ Started_at: timestamp                │
│ └─ Timer: 30 seconds                    │
│ ↓                                       │
│ User joins channel manually             │
│ ↓                                       │
│ POST /api/tasks/verify/{id}/telegram_1  │
│ ↓                                       │
│ VerificationService.verify()            │
│ ├─ TelegramService.check_subscription() │
│ ├─ Result: VERIFIED                     │
│ └─ Auto-reward trigger                  │
│ ↓                                       │
│ TransactionService.process_task_reward()│
│ ├─ Transaction: +50 WINIX, +2 tickets   │
│ ├─ Balance: 20 → 70 WINIX, 0 → 2 tickets│
│ └─ Task marked completed                │
│ ↓                                       │
│ Analytics.log_task_completed()          │
└─────────────────────────────────────────┘

4. ПІДКЛЮЧЕННЯ TON ГАМАНЦЯ
┌─────────────────────────────────────────┐
│ POST /api/wallet/connect/{id}           │
│ Body: {address: "EQD...", provider}     │
│ ↓                                       │
│ WalletController.connect()              │
│ ├─ TONConnectService.validate()         │
│ ├─ Signature verification               │
│ └─ Address format check                 │
│ ↓                                       │
│ WalletModel.create_connection()         │
│ ├─ Save wallet info                     │
│ └─ Status: connected                    │
│ ↓                                       │
│ Check: first_wallet_bonus               │
│ ├─ TransactionService.wallet_bonus()    │
│ ├─ Reward: 100 WINIX + 5 tickets        │
│ └─ Balance: 70→170 WINIX, 2→7 tickets   │
│ ↓                                       │
│ TONConnectService.get_balances()        │
│ ├─ TON: 1.5                             │
│ └─ FLEX: 75,000                         │
│ ↓                                       │
│ Analytics.log_wallet_connected()        │
└─────────────────────────────────────────┘

5. ПЕРША FLEX ВИНАГОРОДА
┌─────────────────────────────────────────┐
│ GET /api/flex/levels/{id}               │
│ ↓                                       │
│ FlexController.get_levels()             │
│ ├─ Current FLEX: 75,000                 │
│ ├─ Available: Bronze, Silver            │
│ └─ Can claim: Bronze (10K), Silver (50K)│
│ ↓                                       │
│ POST /api/flex/claim/{id}               │
│ Body: {level: "Silver"}                 │
│ ↓                                       │
│ FlexController.claim()                  │
│ ├─ Verify 50K FLEX requirement          │
│ ├─ Check cooldown (24h)                 │
│ └─ Silver reward: 75 WINIX + 2 tickets  │
│ ↓                                       │
│ TransactionService.process_flex()       │
│ ├─ Transaction created                  │
│ └─ Balance: 170→245 WINIX, 7→9 tickets  │
│ ↓                                       │
│ FlexRewards.set_cooldown()              │
│ └─ Next claim in: 24:00:00              │
│ ↓                                       │
│ Analytics.log_flex_claimed()            │
└─────────────────────────────────────────┘

FINAL STATE:
├─ WINIX Balance: 245
├─ Tickets: 9
├─ Completed Tasks: 1
├─ Daily Streak: 1
├─ Wallet Connected: ✅
├─ FLEX Level: Silver
└─ Total Transactions: 4
```

## 🚀 Performance & Scalability

### Caching Strategy
```
┌─────────────────────────────────────────┐
│              CACHING LAYERS             │
│                                         │
│ ┌─────────────────┐ ┌─────────────────┐ │
│ │ Level 1: Memory │ │ Level 2: Redis  │ │
│ │                 │ │                 │ │
│ │ • JWT tokens    │ │ • User sessions │ │
│ │ • Rate limits   │ │ • TON balances  │ │
│ │ • Temp data     │ │ • Task progress │ │
│ │ TTL: 1-5 min    │ │ TTL: 5-60 min   │ │
│ └─────────────────┘ └─────────────────┘ │
│          │                   │          │
│          ▼                   ▼          │
│ ┌─────────────────────────────────────┐ │
│ │        Level 3: Database            │ │
│ │                                     │ │
│ │ • Persistent data                   │ │
│ │ • Historical records                │ │
│ │ • Analytics events                  │ │
│ │ • User profiles                     │ │
│ └─────────────────────────────────────┘ │
│                                         │
│ Cache Invalidation Strategy:            │
│ • User update → Clear user cache        │
│ • Balance change → Clear balance cache  │
│ • Task completion → Clear task cache    │
│ • Daily bonus → Clear daily cache       │
└─────────────────────────────────────────┘
```

### Async Processing
```
┌─────────────────────────────────────────┐
│          ASYNC ARCHITECTURE             │
│                                         │
│ Synchronous Operations:                 │
│ ├─ User authentication                  │
│ ├─ Balance updates                      │
│ ├─ Task verification                    │
│ └─ Transaction processing               │
│                                         │
│ Asynchronous Operations:                │
│ ├─ Analytics event logging              │
│ ├─ Email/Push notifications             │
│ ├─ TON balance monitoring               │
│ ├─ Background health checks             │
│ └─ Cache warming                        │
│                                         │
│ Implementation:                         │
│ ├─ asyncio.create_task()                │
│ ├─ Background threads                   │
│ ├─ Queue processing                     │
│ └─ Scheduled jobs                       │
└─────────────────────────────────────────┘
```

## 🛡️ Error Handling & Recovery

### Fallback Mechanisms
```
1. Transaction Service Fallback
┌─────────────────────────────────────────┐
│ Primary: TransactionService.process()   │
│ ↓ (if fails)                            │
│ Fallback: Direct DB operations          │
│ ├─ supabase_client.update_balance()     │
│ ├─ Manual transaction logging           │
│ └─ Analytics.log_fallback_used()        │
│ ↓                                       │
│ Recovery: Sync transactions later       │
└─────────────────────────────────────────┘

2. External API Fallback
┌─────────────────────────────────────────┐
│ Primary: TelegramService.check()        │
│ ↓ (if API down)                         │
│ Fallback: Cached results (if available) │
│ ↓ (if no cache)                         │
│ Graceful: Mark as "pending verification"│
│ ↓                                       │
│ Recovery: Retry queue processing        │
└─────────────────────────────────────────┘

3. Database Connection Fallback
┌─────────────────────────────────────────┐
│ Primary: Supabase connection            │
│ ↓ (if connection lost)                  │
│ Retry: 3 attempts with backoff         │
│ ↓ (if still failing)                    │
│ Fallback: Local caching mode           │
│ ├─ Store operations in memory           │
│ ├─ Return cached responses              │
│ └─ Queue operations for later sync      │
│ ↓                                       │
│ Recovery: Auto-reconnect + sync         │
└─────────────────────────────────────────┘
```

## 📈 Monitoring & Health Checks

### Health Check Endpoints
```
GET /api/health
├─ Overall system health
├─ Database connectivity
├─ External services status
└─ Performance metrics

GET /api/winix/health
├─ WINIX system components
├─ Transaction service status
├─ Cache system health
└─ Background job status

GET /api/winix/diagnosis
├─ Detailed component analysis
├─ Performance bottlenecks
├─ Error rate statistics
└─ Resource utilization
```

## 📁 Детальний опис КОЖНОГО файлу системи

### 🏠 CORE SYSTEM FILES

#### `main.py` - Головний файл додатку
```python
Відповідальність: Точка входу Flask додатку
```
**Ключові функції:**
- 🚀 `create_app()` - Flask App Factory pattern
- 🔗 `setup_winix_routes(app)` - Реєстрація всіх WINIX маршрутів
- 🏥 `diagnose_winix_import()` - Діагностика завантаження модулів
- ⚙️ CORS налаштування для frontend
- 🛡️ Middleware інтеграція (Logger, Rate Limiter, Security)
- 📄 Static files serving (/assets, /js, /css, /ChenelPNG)
- ❌ Error handlers (404, 500)

**Залежності:**
- `settings.config` → Конфігурація додатку
- `quests/__init__.py` → WINIX система
- `middleware/*` → Middleware компоненти

**Маршрути що реєструються:**
```python
/api/health           → Загальний health check
/api/winix/*          → WINIX система маршрутів
/debug                → Діагностичний endpoint
/assets/<filename>    → Статичні файли
```

---

#### `supabase_client.py` - Database Layer
```python
Відповідальність: Єдина точка доступу до Supabase PostgreSQL
```
**Ключові функції:**
- 👤 **User Management**: `get_user()`, `create_user()`, `update_user()`
- 💰 **Balance Operations**: `update_balance()`, `update_coins()`
- 💳 **Transaction Processing**: Create, read, update transactions
- 📊 **Analytics Integration**: `create_analytics_event()`, `get_user_analytics()`
- 🎁 **Daily Bonus System**: `get_user_daily_status()`, `create_daily_bonus_entry()`
- 💎 **FLEX System**: `get_user_flex_balance()`, `create_flex_claim()`
- 📋 **Tasks Management**: `get_user_tasks_progress()`, `update_task_progress()`
- 💼 **Wallet Integration**: `get_user_wallet_info()`, `update_wallet_connection()`
- 🎯 **Staking System**: `create_staking_session()`, `complete_staking_session()`

**Caching Strategy:**
```python
@cached(timeout=300)  # User data: 5 хвилин
@cached(timeout=60)   # Daily status: 1 хвилина
@cached(timeout=180)  # Balance: 3 хвилини
```

**Error Handling:**
- Connection retry logic (3 спроби)
- Timeout handling (10 секунд)
- Graceful degradation при недоступності DB

---

### 📦 QUESTS PACKAGE

#### `quests/__init__.py` - WINIX System Core
```python
Відповідальність: Центральний координатор WINIX системи
```
**Головний клас:**
```python
class WinixQuests:
    def __init__(self):
        self.models = self._init_models()           # Data layer
        self.services = self._init_services()       # Business logic
        self.controllers = self._init_controllers() # API coordination
        self.utils = self._init_utils()            # Utilities
```

**Ключові методи:**
- 🏥 `health_check()` → Статус всіх компонентів системи
- 🛣️ `register_routes(app)` → Реєстрація всіх API маршрутів
- 🔍 `get_component_status()` → Діагностика окремих модулів
- ⚠️ `handle_component_failure()` → Fallback при помилках

**Component Status Tracking:**
```python
COMPONENTS_STATUS = {
    'models': {'loaded': True, 'error': None, 'count': 7},
    'services': {'loaded': True, 'error': None, 'count': 5},
    'controllers': {'loaded': True, 'error': None, 'count': 8},
    'routes': {'loaded': True, 'error': None, 'count': 8},
    'utils': {'loaded': True, 'error': None, 'count': 4}
}
```

**Graceful Degradation:**
- При помилці компонента створюються заглушки (stubs)
- Система продовжує працювати з обмеженим функціоналом
- Логування всіх помилок для діагностики

---

## 📊 MODELS LAYER - Data Access & Business Entities

### `models/__init__.py` - Models Coordinator
```python
Відповідальність: Централізоване завантаження та управління моделями
```
**Функціональність:**
- 📋 Model registration and initialization
- 🔍 Health checking for all models
- ⚠️ Error aggregation and reporting
- 🏥 Dependencies validation

---

### `models/analytics.py` - Analytics & Events System
```python
Відповідальність: Збір, збереження та аналіз подій користувачів
```

**Основні класи:**
```python
class AnalyticsDB:
    # Клас для роботи з базою даних аналітики
    def save_event(event: AnalyticsEvent) -> bool
    def get_user_events(user_id, date_range) -> List[AnalyticsEvent]
    def generate_user_stats(user_id) -> UserStats
    def cleanup_old_events(days_to_keep=90) -> int

class AnalyticsEvent:
    # Модель події користувача
    user_id: str
    event_type: EventType
    event_data: Dict[str, Any]
    timestamp: datetime
    severity: EventSeverity
    session_id: Optional[str]

class UserSession:
    # Сесія користувача
    session_id: str
    user_id: str
    start_time: datetime
    end_time: Optional[datetime]
    events_count: int
    platform: str

class UserStats:
    # Статистика користувача
    total_events: int
    daily_events: int
    favorite_actions: List[str]
    session_duration_avg: float
    last_activity: datetime
```

**EventType Enum:**
```python
AUTH = "auth"                    # Авторизація
TASK = "task"                    # Завдання
WALLET = "wallet"                # Гаманець
FLEX = "flex"                    # FLEX токени
DAILY = "daily"                  # Щоденні бонуси
TRANSACTION = "transaction"      # Транзакції
ERROR = "error"                  # Помилки
```

**Взаємодії:**
- ↔️ Supabase: `analytics_events`, `user_analytics_stats`, `user_sessions`
- ↗️ All Controllers: Асинхронне логування подій
- ↗️ Analytics Controller: Запити статистики

**Async Event Processing:**
```python
asyncio.create_task(analytics_db.save_event(event))
# Події зберігаються в фоновому режимі без блокування основного потоку
```

---

### `models/user_quest.py` - User Management System
```python
Відповідальність: Управління користувачами, балансами, профілями
```

**Основні класи:**
```python
class UserQuest:
    # Розширена модель користувача в системі квестів
    telegram_id: str
    username: str
    balance: UserBalance
    level: int
    experience: int
    created_at: datetime
    last_active: datetime
    daily_streak: int
    total_tasks_completed: int
    referrer_id: Optional[str]

    def get_user_by_telegram_id(telegram_id) -> Optional['UserQuest']
    def create_new_user(telegram_id, username, referrer_id) -> 'UserQuest'
    def update_balance(amount: int, currency: str) -> bool
    def add_experience(exp: int) -> bool
    def check_level_up() -> bool

class UserBalance:
    # Система балансів користувача
    winix: int = 0              # Основна валюта
    tickets: int = 0            # Квитки для спеціальних подій
    flex_tokens: int = 0        # FLEX токени (синхронізується з blockchain)

    def add_winix(amount: int) -> bool
    def spend_winix(amount: int) -> bool
    def add_tickets(amount: int) -> bool
    def spend_tickets(amount: int) -> bool
    def get_total_value() -> int

class Reward:
    # Структура винагороди
    winix: int = 0
    tickets: int = 0
    experience: int = 0

    def is_valid() -> bool
    def get_total_value() -> int

class TaskStatus(Enum):
    # Статуси завдань користувача
    NOT_STARTED = "not_started"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    EXPIRED = "expired"
```

**Ключові методи:**
- 👤 **Profile Management**: CRUD операції з профілем
- 💰 **Balance Operations**: Atomic операції з балансами
- 📈 **Level System**: Розрахунок рівнів та досвіду
- 🎯 **Achievement Tracking**: Відстеження досягнень
- 👥 **Referral System**: Обробка рефералів

**Взаємодії:**
- ↔️ Supabase: `winix` table (головна таблиця користувачів)
- ↗️ Auth Controller: Створення/валідація користувачів
- ↗️ User Controller: Профіль та баланси
- ↗️ All Controllers: Отримання даних користувача

---

### `models/daily_bonus.py` - Daily Rewards System
```python
Відповідальність: Система щоденних бонусів та серій
```

**Основні класи:**
```python
class DailyBonusEntry:
    # Запис про отримання щоденного бонусу
    telegram_id: str
    day_number: int              # День в серії (1-30)
    claimed_at: datetime
    reward_winix: int
    reward_tickets: int
    streak_bonus: int
    level_bonus: int

    def create_entry(telegram_id, day, reward) -> bool
    def get_user_history(telegram_id, limit=30) -> List['DailyBonusEntry']

class DailyBonusStatus:
    # Поточний статус щоденних бонусів користувача
    telegram_id: str
    current_day_number: int      # Поточний день (1-30, reset after 30)
    current_streak: int          # Активна серія днів
    last_claim_timestamp: datetime
    can_claim: bool
    next_claim_time: datetime

    def can_claim_now() -> bool
    def time_until_next_claim() -> timedelta
    def reset_streak() -> None
    def increment_day() -> None

class DailyBonusManager:
    # Менеджер щоденних бонусів
    def get_user_status(telegram_id) -> DailyBonusStatus
    def process_claim(telegram_id) -> Tuple[bool, Reward]
    def calculate_next_reward(telegram_id) -> Reward
    def check_streak_validity(last_claim) -> bool
    def reset_expired_streaks() -> int  # Background job
```

**Progressive Multipliers System:**
```python
DAILY_BONUS_CONFIG = {
    1: {"winix": 20, "tickets": 0, "multiplier": 1.0},
    7: {"winix": 20, "tickets": 1, "multiplier": 2.0},    # Special day
    14: {"winix": 20, "tickets": 2, "multiplier": 2.5},   # Special day
    21: {"winix": 20, "tickets": 3, "multiplier": 3.0},   # Special day
    30: {"winix": 20, "tickets": 10, "multiplier": 5.0}   # Final reward
}
```

**Бізнес-правила:**
- ⏰ Мінімум 20 годин між отриманнями
- 🔥 Серія обнуляється після 44 годин пропуску
- 🎯 Спеціальні дні: 7, 14, 21, 30 (додаткові tickets)
- 📈 Прогресивне зростання винагород

**Взаємодії:**
- ↔️ Supabase: `daily_bonus_status`, `daily_bonus_entries`
- ↗️ Daily Controller: Бізнес-логіка бонусів
- ↗️ Reward Calculator: Розрахунки винагород
- ↗️ Transaction Service: Нарахування винагород

---

### `models/flex_rewards.py` - FLEX Token Rewards System
```python
Відповідальність: FLEX токени, рівні винагород, інтеграція з TON
```

**Основні класи:**
```python
class FlexRewardsModel:
    # Основна модель FLEX системи
    def get_user_flex_balance(telegram_id) -> int
    def update_flex_balance(telegram_id, balance, wallet_address) -> bool
    def get_available_levels(telegram_id) -> List[FlexLevel]
    def can_claim_level(telegram_id, level) -> bool
    def process_claim(telegram_id, level) -> Tuple[bool, Reward]
    def get_claim_history(telegram_id) -> List[Dict]

class FlexLevel:
    # Рівень FLEX винагороди
    name: str                    # Bronze, Silver, Gold, Platinum, Diamond
    required_flex: int           # Мінімальна кількість FLEX
    reward_winix: int           # Винагорода WINIX
    reward_tickets: int         # Винагорода tickets
    cooldown_hours: int = 24    # Час очікування між claims

    def can_access(flex_balance: int) -> bool
    def get_reward() -> Reward

class FlexRewardConfig:
    # Конфігурація рівнів FLEX
    LEVELS = {
        "Bronze": FlexLevel("Bronze", 10_000, 25, 1, 24),
        "Silver": FlexLevel("Silver", 50_000, 75, 2, 24),
        "Gold": FlexLevel("Gold", 100_000, 150, 4, 24),
        "Platinum": FlexLevel("Platinum", 250_000, 300, 8, 24),
        "Diamond": FlexLevel("Diamond", 500_000, 500, 15, 24)
    }

class UserFlexStatus:
    # Статус FLEX користувача
    telegram_id: str
    current_flex_balance: int
    wallet_address: str
    last_balance_update: datetime
    claimed_levels: Dict[str, datetime]  # level -> last_claim_time

    def can_claim_level(level: str) -> bool
    def get_cooldown_remaining(level: str) -> timedelta
    def mark_level_claimed(level: str) -> None
```

**FLEX Levels Configuration:**
```python
Bronze:   10,000 FLEX   → 25 WINIX + 1 Ticket
Silver:   50,000 FLEX   → 75 WINIX + 2 Tickets
Gold:    100,000 FLEX   → 150 WINIX + 4 Tickets
Platinum: 250,000 FLEX  → 300 WINIX + 8 Tickets
Diamond:  500,000 FLEX  → 500 WINIX + 15 Tickets
```

**Особливості:**
- 🔗 Інтеграція з TON Blockchain для перевірки балансів
- ⏰ 24-годинний cooldown для кожного рівня
- 📊 Real-time синхронізація з wallet балансами
- 💎 Множинні рівні можна отримувати паралельно

**Взаємодії:**
- ↔️ Supabase: `flex_balances`, `flex_claims`
- ↗️ TON Connect Service: Баланси FLEX токенів
- ↗️ FLEX Controller: Бізнес-логіка
- ↗️ Transaction Service: Нарахування винагород

---

### `models/task.py` - Task Management System
```python
Відповідальність: Система завдань, типи, статуси, платформи
```

**Основні класи:**
```python
class TaskModel:
    # Основна модель завдань
    def get_all_tasks() -> List[Dict]
    def get_task_by_id(task_id) -> Optional[Dict]
    def create_task(task_data) -> Dict
    def update_task(task_id, updates) -> bool
    def delete_task(task_id) -> bool
    def get_user_task_progress(telegram_id) -> List[Dict]
    def update_task_progress(telegram_id, task_id, status, data) -> bool

class TaskType(Enum):
    # Типи завдань
    TELEGRAM_SUBSCRIBE = "telegram_subscribe"    # Підписка на канал
    TELEGRAM_BOT_START = "telegram_bot_start"    # Запуск бота
    YOUTUBE_SUBSCRIBE = "youtube_subscribe"      # YouTube підписка
    TWITTER_FOLLOW = "twitter_follow"            # Twitter підписка
    DISCORD_JOIN = "discord_join"                # Discord сервер
    SOCIAL_SHARE = "social_share"                # Поділитися в соцмережах
    LIMITED_TIME = "limited_time"                # Обмежені за часом
    PARTNER = "partner"                          # Партнерські
    DAILY_CHECK = "daily_check"                  # Щоденні перевірки

class TaskStatus(Enum):
    # Статуси виконання завдань
    AVAILABLE = "available"                      # Доступне для виконання
    STARTED = "started"                          # Розпочато
    IN_VERIFICATION = "in_verification"          # На перевірці
    COMPLETED = "completed"                      # Завершено
    FAILED = "failed"                           # Не пройдено
    EXPIRED = "expired"                         # Термін вийшов

class TaskPlatform(Enum):
    # Платформи для завдань
    TELEGRAM = "telegram"
    YOUTUBE = "youtube"
    TWITTER = "twitter"
    DISCORD = "discord"
    INSTAGRAM = "instagram"
    TIKTOK = "tiktok"
    WEBSITE = "website"

class TaskAction(Enum):
    # Дії для виконання
    SUBSCRIBE = "subscribe"                      # Підписатися
    LIKE = "like"                               # Поставити лайк
    SHARE = "share"                             # Поділитися
    COMMENT = "comment"                         # Коментувати
    JOIN = "join"                               # Приєднатися
    VISIT = "visit"                             # Відвідати
    DOWNLOAD = "download"                       # Завантажити
```

**Task Structure:**
```python
task_schema = {
    "id": "task_uuid",
    "title": "Підписатися на Telegram канал",
    "description": "Підпишіться на наш офіційний канал",
    "type": TaskType.TELEGRAM_SUBSCRIBE,
    "platform": TaskPlatform.TELEGRAM,
    "action": TaskAction.SUBSCRIBE,
    "target_url": "https://t.me/winixchannel",
    "verification_data": {
        "channel_username": "@winixchannel",
        "timer_seconds": 30
    },
    "reward": {
        "winix": 50,
        "tickets": 2,
        "experience": 10
    },
    "requirements": {
        "min_level": 1,
        "max_completions": 1,
        "expiry_date": "2024-12-31"
    },
    "status": "active"
}
```

**Взаємодії:**
- ↔️ Supabase: `tasks`, `task_progress`, `completed_tasks`
- ↗️ Tasks Controller: CRUD операції
- ↗️ Verification Service: Процес верифікації
- ↗️ Transaction Service: Винагороди за завершення

---

### `models/transaction.py` - Transaction Management System
```python
Відповідальність: Фінансові операції, історія транзакцій, аудит
```

**Основні класи:**
```python
class TransactionModel:
    # Модель фінансових транзакцій
    def create_transaction(transaction: Transaction) -> str
    def get_transaction(transaction_id) -> Optional[Transaction]
    def get_user_transactions(telegram_id, limit=50) -> List[Transaction]
    def update_transaction_status(transaction_id, status) -> bool
    def get_balance_from_transactions(telegram_id) -> TransactionAmount
    def reverse_transaction(transaction_id, reason) -> bool

class Transaction:
    # Структура транзакції
    id: str                              # UUID транзакції
    telegram_id: str                     # Користувач
    type: TransactionType                # Тип операції
    status: TransactionStatus            # Статус
    amount: TransactionAmount            # Суми по валютах
    metadata: Dict[str, Any]            # Додаткові дані
    created_at: datetime
    processed_at: Optional[datetime]
    description: str
    reference_id: Optional[str]          # ID пов'язаної операції

class TransactionAmount:
    # Суми транзакції по валютах
    winix: int = 0                      # Зміна WINIX
    tickets: int = 0                    # Зміна tickets

    def is_credit() -> bool             # Позитивна транзакція
    def is_debit() -> bool              # Негативна транзакція
    def get_total_value() -> int        # Загальна вартість

class TransactionType(Enum):
    # Типи транзакцій
    # ЗАРОБІТОК
    DAILY_BONUS = "daily_bonus"         # Щоденний бонус
    FLEX_REWARD = "flex_reward"         # FLEX винагорода
    TASK_REWARD = "task_reward"         # Винагорода за завдання
    REFERRAL_BONUS = "referral_bonus"   # Реферальний бонус
    WALLET_CONNECTION_BONUS = "wallet_connection_bonus"  # Бонус за гаманець
    LEVEL_UP_REWARD = "level_up_reward" # Винагорода за рівень

    # ВИТРАТИ
    PURCHASE = "purchase"               # Покупка
    WITHDRAWAL = "withdrawal"           # Виведення
    PENALTY = "penalty"                 # Штраф

    # СИСТЕМНІ
    ADMIN_ADJUSTMENT = "admin_adjustment"  # Ручне коригування
    MIGRATION = "migration"             # Міграція даних
    CORRECTION = "correction"           # Виправлення помилки

class TransactionStatus(Enum):
    # Статуси транзакцій
    PENDING = "pending"                 # В обробці
    COMPLETED = "completed"             # Завершено
    FAILED = "failed"                   # Помилка
    REVERSED = "reversed"               # Відкочено
    CANCELLED = "cancelled"             # Скасовано
```

**Аудит та безпека:**
```python
# Кожна транзакція незмінна після створення
# Reversals створюють нову транзакцію з протилежними сумами
# Повна історія зберігається для аудиту
# Atomic operations через database transactions
```

**Взаємодії:**
- ↔️ Supabase: `transactions` table
- ↗️ Transaction Service: Створення та обробка
- ↗️ All Controllers: Логування фінансових операцій
- ↗️ Analytics: Фінансова статистика

---

### `models/wallet.py` - TON Wallet Integration
```python
Відповідальність: TON гаманці, підключення, статуси, бонуси
```

**Основні класи:**
```python
class WalletModel:
    # Модель TON гаманців
    def get_wallet_info(telegram_id) -> Optional[Dict]
    def create_wallet_connection(telegram_id, wallet_data) -> bool
    def update_wallet_status(telegram_id, status) -> bool
    def disconnect_wallet(telegram_id) -> bool
    def get_wallet_events(telegram_id) -> List[Dict]
    def log_wallet_event(telegram_id, event_type, data) -> bool

class WalletStatus(Enum):
    # Статуси підключення гаманця
    DISCONNECTED = "disconnected"       # Не підключено
    CONNECTING = "connecting"           # В процесі підключення
    CONNECTED = "connected"             # Підключено
    VERIFIED = "verified"               # Верифіковано
    ERROR = "error"                     # Помилка підключення

class WalletProvider(Enum):
    # Провайдери TON гаманців
    TONKEEPER = "tonkeeper"
    TONHUB = "tonhub"
    OPENMASK = "openmask"
    MYTONWALLET = "mytonwallet"
    TONWALLET = "tonwallet"

class WalletConnectionBonus:
    # Бонус за підключення гаманця
    FIRST_CONNECTION_WINIX = 100        # Перше підключення
    FIRST_CONNECTION_TICKETS = 5
    VERIFICATION_WINIX = 50             # Верифікація підпису
    VERIFICATION_TICKETS = 2

    @staticmethod
    def get_connection_bonus() -> Reward:
        return Reward(winix=100, tickets=5)

    @staticmethod
    def get_verification_bonus() -> Reward:
        return Reward(winix=50, tickets=2)
```

**Wallet Connection Flow:**
```python
wallet_schema = {
    "telegram_id": "123456789",
    "address": "EQDk2VTvn04SUKJrW7rXahzdF8_Qi6utb0wj...",
    "provider": WalletProvider.TONKEEPER,
    "status": WalletStatus.CONNECTED,
    "connected_at": "2024-01-15T10:30:00Z",
    "last_verified": "2024-01-15T10:30:00Z",
    "balance_info": {
        "ton": 1.5,
        "flex": 75000,
        "last_updated": "2024-01-15T10:30:00Z"
    },
    "bonuses_received": {
        "connection_bonus": True,
        "verification_bonus": True
    }
}
```

**Взаємодії:**
- ↔️ Supabase: `wallets`, `wallet_events`
- ↗️ TON Connect Service: Blockchain взаємодія
- ↗️ Wallet Controller: Логіка підключення
- ↗️ Transaction Service: Бонуси за підключення

---

## 🔧 SERVICES LAYER - Business Logic & Integrations

### `services/__init__.py` - Services Coordinator
```python
Відповідальність: Централізоване управління сервісами
```
**Функціональність:**
- 🔧 Service initialization and dependency injection
- 🏥 Health monitoring for all services
- ⚠️ Error handling and fallback coordination
- 🔄 Service lifecycle management

---

### `services/reward_calculator.py` - Reward Calculation Engine
```python
Відповідальність: Розрахунки всіх видів винагород системи
```

**Основні функції:**
```python
class RewardCalculator:
    # Головний клас розрахунків винагород

    def calculate_daily_bonus(
        day_number: int,
        current_streak: int,
        user_level: int,
        bonus_multiplier: float = 1.0
    ) -> Reward:
        # Розрахунок щоденного бонусу

    def calculate_task_reward(
        task_type: TaskType,
        task_difficulty: str,
        user_level: int
    ) -> Reward:
        # Винагорода за завдання

    def calculate_flex_reward(
        flex_level: str,
        user_level: int
    ) -> Reward:
        # FLEX винагороди

    def calculate_referral_bonus(
        referrer_level: int,
        referred_action: str
    ) -> Reward:
        # Реферальні бонуси

    def apply_multipliers(
        base_reward: Reward,
        multipliers: Dict[str, float]
    ) -> Reward:
        # Застосування множників

    def get_reward_preview(
        start_day: int,
        end_day: int,
        user_level: int
    ) -> List[Reward]:
        # Попередній перегляд винагород
```

**Progressive Daily Bonus Logic:**
```python
def calculate_daily_bonus(day_number, current_streak, user_level, bonus_multiplier):
    # Базова винагорода
    base_winix = 20
    tickets = 0
    multiplier = 1.0

    # Спеціальні дні з множниками
    if day_number == 7:
        multiplier = 2.0
        tickets = 1
    elif day_number == 14:
        multiplier = 2.5
        tickets = 2
    elif day_number == 21:
        multiplier = 3.0
        tickets = 3
    elif day_number == 30:
        multiplier = 5.0
        tickets = 10

    # Бонус за серію
    streak_bonus = 0
    if current_streak >= 7:
        streak_bonus = 0.1  # +10%
    if current_streak >= 14:
        streak_bonus = 0.2  # +20%
    if current_streak >= 21:
        streak_bonus = 0.3  # +30%

    # Бонус за рівень
    level_bonus = max(0, (user_level - 1) * 0.05)  # +5% за рівень

    # Фінальний розрахунок
    final_winix = int(base_winix * multiplier * (1 + streak_bonus + level_bonus) * bonus_multiplier)

    return Reward(winix=final_winix, tickets=tickets)
```

**Task Rewards Configuration:**
```python
TASK_REWARDS = {
    TaskType.TELEGRAM_SUBSCRIBE: {"winix": 50, "tickets": 2},
    TaskType.YOUTUBE_SUBSCRIBE: {"winix": 75, "tickets": 3},
    TaskType.TWITTER_FOLLOW: {"winix": 40, "tickets": 1},
    TaskType.DISCORD_JOIN: {"winix": 60, "tickets": 2},
    TaskType.PARTNER: {"winix": 100, "tickets": 5},
    TaskType.LIMITED_TIME: {"winix": 150, "tickets": 7}
}
```

**Взаємодії:**
- ↗️ Daily Controller: Розрахунки щоденних бонусів
- ↗️ Tasks Controller: Винагороди за завдання
- ↗️ FLEX Controller: FLEX винагороди
- ↗️ Transaction Service: Валідація сум

---

### `services/telegram_service.py` - Telegram Integration
```python
Відповідальність: Інтеграція з Telegram Bot API та WebApp
```

**Основні методи:**
```python
class TelegramService:
    def __init__(self, bot_token: str):
        self.bot_token = bot_token
        self.bot_username = None
        self.session = aiohttp.ClientSession()

    # AUTHENTICATION & VALIDATION
    async def validate_webapp_data(self, init_data: str) -> Dict[str, Any]:
        # Валідація Telegram WebApp initData
        # Перевірка HMAC-SHA256 підпису
        # Валідація часу (не старше 24 годин)

    def parse_init_data(self, init_data: str) -> Dict[str, Any]:
        # Парсинг query string з WebApp

    # BOT INTERACTION
    async def check_bot_started(self, user_id: int) -> bool:
        # Перевірка чи користувач запустив бота

    async def send_message(self, user_id: int, text: str) -> bool:
        # Відправка повідомлення користувачу

    async def send_notification(self, user_id: int, notification_type: str, data: Dict) -> bool:
        # Відправка нотифікацій

    # CHANNEL & SUBSCRIPTION MANAGEMENT
    async def check_channel_subscription(self, user_id: int, channel_username: str) -> bool:
        # Перевірка підписки на канал
        # Обробка різних типів помилок

    async def get_chat_member(self, chat_id: str, user_id: int) -> Dict:
        # Отримання інформації про учасника чату

    # BOT INFO & HEALTH
    async def get_bot_info(self) -> Dict[str, Any]:
        # Інформація про бота

    async def health_check(self) -> bool:
        # Перевірка доступності Telegram API
```

**Error Handling:**
```python
# Типи помилок Telegram API
class TelegramError(Exception):
    pass

class BotBlocked(TelegramError):
    # Користувач заблокував бота
    pass

class ChatNotFound(TelegramError):
    # Канал не знайдено
    pass

class UserNotFound(TelegramError):
    # Користувач не знайдений
    pass

class InsufficientPermissions(TelegramError):
    # Недостатньо прав
    pass
```

**Retry Logic:**
```python
@retry(max_attempts=3, backoff_seconds=1)
async def check_subscription_with_retry(user_id, channel_username):
    # Автоматичні повторні спроби при помилках мережі
    # Exponential backoff strategy
    pass
```

**Взаємодії:**
- ↗️ Auth Controller: Валідація WebApp даних
- ↗️ Verification Service: Перевірка завдань
- ↗️ Tasks Controller: Верифікація Telegram завдань
- 🌐 Telegram Bot API: Зовнішні HTTP запити

---

### `services/ton_connect_service.py` - TON Blockchain Integration
```python
Відповідальність: Інтеграція з TON блокчейном та FLEX токенами
```

**Основні класи та методи:**
```python
class TONConnectService:
    def __init__(self, api_key: str, network: TONNetwork = TONNetwork.MAINNET):
        self.api_key = api_key
        self.network = network
        self.session = aiohttp.ClientSession()
        self.cache = {}

    # WALLET OPERATIONS
    async def validate_wallet_address(self, address: str) -> bool:
        # Валідація формату TON адреси
        # Перевірка checksum

    async def get_wallet_balance(self, address: str) -> TONBalance:
        # Отримання балансу TON гаманця
        # Кешування результатів (5 хв TTL)

    async def get_flex_balance(self, address: str) -> int:
        # Отримання балансу FLEX токенів
        # Запит до смарт-контракту FLEX

    # TRANSACTION MONITORING
    async def get_recent_transactions(self, address: str, limit: int = 50) -> List[Dict]:
        # Останні транзакції гаманця

    async def monitor_wallet_changes(self, address: str, callback: Callable) -> None:
        # Моніторинг змін балансу в реальному часі

    # VERIFICATION
    async def verify_wallet_ownership(self, address: str, signature: str, message: str) -> bool:
        # Верифікація підпису для підтвердження володіння

    # SMART CONTRACT INTERACTION
    async def call_flex_contract_method(self, method: str, params: Dict) -> Any:
        # Виклик методів FLEX смарт-контракту
```

**Data Classes:**
```python
@dataclass
class TONBalance:
    ton_balance: float          # Баланс TON
    flex_balance: int          # Баланс FLEX токенів
    last_updated: datetime     # Час останнього оновлення
    address: str              # Адреса гаманця

@dataclass
class FlexTokenInfo:
    contract_address: str     # Адреса смарт-контракту
    decimals: int            # Кількість десяткових знаків
    symbol: str = "FLEX"     # Символ токену
    total_supply: int        # Загальна емісія

class TONNetwork(Enum):
    MAINNET = "mainnet"
    TESTNET = "testnet"
```

**Caching Strategy:**
```python
# Кешування для оптимізації
CACHE_CONFIG = {
    "wallet_balance": {"ttl": 300, "type": "memory"},      # 5 хвилин
    "flex_balance": {"ttl": 180, "type": "memory"},        # 3 хвилини
    "transactions": {"ttl": 600, "type": "redis"},         # 10 хвилин
    "contract_info": {"ttl": 3600, "type": "redis"}        # 1 година
}
```

**Background Monitoring:**
```python
async def background_balance_monitor():
    # Фоновий процес для оновлення балансів
    while True:
        connected_wallets = await get_all_connected_wallets()
        for wallet in connected_wallets:
            try:
                balance = await get_wallet_balance(wallet.address)
                await update_cached_balance(wallet.telegram_id, balance)

                # Trigger FLEX level recalculation if needed
                if balance.flex_balance != wallet.last_flex_balance:
                    await recalculate_flex_levels(wallet.telegram_id)

            except Exception as e:
                logger.error(f"Balance update failed for {wallet.address}: {e}")

        await asyncio.sleep(300)  # 5 хвилин
```

**Взаємодії:**
- ↗️ Wallet Controller: Підключення та верифікація гаманців
- ↗️ FLEX Controller: Баланси FLEX токенів
- ↗️ Analytics: Blockchain статистика
- 🌐 TON API: Зовнішні blockchain запити

---

### `services/transaction_service.py` - Transaction Processing Hub
```python
Відповідальність: Централізована обробка всіх фінансових операцій
```

**Основний клас:**
```python
class TransactionService:
    def __init__(self):
        self.db = supabase_client
        self.analytics = analytics_db

    # CORE TRANSACTION METHODS
    def create_transaction(self, transaction_data: Dict) -> Dict[str, Any]:
        # Створення нової транзакції з валідацією

    def process_reward(
        self,
        telegram_id: str,
        winix_amount: int = 0,
        tickets_amount: int = 0,
        transaction_type: TransactionType,
        metadata: Dict = None
    ) -> Dict[str, Any]:
        # Централізована обробка винагород

    def process_spending(
        self,
        telegram_id: str,
        winix_amount: int = 0,
        tickets_amount: int = 0,
        transaction_type: TransactionType,
        metadata: Dict = None
    ) -> Dict[str, Any]:
        # Обробка витрат з перевіркою балансу

    # SPECIALIZED REWARD METHODS
    def process_daily_bonus(
        self,
        telegram_id: str,
        winix_amount: int,
        tickets_amount: int,
        day_number: int,
        streak: int
    ) -> Dict[str, Any]:
        # Обробка щоденного бонусу

    def process_flex_reward(
        self,
        telegram_id: str,
        winix_amount: int,
        tickets_amount: int,
        flex_level: str,
        flex_balance: int
    ) -> Dict[str, Any]:
        # Обробка FLEX винагороди

    def process_task_reward(
        self,
        telegram_id: str,
        winix_amount: int,
        tickets_amount: int,
        task_id: str,
        task_type: str
    ) -> Dict[str, Any]:
        # Винагорода за завдання

    def process_wallet_connection_bonus(
        self,
        telegram_id: str,
        wallet_address: str,
        is_first_connection: bool = False
    ) -> Dict[str, Any]:
        # Бонус за підключення гаманця

    # BALANCE & HISTORY
    def get_user_balance_summary(self, telegram_id: str) -> Dict[str, Any]:
        # Зведення балансу з транзакцій

    def get_transaction_history(
        self,
        telegram_id: str,
        limit: int = 50,
        transaction_type: Optional[TransactionType] = None
    ) -> List[Dict]:
        # Історія транзакцій користувача

    def reverse_transaction(self, transaction_id: str, reason: str) -> Dict[str, Any]:
        # Скасування транзакції
```

**Atomic Transaction Processing:**
```python
def process_reward(self, telegram_id, winix_amount, tickets_amount, transaction_type, metadata):
    """
    Атомарна обробка винагороди з повним аудитом
    """
    try:
        # 1. Валідація входів
        if not self._validate_reward_amounts(winix_amount, tickets_amount):
            return {"success": False, "error": "Invalid amounts"}

        # 2. Створення транзакції (pending)
        transaction = self._create_transaction_record(
            telegram_id=telegram_id,
            type=transaction_type,
            status=TransactionStatus.PENDING,
            amount=TransactionAmount(winix=winix_amount, tickets=tickets_amount),
            metadata=metadata
        )

        # 3. Атомарне оновлення балансу
        balance_updated = self.db.update_balance(
            telegram_id=telegram_id,
            winix_amount=winix_amount,
            tickets_amount=tickets_amount
        )

        if not balance_updated:
            # Rollback transaction
            self._update_transaction_status(transaction['id'], TransactionStatus.FAILED)
            return {"success": False, "error": "Balance update failed"}

        # 4. Фіналізація транзакції
        self._update_transaction_status(transaction['id'], TransactionStatus.COMPLETED)

        # 5. Асинхронне логування аналітики
        asyncio.create_task(self._log_transaction_analytics(transaction))

        # 6. Успішна відповідь
        return {
            "success": True,
            "transaction_id": transaction['id'],
            "new_balance": self._get_user_balance(telegram_id),
            "amount_added": {"winix": winix_amount, "tickets": tickets_amount}
        }

    except Exception as e:
        # Логування помилки та rollback
        logger.error(f"Transaction failed for {telegram_id}: {e}", exc_info=True)
        if 'transaction' in locals():
            self._update_transaction_status(transaction['id'], TransactionStatus.FAILED)
        return {"success": False, "error": "Internal server error"}
```

**Balance Validation:**
```python
def _validate_spending_request(self, telegram_id: str, winix_amount: int, tickets_amount: int) -> bool:
    """
    Перевірка достатності коштів для витрати
    """
    current_balance = self._get_user_balance(telegram_id)

    if current_balance['winix'] < winix_amount:
        return False

    if current_balance['tickets'] < tickets_amount:
        return False

    return True
```

**Взаємодії:**
- ↗️ All Controllers: Створення транзакцій для винагород/витрат
- ↔️ Supabase: Атомарні операції з балансами та транзакціями
- ↗️ Analytics: Асинхронне логування подій
- ↗️ User Model: Синхронізація балансів

---

### `services/verification_service.py` - Task Verification Engine
```python
Відповідальність: Верифікація виконання завдань різних типів
```

**Основний клас:**
```python
class VerificationService:
    def __init__(self):
        self.telegram_service = telegram_service
        self.verification_queue = {}
        self.active_verifications = {}

    # MAIN VERIFICATION METHODS
    async def start_verification(
        self,
        telegram_id: str,
        task_id: str,
        task_type: TaskType,
        verification_data: Dict
    ) -> Dict[str, Any]:
        # Початок процесу верифікації

    async def complete_verification(
        self,
        telegram_id: str,
        task_id: str
    ) -> Dict[str, Any]:
        # Завершення верифікації та видача винагороди

    # PLATFORM-SPECIFIC VERIFICATION
    async def verify_telegram_task(
        self,
        user_id: int,
        task_data: Dict
    ) -> VerificationResult:
        # Верифікація Telegram завдань

    async def verify_social_task(
        self,
        user_id: int,
        platform: TaskPlatform,
        task_data: Dict
    ) -> VerificationResult:
        # Верифікація соціальних мереж

    # TIMER-BASED VERIFICATION
    def start_verification_timer(
        self,
        telegram_id: str,
        task_id: str,
        timer_seconds: int
    ) -> None:
        # Запуск таймера для завдань з затримкою

    def check_timer_completion(
        self,
        telegram_id: str,
        task_id: str
    ) -> bool:
        # Перевірка завершення таймера
```

**Verification Result Structure:**
```python
@dataclass
class VerificationResult:
    verified: bool              # Чи пройшла верифікація
    error_message: str = ""     # Повідомлення про помилку
    retry_after: int = 0        # Через скільки секунд можна повторити
    metadata: Dict = None       # Додаткові дані
```

**Platform-Specific Logic:**
```python
async def verify_telegram_task(self, user_id: int, task_data: Dict) -> VerificationResult:
    """
    Верифікація Telegram завдань
    """
    task_type = task_data.get('type')

    if task_type == TaskType.TELEGRAM_SUBSCRIBE:
        # Перевірка підписки на канал
        channel_username = task_data['verification_data']['channel_username']

        is_subscribed = await self.telegram_service.check_channel_subscription(
            user_id, channel_username
        )

        if is_subscribed:
            return VerificationResult(verified=True)
        else:
            return VerificationResult(
                verified=False,
                error_message="Підписка на канал не знайдена",
                retry_after=30
            )

    elif task_type == TaskType.TELEGRAM_BOT_START:
        # Перевірка запуску бота
        bot_started = await self.telegram_service.check_bot_started(user_id)

        return VerificationResult(verified=bot_started)

    else:
        return VerificationResult(
            verified=False,
            error_message="Невідомий тип Telegram завдання"
        )

async def verify_social_task(self, user_id: int, platform: TaskPlatform, task_data: Dict) -> VerificationResult:
    """
    Верифікація завдань соціальних мереж
    """
    if platform == TaskPlatform.YOUTUBE:
        # YouTube підписка - використовуємо таймер + ручна перевірка
        return VerificationResult(verified=True, metadata={"method": "timer_based"})

    elif platform == TaskPlatform.TWITTER:
        # Twitter підписка - використовуємо таймер + ручна перевірка
        return VerificationResult(verified=True, metadata={"method": "timer_based"})

    elif platform == TaskPlatform.DISCORD:
        # Discord - використовуємо таймер + ручна перевірка
        return VerificationResult(verified=True, metadata={"method": "timer_based"})

    else:
        return VerificationResult(
            verified=False,
            error_message=f"Верифікація для {platform.value} не підтримується"
        )
```

**Timer-Based Verification:**
```python
class VerificationTimer:
    def __init__(self, telegram_id: str, task_id: str, duration: int):
        self.telegram_id = telegram_id
        self.task_id = task_id
        self.started_at = datetime.now()
        self.duration = duration  # seconds

    def is_completed(self) -> bool:
        elapsed = (datetime.now() - self.started_at).total_seconds()
        return elapsed >= self.duration

    def time_remaining(self) -> int:
        elapsed = (datetime.now() - self.started_at).total_seconds()
        return max(0, self.duration - int(elapsed))

# Менеджер таймерів
verification_timers: Dict[str, VerificationTimer] = {}

def start_verification_timer(telegram_id: str, task_id: str, timer_seconds: int):
    timer_key = f"{telegram_id}:{task_id}"
    verification_timers[timer_key] = VerificationTimer(
        telegram_id, task_id, timer_seconds
    )
```

**Verification Queue Management:**
```python
async def process_verification_queue():
    """
    Фоновий процес обробки черги верифікації
    """
    while True:
        try:
            # Перевірка завершених таймерів
            completed_timers = [
                timer_key for timer_key, timer in verification_timers.items()
                if timer.is_completed()
            ]

            # Обробка завершених верифікацій
            for timer_key in completed_timers:
                timer = verification_timers.pop(timer_key)
                await auto_complete_verification(timer.telegram_id, timer.task_id)

            await asyncio.sleep(10)  # Перевірка кожні 10 секунд

        except Exception as e:
            logger.error(f"Verification queue processing error: {e}")
            await asyncio.sleep(30)  # При помилці - довша затримка
```

**Взаємодії:**
- ↗️ Tasks Controller: Процес верифікації завдань
- ↗️ Telegram Service: Перевірка Telegram завдань
- ↗️ Transaction Service: Видача винагород після верифікації
- ↗️ Analytics: Логування результатів верифікації

---

## 🎮 CONTROLLERS LAYER - API Coordination

### `controllers/__init__.py` - Controllers Manager
```python
Відповідальність: Централізоване управління контролерами
```
**Головні функції:**
- 📋 Registration and initialization of all controllers
- 🏥 Health checking across controllers
- ⚠️ Error handling coordination
- 🔄 Fallback mechanism when controllers fail

**Controllers Status Tracking:**
```python
controllers_status: Dict[str, Dict[str, Any]] = {
    'analytics': {'loaded': True, 'error': None},
    'auth': {'loaded': True, 'error': None},
    'daily': {'loaded': True, 'error': None},
    'flex': {'loaded': True, 'error': None},
    'tasks': {'loaded': True, 'error': None},
    'transaction': {'loaded': True, 'error': None},
    'user': {'loaded': True, 'error': None},
    'verification': {'loaded': True, 'error': None},
    'wallet': {'loaded': True, 'error': None}
}
```

---

### `controllers/auth_controller.py` - Authentication Controller
```python
Відповідальність: Telegram WebApp авторизація та JWT управління
```

**Головні функції:**
```python
def validate_telegram_route():
    # POST /api/auth/validate-telegram
    # Валідація Telegram WebApp initData та створення JWT токену

def refresh_token_route():
    # POST /api/auth/refresh-token
    # Оновлення JWT токену

def validate_token_route():
    # GET /api/auth/validate-token
    # Перевірка чинності JWT токену

def logout_route():
    # POST /api/auth/logout
    # Вихід з системи (інвалідація токену)
```

**Authentication Flow:**
```python
def validate_telegram_route():
    """
    Повний процес авторизації через Telegram WebApp
    """
    try:
        # 1. Отримання та валідація initData
        request_data = request.get_json()
        init_data = request_data.get('initData')

        if not init_data:
            return error_response("initData is required", 400)

        # 2. Валідація через Telegram Service
        validation_result = telegram_service.validate_webapp_data(init_data)

        if not validation_result['valid']:
            return error_response("Invalid Telegram data", 401)

        # 3. Обробка даних користувача
        user_data = validation_result['user']
        telegram_id = str(user_data['id'])
        username = user_data.get('username', '')

        # 4. Отримання або створення користувача
        user = get_user(telegram_id)
        if not user:
            # Створення нового користувача
            referrer_id = request_data.get('referrer_id')
            user = create_user(telegram_id, username, referrer_id)

            if user:
                # Вітальний бонус для нового користувача
                welcome_bonus = transaction_service.process_welcome_bonus(telegram_id)
                asyncio.create_task(
                    analytics_db.save_event(AnalyticsEvent(
                        user_id=telegram_id,
                        event_type=EventType.AUTH,
                        event_data={"action": "new_user_created", "welcome_bonus": welcome_bonus}
                    ))
                )

        # 5. Генерація JWT токену
        token_payload = {
            'user_id': user['id'],
            'telegram_id': telegram_id,
            'username': username,
            'exp': datetime.utcnow() + timedelta(days=7)
        }

        jwt_token = generate_jwt_token(token_payload)

        # 6. Логування успішної авторизації
        asyncio.create_task(
            analytics_db.save_event(AnalyticsEvent(
                user_id=telegram_id,
                event_type=EventType.AUTH,
                event_data={"action": "login_success", "method": "telegram_webapp"}
            ))
        )

        # 7. Відповідь з даними користувача та токеном
        return success_response({
            'token': jwt_token,
            'user': {
                'id': user['id'],
                'telegram_id': telegram_id,
                'username': username,
                'balance': {
                    'winix': user.get('winix', 0),
                    'tickets': user.get('tickets', 0)
                },
                'level': user.get('level', 1),
                'created_at': user.get('created_at')
            },
            'expires_in': 604800  # 7 днів у секундах
        })

    except Exception as e:
        logger.error(f"Authentication error: {e}", exc_info=True)
        return error_response("Authentication failed", 500)
```

**JWT Token Management:**
```python
def generate_jwt_token(payload: Dict) -> str:
    """
    Генерація JWT токену з підписом
    """
    secret_key = os.getenv('JWT_SECRET_KEY')
    algorithm = 'HS256'

    return jwt.encode(payload, secret_key, algorithm=algorithm)

def decode_jwt_token(token: str) -> Dict[str, Any]:
    """
    Декодування та валідація JWT токену
    """
    try:
        secret_key = os.getenv('JWT_SECRET_KEY')
        payload = jwt.decode(token, secret_key, algorithms=['HS256'])
        return {'valid': True, 'payload': payload}
    except jwt.ExpiredSignatureError:
        return {'valid': False, 'error': 'Token expired'}
    except jwt.InvalidTokenError:
        return {'valid': False, 'error': 'Invalid token'}
```

**Взаємодії:**
- ↗️ Telegram Service: Валідація WebApp даних
- ↗️ User Model: Створення/отримання користувачів
- ↗️ Transaction Service: Вітальні бонуси
- ↗️ Analytics: Логування авторизації

---

### `controllers/daily_controller.py` - Daily Bonus Controller
```python
Відповідальність: Управління щоденними бонусами з Transaction Service інтеграцією
```

**Головні функції:**
```python
def get_daily_status_route():
    # GET /api/daily/status/{telegram_id}
    # Отримання поточного статусу щоденних бонусів

def claim_daily_bonus_route():
    # POST /api/daily/claim/{telegram_id}
    # Отримання щоденного бонусу через Transaction Service

def get_daily_history_route():
    # GET /api/daily/history/{telegram_id}
    # Історія отримання щоденних бонусів

def calculate_reward_for_day_route():
    # GET /api/daily/preview/{telegram_id}
    # Попередній перегляд винагороди на наступні дні
```

**Детальна реалізація claim_daily_bonus:**
```python
def claim_daily_bonus_route():
    """
    Основна функція отримання щоденного бонусу
    """
    try:
        # 1. Валідація користувача
        telegram_id = request.view_args.get('telegram_id')
        validated_id = validate_telegram_id(telegram_id)

        if not validated_id:
            return error_response("Invalid telegram_id", 400)

        # 2. Отримання статусу щоденних бонусів
        daily_status = daily_bonus_manager.get_user_status(validated_id)

        if not daily_status.can_claim:
            time_remaining = daily_status.time_until_next_claim()
            return error_response(
                f"Cannot claim yet. Wait {time_remaining}", 400
            )

        # 3. Розрахунок винагороди
        user = get_user(validated_id)
        if not user:
            return error_response("User not found", 404)

        reward = reward_calculator.calculate_daily_bonus(
            day_number=daily_status.current_day_number,
            current_streak=daily_status.current_streak,
            user_level=user.get('level', 1),
            bonus_multiplier=1.0
        )

        # 4. Обробка через Transaction Service (PREFERRED METHOD)
        if transaction_service:
            transaction_result = transaction_service.process_daily_bonus(
                telegram_id=str(validated_id),
                winix_amount=reward.winix,
                tickets_amount=reward.tickets,
                day_number=daily_status.current_day_number,
                streak=daily_status.current_streak
            )

            if transaction_result['success']:
                # Оновлення статусу щоденних бонусів
                daily_bonus_manager.mark_claimed(validated_id)

                # Асинхронне логування аналітики
                asyncio.create_task(
                    analytics_db.save_event(AnalyticsEvent(
                        user_id=str(validated_id),
                        event_type=EventType.DAILY,
                        event_data={
                            "action": "daily_bonus_claimed",
                            "day_number": daily_status.current_day_number,
                            "streak": daily_status.current_streak,
                            "reward": reward.__dict__,
                            "method": "transaction_service"
                        }
                    ))
                )

                return success_response({
                    'claimed': True,
                    'reward': {
                        'winix': reward.winix,
                        'tickets': reward.tickets
                    },
                    'new_balance': transaction_result['new_balance'],
                    'day_number': daily_status.current_day_number + 1,
                    'streak': daily_status.current_streak + 1,
                    'transaction_id': transaction_result['transaction_id']
                })
            else:
                return error_response(
                    f"Transaction failed: {transaction_result['error']}", 500
                )

        # 5. Fallback до прямих DB операцій
        else:
            logger.warning("Transaction Service недоступний, використовуємо fallback")

            success_operations = []

            # Прямі операції з базою даних
            if reward.winix > 0:
                winix_updated = update_balance(validated_id, reward.winix)
                if winix_updated:
                    success_operations.append(f"WINIX +{reward.winix}")

            if reward.tickets > 0:
                tickets_updated = update_coins(validated_id, reward.tickets)
                if tickets_updated:
                    success_operations.append(f"Tickets +{reward.tickets}")

            if success_operations:
                # Оновлення статусу
                daily_bonus_manager.mark_claimed(validated_id)

                # Створення запису в історії
                daily_bonus_manager.create_history_entry(
                    validated_id, daily_status.current_day_number, reward
                )

                return success_response({
                    'claimed': True,
                    'reward': {'winix': reward.winix, 'tickets': reward.tickets},
                    'operations': success_operations,
                    'day_number': daily_status.current_day_number + 1,
                    'method': 'fallback'
                })
            else:
                return error_response("Failed to process reward", 500)

    except Exception as e:
        logger.error(f"Daily bonus claim error: {e}", exc_info=True)
        return error_response("Internal server error", 500)
```

**Взаємодії:**
- ↗️ Daily Bonus Model: Статуси та управління
- ↗️ Reward Calculator: Розрахунки винагород
- ↗️ Transaction Service: Атомарне нарахування (preferred)
- ↗️ Analytics: Логування подій
- ↗️ Supabase: Fallback операції

---

### `controllers/flex_controller.py` - FLEX Rewards Controller
```python
Відповідальність: FLEX токени, рівні винагород, TON blockchain інтеграція
```

**Головні функції:**
```python
def get_flex_balance_route():
    # GET /api/flex/balance/{telegram_id}
    # Отримання поточного балансу FLEX токенів з blockchain

def check_flex_levels_route():
    # GET /api/flex/levels/{telegram_id}
    # Перевірка доступних рівнів винагород

def claim_flex_reward_route():
    # POST /api/flex/claim/{telegram_id}
    # Отримання винагороди за FLEX рівень

def get_flex_history_route():
    # GET /api/flex/history/{telegram_id}
    # Історія отримання FLEX винагород
```

**Реалізація claim_flex_reward:**
```python
def claim_flex_reward_route():
    """
    Отримання винагороди за FLEX рівень
    """
    try:
        # 1. Валідація вхідних даних
        telegram_id = request.view_args.get('telegram_id')
        validated_id = validate_telegram_id(telegram_id)

        request_data = request.get_json()
        requested_level = request_data.get('level')

        if not requested_level or requested_level not in flex_rewards_model.LEVELS:
            return error_response("Invalid FLEX level", 400)

        # 2. Перевірка підключення гаманця
        user = get_user(validated_id)
        if not user:
            return error_response("User not found", 404)

        wallet_info = get_user_wallet_info(validated_id)
        if not wallet_info or wallet_info.get('status') != 'connected':
            return error_response("Wallet not connected", 400)

        # 3. Перевірка FLEX балансу через TON Connect
        wallet_address = wallet_info['address']

        if ton_connect_service:
            try:
                ton_balance = await ton_connect_service.get_flex_balance(wallet_address)

                # Оновлення кешованого балансу
                flex_rewards_model.update_flex_balance(
                    validated_id, ton_balance, wallet_address
                )

            except Exception as e:
                logger.error(f"TON Connect error: {e}")
                # Використовуємо кешований баланс
                ton_balance = flex_rewards_model.get_cached_balance(validated_id)
        else:
            # Fallback до кешованого балансу
            ton_balance = flex_rewards_model.get_cached_balance(validated_id)

        # 4. Валідація права на отримання
        level_config = flex_rewards_model.LEVELS[requested_level]

        if ton_balance < level_config.required_flex:
            return error_response(
                f"Insufficient FLEX. Required: {level_config.required_flex}, "
                f"Current: {ton_balance}", 400
            )

        # Перевірка cooldown
        can_claim, cooldown_remaining = flex_rewards_model.can_claim_level(
            validated_id, requested_level
        )

        if not can_claim:
            return error_response(
                f"Cooldown active. Wait {cooldown_remaining}", 400
            )

        # 5. Обробка винагороди через Transaction Service
        if transaction_service:
            transaction_result = transaction_service.process_flex_reward(
                telegram_id=str(validated_id),
                winix_amount=level_config.reward_winix,
                tickets_amount=level_config.reward_tickets,
                flex_level=requested_level,
                flex_balance=ton_balance
            )

            if transaction_result['success']:
                # Встановлення cooldown
                flex_rewards_model.set_level_cooldown(validated_id, requested_level)

                # Логування в flex_claims
                flex_rewards_model.create_claim_record(
                    validated_id, requested_level, ton_balance, level_config
                )

                # Аналітика
                asyncio.create_task(
                    analytics_db.save_event(AnalyticsEvent(
                        user_id=str(validated_id),
                        event_type=EventType.FLEX,
                        event_data={
                            "action": "flex_reward_claimed",
                            "level": requested_level,
                            "flex_balance": ton_balance,
                            "reward": {
                                "winix": level_config.reward_winix,
                                "tickets": level_config.reward_tickets
                            }
                        }
                    ))
                )

                return success_response({
                    'claimed': True,
                    'level': requested_level,
                    'reward': {
                        'winix': level_config.reward_winix,
                        'tickets': level_config.reward_tickets
                    },
                    'flex_balance': ton_balance,
                    'new_balance': transaction_result['new_balance'],
                    'cooldown_until': flex_rewards_model.get_cooldown_end(
                        validated_id, requested_level
                    )
                })
            else:
                return error_response(
                    f"Transaction failed: {transaction_result['error']}", 500
                )

        # 6. Fallback операції
        else:
            # Прямі DB операції як fallback
            reward_given = False

            if level_config.reward_winix > 0:
                winix_updated = update_balance(validated_id, level_config.reward_winix)
                reward_given = winix_updated

            if level_config.reward_tickets > 0:
                tickets_updated = update_coins(validated_id, level_config.reward_tickets)
                reward_given = reward_given or tickets_updated

            if reward_given:
                flex_rewards_model.set_level_cooldown(validated_id, requested_level)
                return success_response({
                    'claimed': True,
                    'level': requested_level,
                    'method': 'fallback'
                })
            else:
                return error_response("Failed to process FLEX reward", 500)

    except Exception as e:
        logger.error(f"FLEX claim error: {e}", exc_info=True)
        return error_response("Internal server error", 500)
```

**Взаємодії:**
- ↗️ FLEX Rewards Model: Рівні та статуси
- ↗️ TON Connect Service: Blockchain баланси
- ↗️ Transaction Service: Атомарне нарахування
- ↗️ Wallet Model: Інформація про гаманець
- ↗️ Analytics: Логування подій

---

### `controllers/tasks_controller.py` - Tasks Management Controller
```python
Відповідальність: CRUD завдань, верифікація, автоматичне нарахування винагород
```

**Головні функції:**
```python
def get_tasks_list_route():
    # GET /api/tasks/list/{telegram_id}
    # Список доступних завдань з фільтрацією виконаних

def get_task_details_route():
    # GET /api/tasks/details/{task_id}
    # Детальна інформація про завдання

def start_task_route():
    # POST /api/tasks/start/{telegram_id}/{task_id}
    # Початок виконання завдання

def verify_task_route():
    # POST /api/tasks/verify/{telegram_id}/{task_id}
    # Верифікація виконання + автоматична винагорода

def get_user_task_progress_route():
    # GET /api/tasks/progress/{telegram_id}
    # Прогрес користувача по завданнях

def create_task_route():
    # POST /api/tasks/create (admin only)
    # Створення нового завдання
```

**Lifecycle завдання - verify_task_route:**
```python
def verify_task_route():
    """
    Верифікація завдання з автоматичним нарахуванням винагороди
    """
    try:
        # 1. Валідація параметрів
        telegram_id = request.view_args.get('telegram_id')
        task_id = request.view_args.get('task_id')

        validated_id = validate_telegram_id(telegram_id)
        if not validated_id:
            return error_response("Invalid telegram_id", 400)

        # 2. Отримання завдання та перевірка існування
        task = task_model.get_task_by_id(task_id)
        if not task:
            return error_response("Task not found", 404)

        # 3. Перевірка чи завдання вже виконано
        user_progress = task_model.get_user_task_progress(validated_id)
        completed_tasks = [p['task_id'] for p in user_progress if p['status'] == 'completed']

        if task_id in completed_tasks:
            return error_response("Task already completed", 400)

        # 4. Перевірка чи завдання було розпочато
        task_progress = next(
            (p for p in user_progress if p['task_id'] == task_id), None
        )

        if not task_progress or task_progress['status'] != 'started':
            return error_response("Task not started", 400)

        # 5. Верифікація через Verification Service
        if verification_service:
            verification_result = await verification_service.complete_verification(
                telegram_id=str(validated_id),
                task_id=task_id
            )

            if not verification_result['verified']:
                # Оновлення статусу як failed
                task_model.update_task_progress(
                    validated_id, task_id, 'failed',
                    {'error': verification_result.get('error', 'Verification failed')}
                )

                return error_response(
                    verification_result.get('error', 'Task verification failed'), 400
                )

        # 6. Верифікацію пройдено - нараховуємо винагороду
        task_reward = task.get('reward', {})
        winix_reward = task_reward.get('winix', 0)
        tickets_reward = task_reward.get('tickets', 0)

        if transaction_service and (winix_reward > 0 or tickets_reward > 0):
            # Атомарне нарахування через Transaction Service
            reward_result = transaction_service.process_task_reward(
                telegram_id=str(validated_id),
                winix_amount=winix_reward,
                tickets_amount=tickets_reward,
                task_id=task_id,
                task_type=task.get('type', 'unknown')
            )

            if reward_result['success']:
                # Позначаємо завдання як виконане
                task_model.update_task_progress(
                    validated_id, task_id, 'completed',
                    {
                        'completed_at': datetime.now().isoformat(),
                        'reward_given': True,
                        'transaction_id': reward_result['transaction_id']
                    }
                )

                # Створення запису в completed_tasks
                task_model.create_completed_task_record(
                    validated_id, task_id, task['type'], task_reward
                )

                # Аналітика
                asyncio.create_task(
                    analytics_db.save_event(AnalyticsEvent(
                        user_id=str(validated_id),
                        event_type=EventType.TASK,
                        event_data={
                            "action": "task_completed",
                            "task_id": task_id,
                            "task_type": task['type'],
                            "reward": task_reward,
                            "verification_method": verification_result.get('method', 'unknown')
                        }
                    ))
                )

                return success_response({
                    'verified': True,
                    'completed': True,
                    'reward': task_reward,
                    'new_balance': reward_result['new_balance'],
                    'transaction_id': reward_result['transaction_id']
                })
            else:
                # Транзакція не пройшла, але верифікація успішна
                task_model.update_task_progress(
                    validated_id, task_id, 'completed',
                    {
                        'completed_at': datetime.now().isoformat(),
                        'reward_given': False,
                        'error': f"Reward failed: {reward_result['error']}"
                    }
                )

                return success_response({
                    'verified': True,
                    'completed': True,
                    'reward_given': False,
                    'error': 'Reward processing failed'
                })

        # 7. Завдання без винагороди або fallback
        else:
            # Позначаємо як виконане без винагороди
            task_model.update_task_progress(
                validated_id, task_id, 'completed',
                {'completed_at': datetime.now().isoformat()}
            )

            return success_response({
                'verified': True,
                'completed': True,
                'reward': task_reward if task_reward else None
            })

    except Exception as e:
        logger.error(f"Task verification error: {e}", exc_info=True)
        return error_response("Internal server error", 500)
```

**Взаємодії:**
- ↗️ Task Model: CRUD операції з завданнями
- ↗️ Verification Service: Процес верифікації
- ↗️ Transaction Service: Автоматичні винагороди
- ↗️ Analytics: Логування завершень завдань

---

### `controllers/user_controller.py` - User Management Controller
```python
Відповідальність: Профілі користувачів, баланси, статистика
```

**Головні функції:**
```python
def get_user_profile_route():
    # GET /api/user/profile/{telegram_id}
    # Повний профіль користувача з верифікацією через транзакції

def get_user_balance_route():
    # GET /api/user/balance/{telegram_id}
    # Баланси з cross-verification через Transaction Service

def update_user_balance_route():
    # PUT /api/user/balance/{telegram_id}
    # Оновлення балансу через Transaction Service

def get_user_stats_route():
    # GET /api/user/stats/{telegram_id}
    # Статистика з аналітики та транзакцій
```

**Integration Pattern з Transaction Service:**
```python
def get_user_balance_route():
    """
    Отримання балансу з cross-verification
    """
    try:
        telegram_id = request.view_args.get('telegram_id')
        validated_id = validate_telegram_id(telegram_id)

        # 1. Отримання базових даних користувача
        user = get_user(validated_id)
        if not user:
            return error_response("User not found", 404)

        # 2. Cross-verification через Transaction Service
        balance_from_db = {
            'winix': user.get('winix', 0),
            'tickets': user.get('tickets', 0)
        }

        if transaction_service:
            # Перевірка балансу через транзакції
            transaction_balance = transaction_service.get_user_balance_summary(
                str(validated_id)
            )

            # Порівняння та виявлення розбіжностей
            discrepancies = {}
            if balance_from_db['winix'] != transaction_balance.get('winix', 0):
                discrepancies['winix'] = {
                    'db': balance_from_db['winix'],
                    'transactions': transaction_balance.get('winix', 0)
                }

            if balance_from_db['tickets'] != transaction_balance.get('tickets', 0):
                discrepancies['tickets'] = {
                    'db': balance_from_db['tickets'],
                    'transactions': transaction_balance.get('tickets', 0)
                }

            if discrepancies:
                # Логування розбіжностей для подальшої корекції
                logger.warning(
                    f"Balance discrepancy for user {validated_id}: {discrepancies}"
                )

                # Аналітична подія про розбіжність
                asyncio.create_task(
                    analytics_db.save_event(AnalyticsEvent(
                        user_id=str(validated_id),
                        event_type=EventType.ERROR,
                        event_data={
                            "action": "balance_discrepancy_detected",
                            "discrepancies": discrepancies
                        },
                        severity=EventSeverity.WARNING
                    ))
                )

        # 3. Повернення балансу (з DB як primary source)
        return success_response({
            'telegram_id': validated_id,
            'balance': balance_from_db,
            'verified': discrepancies == {} if transaction_service else None,
            'last_updated': user.get('updated_at')
        })

    except Exception as e:
        logger.error(f"Balance retrieval error: {e}", exc_info=True)
        return error_response("Internal server error", 500)
```

**Взаємодії:**
- ↗️ User Model: Профільні дані
- ↗️ Transaction Service: Верифікація балансів
- ↗️ Analytics: Статистика користувача
- ↗️ Supabase: CRUD операції

---

### `controllers/wallet_controller.py` - TON Wallet Controller
```python
Відповідальність: TON гаманці з автоматичними бонусами
```

**Головні функції:**
```python
def check_wallet_status_route():
    # GET /api/wallet/status/{telegram_id}
    # Статус підключення TON гаманця

def connect_wallet_route():
    # POST /api/wallet/connect/{telegram_id}
    # Підключення гаманця + автоматичний бонус

def disconnect_wallet_route():
    # DELETE /api/wallet/disconnect/{telegram_id}
    # Відключення гаманця

def verify_wallet_route():
    # POST /api/wallet/verify/{telegram_id}
    # Верифікація підпису гаманця
```

**Workflow підключення з бонусами:**
```python
def connect_wallet_route():
    """
    Підключення TON гаманця з автоматичним бонусом
    """
    try:
        # 1. Валідація користувача та даних
        telegram_id = request.view_args.get('telegram_id')
        validated_id = validate_telegram_id(telegram_id)

        wallet_data = request.get_json()
        wallet_address = sanitize_string(wallet_data.get('address', '').strip())
        provider = wallet_data.get('provider', 'unknown')
        signature = wallet_data.get('signature', '')

        # 2. Валідація адреси через TON Connect
        if ton_connect_service:
            is_valid_address = await ton_connect_service.validate_wallet_address(
                wallet_address
            )
            if not is_valid_address:
                return error_response("Invalid TON wallet address", 400)

            # Верифікація підпису (якщо надано)
            if signature:
                is_signature_valid = await ton_connect_service.verify_wallet_ownership(
                    wallet_address, signature, f"Connect to WINIX {validated_id}"
                )
                if not is_signature_valid:
                    return error_response("Invalid wallet signature", 400)

        # 3. Перевірка чи це перше підключення
        existing_wallet = wallet_model.get_wallet_info(validated_id)
        is_first_connection = not existing_wallet or existing_wallet.get('status') == 'disconnected'

        # 4. Збереження підключення
        connection_success = wallet_model.create_wallet_connection(
            validated_id, {
                'address': wallet_address,
                'provider': provider,
                'status': 'connected',
                'connected_at': datetime.now().isoformat(),
                'signature_verified': bool(signature)
            }
        )

        if not connection_success:
            return error_response("Failed to save wallet connection", 500)

        # 5. Автоматичний бонус за підключення
        bonus_result = None
        if is_first_connection and transaction_service:
            bonus_result = transaction_service.process_wallet_connection_bonus(
                telegram_id=str(validated_id),
                wallet_address=wallet_address,
                is_first_connection=True
            )

            if bonus_result['success']:
                # Логування події бонусу
                wallet_model.log_wallet_event(
                    validated_id, 'connection_bonus_given',
                    {
                        'bonus': bonus_result['amount_added'],
                        'transaction_id': bonus_result['transaction_id']
                    }
                )

        # 6. Отримання балансів з blockchain
        blockchain_balances = {}
        if ton_connect_service:
            try:
                ton_balance = await ton_connect_service.get_wallet_balance(wallet_address)
                blockchain_balances = {
                    'ton': ton_balance.ton_balance,
                    'flex': ton_balance.flex_balance,
                    'last_updated': ton_balance.last_updated.isoformat()
                }
            except Exception as e:
                logger.warning(f"Failed to get blockchain balances: {e}")

        # 7. Логування аналітики
        asyncio.create_task(
            analytics_db.save_event(AnalyticsEvent(
                user_id=str(validated_id),
                event_type=EventType.WALLET,
                event_data={
                    "action": "wallet_connected",
                    "provider": provider,
                    "address": wallet_address[:10] + "...",  # Обрізана адреса для приватності
                    "first_connection": is_first_connection,
                    "bonus_given": bonus_result['success'] if bonus_result else False
                }
            ))
        )

        # 8. Успішна відповідь
        response_data = {
            'connected': True,
            'address': wallet_address,
            'provider': provider,
            'status': 'connected',
            'first_connection': is_first_connection,
            'blockchain_balances': blockchain_balances
        }

        if bonus_result and bonus_result['success']:
            response_data['bonus_received'] = {
                'winix': bonus_result['amount_added']['winix'],
                'tickets': bonus_result['amount_added']['tickets'],
                'transaction_id': bonus_result['transaction_id']
            }

        return success_response(response_data)

    except Exception as e:
        logger.error(f"Wallet connection error: {e}", exc_info=True)
        return error_response("Internal server error", 500)
```

**Взаємодії:**
- ↗️ Wallet Model: Збереження підключень
- ↗️ TON Connect Service: Blockchain валідація
- ↗️ Transaction Service: Автоматичні бонуси
- ↗️ Analytics: Логування подій

---

### `controllers/transaction_controller.py` - Transaction Controller
```python
Відповідальність: Централізоване управління фінансовими операціями
```

**Головні функції:**
```python
def process_user_reward_route():
    # POST /api/transactions/reward
    # Централізована обробка будь-якої винагороди

def process_user_spending_route():
    # POST /api/transactions/spend
    # Обробка витрат з перевіркою балансу

def get_user_transaction_history_route():
    # GET /api/transactions/user/{telegram_id}/history
    # Повна історія фінансових операцій

def get_user_balance_summary_route():
    # GET /api/transactions/user/{telegram_id}/summary
    # Зведення балансу з аналітикою
```

---

### `controllers/analytics_controller.py` - Analytics Controller
```python
Відповідальність: Збір та обробка аналітичних даних
```

**Головні функції:**
```python
def track_event_route():
    # POST /api/analytics/event
    # Відстеження окремої аналітичної події

def track_batch_events_route():
    # POST /api/analytics/batch
    # Пакетне відстеження подій

def get_user_analytics_route():
    # GET /api/analytics/user/{telegram_id}
    # Аналітика конкретного користувача

def get_summary_stats_route():
    # GET /api/analytics/summary
    # Загальна статистика системи
```

---

### `controllers/verification_controller.py` - Verification Controller
```python
Відповідальність: Верифікація соціальних завдань
```

**Головні функції:**
```python
def start_verification_route():
    # POST /api/verification/start
    # Початок процесу верифікації

def check_verification_status_route():
    # GET /api/verification/status/{telegram_id}/{task_id}
    # Перевірка статусу верифікації

def complete_verification_route():
    # POST /api/verification/complete
    # Ручне завершення верифікації
```

---

## 🛣️ ROUTES LAYER - HTTP API Endpoints

### `routes/__init__.py` - Routes Coordinator
```python
Відповідальність: Централізована реєстрація всіх маршрутів
```

**Blueprint Registration:**
```python
def register_all_routes(app: Flask):
    """
    Реєстрація всіх blueprints у Flask додатку
    """
    app.register_blueprint(auth_routes, url_prefix='/api/auth')
    app.register_blueprint(user_routes, url_prefix='/api/user')
    app.register_blueprint(daily_routes, url_prefix='/api/daily')
    app.register_blueprint(flex_routes, url_prefix='/api/flex')
    app.register_blueprint(tasks_routes, url_prefix='/api/tasks')
    app.register_blueprint(wallet_routes, url_prefix='/api/wallet')
    app.register_blueprint(transaction_routes, url_prefix='/api/transactions')
    app.register_blueprint(analytics_routes, url_prefix='/api/analytics')
    app.register_blueprint(verification_routes, url_prefix='/api/verification')
```

---

### `routes/auth_routes.py` - Authentication Routes
```python
Відповідальність: HTTP маршруті для авторизації
```

**Маршрути:**
```python
from flask import Blueprint
from ..controllers.auth_controller import *

auth_routes = Blueprint('auth', __name__)

@auth_routes.route('/validate-telegram', methods=['POST'])
@public_endpoint(max_requests=20)
@validate_json(required_fields=['initData'])
def validate_telegram():
    return validate_telegram_route()

@auth_routes.route('/refresh-token', methods=['POST'])
@require_auth
@rate_limit(max_requests=10, window_seconds=300)
def refresh_token():
    return refresh_token_route()

@auth_routes.route('/validate-token', methods=['GET'])
@require_auth
def validate_token():
    return validate_token_route()

@auth_routes.route('/logout', methods=['POST'])
@require_auth
def logout():
    return logout_route()

@auth_routes.route('/status', methods=['GET'])
@public_endpoint(max_requests=50)
def auth_status():
    return get_auth_status_route()
```

---

### `routes/daily_routes.py` - Daily Bonus Routes
```python
Відповідальність: API для щоденних бонусів
```

**Маршрути:**
```python
daily_routes = Blueprint('daily', __name__)

@daily_routes.route('/status/<telegram_id>', methods=['GET'])
@secure_endpoint(max_requests=30)
@validate_telegram_id
def get_daily_status(telegram_id):
    return get_daily_status_route()

@daily_routes.route('/claim/<telegram_id>', methods=['POST'])
@secure_endpoint(max_requests=5)
@validate_telegram_id
def claim_daily_bonus(telegram_id):
    return claim_daily_bonus_route()

@daily_routes.route('/history/<telegram_id>', methods=['GET'])
@secure_endpoint(max_requests=20)
@validate_telegram_id
def get_daily_history(telegram_id):
    return get_daily_history_route()

@daily_routes.route('/preview/<telegram_id>', methods=['GET'])
@secure_endpoint(max_requests=30)
@validate_telegram_id
def get_reward_preview(telegram_id):
    return calculate_reward_for_day_route()
```

---

### `routes/tasks_routes.py` - Tasks Routes
```python
Відповідальність: API для системи завдань
```

**Маршрути:**
```python
tasks_routes = Blueprint('tasks', __name__)

@tasks_routes.route('/list/<telegram_id>', methods=['GET'])
@secure_endpoint(max_requests=50)
@validate_telegram_id
def get_tasks_list(telegram_id):
    return get_tasks_list_route()

@tasks_routes.route('/details/<task_id>', methods=['GET'])
@secure_endpoint(max_requests=100)
def get_task_details(task_id):
    return get_task_details_route()

@tasks_routes.route('/start/<telegram_id>/<task_id>', methods=['POST'])
@secure_endpoint(max_requests=20)
@validate_telegram_id
def start_task(telegram_id, task_id):
    return start_task_route()

@tasks_routes.route('/verify/<telegram_id>/<task_id>', methods=['POST'])
@secure_endpoint(max_requests=10)
@validate_telegram_id
def verify_task(telegram_id, task_id):
    return verify_task_route()

@tasks_routes.route('/progress/<telegram_id>', methods=['GET'])
@secure_endpoint(max_requests=30)
@validate_telegram_id
def get_task_progress(telegram_id):
    return get_user_task_progress_route()

@tasks_routes.route('/create', methods=['POST'])
@admin_required
@validate_json(required_fields=['title', 'type', 'reward'])
def create_task():
    return create_task_route()
```

---

## 🛠️ UTILS LAYER - Cross-cutting Concerns

### `utils/__init__.py` - Utils Coordinator
```python
Відповідальність: Ініціалізація утиліт
```

---

### `utils/constants.py` - System Constants
```python
Відповідальність: Централізовані константи системи
```

**Категорії констант:**
```python
# Environment Configuration
ENVIRONMENT = os.getenv('ENVIRONMENT', 'development')
DEBUG = ENVIRONMENT == 'development'
PRODUCTION = ENVIRONMENT == 'production'

# Database Configuration
SUPABASE_URL = os.getenv('SUPABASE_URL')
SUPABASE_ANON_KEY = os.getenv('SUPABASE_ANON_KEY')
SUPABASE_SERVICE_KEY = os.getenv('SUPABASE_SERVICE_KEY')

# Security & JWT
JWT_SECRET_KEY = os.getenv('JWT_SECRET_KEY')
JWT_EXPIRATION_DAYS = 7
SECRET_KEY = os.getenv('SECRET_KEY')

# Telegram Configuration
TELEGRAM_BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
TELEGRAM_BOT_USERNAME = os.getenv('TELEGRAM_BOT_USERNAME')
TELEGRAM_WEBHOOK_SECRET = os.getenv('TELEGRAM_WEBHOOK_SECRET')

# TON Blockchain
TON_API_KEY = os.getenv('TON_API_KEY')
TON_NETWORK = os.getenv('TON_NETWORK', 'mainnet')
FLEX_CONTRACT_ADDRESS = os.getenv('FLEX_CONTRACT_ADDRESS')

# FLEX System Configuration
FLEX_LEVELS_CONFIG = {
    "Bronze": {"required_flex": 10000, "reward_winix": 25, "reward_tickets": 1},
    "Silver": {"required_flex": 50000, "reward_winix": 75, "reward_tickets": 2},
    "Gold": {"required_flex": 100000, "reward_winix": 150, "reward_tickets": 4},
    "Platinum": {"required_flex": 250000, "reward_winix": 300, "reward_tickets": 8},
    "Diamond": {"required_flex": 500000, "reward_winix": 500, "reward_tickets": 15}
}

# Daily Bonus Configuration
DAILY_BONUS_BASE_WINIX = 20
DAILY_BONUS_SPECIAL_DAYS = {7: 1, 14: 2, 21: 3, 30: 10}  # day: tickets
DAILY_BONUS_COOLDOWN_HOURS = 20
DAILY_BONUS_MAX_STREAK_RESET_HOURS = 44

# Task Rewards Configuration
TASK_REWARDS_CONFIG = {
    'telegram_subscribe': {'winix': 50, 'tickets': 2},
    'youtube_subscribe': {'winix': 75, 'tickets': 3},
    'twitter_follow': {'winix': 40, 'tickets': 1},
    'discord_join': {'winix': 60, 'tickets': 2},
    'partner': {'winix': 100, 'tickets': 5}
}

# Wallet Configuration
WALLET_CONNECTION_BONUS_WINIX = 100
WALLET_CONNECTION_BONUS_TICKETS = 5
WALLET_VERIFICATION_BONUS_WINIX = 50
WALLET_VERIFICATION_BONUS_TICKETS = 2

# Cache Configuration
CACHE_ENABLED = os.getenv('CACHE_ENABLED', 'true').lower() == 'true'
REDIS_HOST = os.getenv('REDIS_HOST', 'localhost')
REDIS_PORT = int(os.getenv('REDIS_PORT', 6379))
CACHE_DEFAULT_TTL = 300  # 5 minutes

# Rate Limiting
RATE_LIMIT_ENABLED = os.getenv('RATE_LIMIT_ENABLED', 'true').lower() == 'true'
RATE_LIMIT_STORAGE = os.getenv('RATE_LIMIT_STORAGE', 'memory')
DEFAULT_RATE_LIMIT = 100  # requests per minute

# Currency Configuration
CURRENCY_WINIX = "winix"
CURRENCY_TICKETS = "tickets"
CURRENCY_FLEX = "flex"

# Error Messages
ERROR_MESSAGES = {
    'INVALID_TELEGRAM_ID': 'Invalid Telegram ID format',
    'USER_NOT_FOUND': 'User not found',
    'INSUFFICIENT_BALANCE': 'Insufficient balance',
    'TASK_NOT_FOUND': 'Task not found',
    'TASK_ALREADY_COMPLETED': 'Task already completed',
    'WALLET_NOT_CONNECTED': 'Wallet not connected',
    'INVALID_WALLET_ADDRESS': 'Invalid wallet address',
    'COOLDOWN_ACTIVE': 'Cooldown period is active',
    'VERIFICATION_FAILED': 'Verification failed',
    'INTERNAL_SERVER_ERROR': 'Internal server error'
}

# API Configuration
API_VERSION = "v1"
MAX_PAGE_SIZE = 100
DEFAULT_PAGE_SIZE = 20
REQUEST_TIMEOUT = 30

# Logging Configuration
LOG_LEVEL = os.getenv('LOG_LEVEL', 'INFO')
LOG_FORMAT = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
LOG_FILE_MAX_SIZE = 10 * 1024 * 1024  # 10MB
LOG_FILE_BACKUP_COUNT = 5
```

---

### `utils/validators.py` - Data Validation
```python
Відповідальність: Валідація всіх типів даних
```

**Основні функції:**
```python
import hashlib
import hmac
import re
from urllib.parse import parse_qsl
from typing import Dict, Any, Optional

def validate_telegram_webapp_data(init_data: str, bot_token: str) -> Dict[str, Any]:
    """
    Валідація Telegram WebApp initData з HMAC-SHA256 перевіркою
    """
    try:
        # Парсинг query string
        parsed_data = dict(parse_qsl(init_data))

        # Отримання hash з даних
        received_hash = parsed_data.pop('hash', '')
        if not received_hash:
            return {'valid': False, 'error': 'Hash not found'}

        # Створення data-check-string
        data_check_string = '\n'.join([
            f"{key}={value}" for key, value in sorted(parsed_data.items())
        ])

        # Створення secret key
        secret_key = hmac.new(
            "WebAppData".encode(),
            bot_token.encode(),
            hashlib.sha256
        ).digest()

        # Обчислення hash
        calculated_hash = hmac.new(
            secret_key,
            data_check_string.encode(),
            hashlib.sha256
        ).hexdigest()

        # Порівняння hash
        if not hmac.compare_digest(received_hash, calculated_hash):
            return {'valid': False, 'error': 'Invalid hash'}

        # Перевірка auth_date (не старше 24 годин)
        auth_date = int(parsed_data.get('auth_date', 0))
        current_time = time.time()

        if current_time - auth_date > 86400:  # 24 години
            return {'valid': False, 'error': 'Data too old'}

        # Парсинг user data
        user_data = json.loads(parsed_data.get('user', '{}'))

        return {
            'valid': True,
            'user': user_data,
            'auth_date': auth_date,
            'parsed_data': parsed_data
        }

    except Exception as e:
        return {'valid': False, 'error': f'Validation error: {str(e)}'}

def validate_telegram_id(telegram_id: Any) -> Optional[int]:
    """
    Валідація Telegram ID
    """
    try:
        # Конвертація в int
        id_int = int(telegram_id)

        # Перевірка діапазону (Telegram IDs завжди позитивні)
        if id_int <= 0:
            return None

        # Перевірка максимального значення
        if id_int > 2**63 - 1:  # int64 max
            return None

        return id_int

    except (ValueError, TypeError):
        return None

def validate_username(username: str) -> bool:
    """
    Валідація Telegram username
    """
    if not username:
        return True  # Username може бути порожнім

    # Telegram username rules
    pattern = r'^[a-zA-Z0-9_]{5,32}
    return bool(re.match(pattern, username))

def validate_wallet_address(address: str) -> bool:
    """
    Валідація TON wallet address
    """
    if not address:
        return False

    # TON address format: EQ... або UQ... (48 символів base64)
    if not (address.startswith('EQ') or address.startswith('UQ')):
        return False

    if len(address) != 48:
        return False

    # Базова перевірка base64
    try:
        import base64
        base64.b64decode(address[2:] + '==')  # Add padding
        return True
    except:
        return False

def validate_reward_amount(amount: Any, currency: str) -> bool:
    """
    Валідація суми винагороди
    """
    try:
        amount_int = int(amount)

        # Перевірка на негативні значення
        if amount_int < 0:
            return False

        # Перевірка максимальних лімітів
        if currency == CURRENCY_WINIX and amount_int > 1000000:  # 1M WINIX max
            return False

        if currency == CURRENCY_TICKETS and amount_int > 1000:  # 1K tickets max
            return False

        return True

    except (ValueError, TypeError):
        return False

def validate_task_type(task_type: str) -> bool:
    """
    Валідація типу завдання
    """
    valid_types = [
        'telegram_subscribe', 'telegram_bot_start',
        'youtube_subscribe', 'twitter_follow',
        'discord_join', 'social_share',
        'limited_time', 'partner', 'daily_check'
    ]
    return task_type in valid_types

def validate_url(url: str) -> bool:
    """
    Валідація URL
    """
    url_pattern = re.compile(
        r'^https?://'  # http:// or https://
        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+[A-Z]{2,6}\.?|'  # domain...
        r'localhost|'  # localhost...
        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})'  # ...or ip
        r'(?::\d+)?'  # optional port
        r'(?:/?|[/?]\S+), re.IGNORECASE)

    return bool(url_pattern.match(url))

def sanitize_string(value: str, max_length: int = 255) -> str:
    """
    Санітизація рядка
    """
    if not isinstance(value, str):
        return ""

    # Видалення небезпечних символів
    sanitized = re.sub(r'[<>"\']', '', value)

    # Обрізання до максимальної довжини
    sanitized = sanitized[:max_length]

    # Видалення зайвих пробілів
    sanitized = sanitized.strip()

    return sanitized

def validate_json_schema(data: Dict[str, Any], required_fields: List[str]) -> Dict[str, Any]:
    """
    Валідація JSON schema
    """
    errors = []

    for field in required_fields:
        if field not in data:
            errors.append(f"Missing required field: {field}")
        elif data[field] is None:
            errors.append(f"Field cannot be null: {field}")

    return {
        'valid': len(errors) == 0,
        'errors': errors
    }
```

---

### `utils/decorators.py` - Security & Validation Decorators
```python
Відповідальність: Декоратори для безпеки, авторизації та валідації
```

**Основні декоратори:**
```python
import functools
import time
import jwt
from flask import request, jsonify, g
from typing import List, Optional, Callable, Dict, Any

def require_auth(validate_ip: bool = False, require_fresh_token: bool = False):
    """
    Декоратор для обов'язкової авторизації
    """
    def decorator(f):
        @functools.wraps(f)
        def decorated_function(*args, **kwargs):
            # Отримання токену з заголовка
            auth_header = request.headers.get('Authorization')
            if not auth_header or not auth_header.startswith('Bearer '):
                return jsonify({'error': 'Authorization header required'}), 401

            token = auth_header.split(' ')[1]

            # Декодування та валідація токену
            token_result = decode_jwt_token(token)
            if not token_result['valid']:
                return jsonify({'error': token_result['error']}), 401

            payload = token_result['payload']

            # Перевірка свіжості токену
            if require_fresh_token:
                issued_at = payload.get('iat', 0)
                if time.time() - issued_at > 3600:  # 1 година
                    return jsonify({'error': 'Token too old, refresh required'}), 401

            # Валідація IP (якщо увімкнено)
            if validate_ip:
                stored_ip = payload.get('ip')
                current_ip = request.remote_addr
                if stored_ip and stored_ip != current_ip:
                    return jsonify({'error': 'IP address mismatch'}), 401

            # Збереження даних користувача в контексті
            g.current_user = {
                'user_id': payload.get('user_id'),
                'telegram_id': payload.get('telegram_id'),
                'username': payload.get('username')
            }

            return f(*args, **kwargs)
        return decorated_function
    return decorator

def optional_auth(f):
    """
    Декоратор для опціональної авторизації
    """
    @functools.wraps(f)
    def decorated_function(*args, **kwargs):
        auth_header = request.headers.get('Authorization')

        if auth_header and auth_header.startswith('Bearer '):
            token = auth_header.split(' ')[1]
            token_result = decode_jwt_token(token)

            if token_result['valid']:
                g.current_user = {
                    'user_id': token_result['payload'].get('user_id'),
                    'telegram_id': token_result['payload'].get('telegram_id'),
                    'username': token_result['payload'].get('username')
                }
            else:
                g.current_user = None
        else:
            g.current_user = None

        return f(*args, **kwargs)
    return decorated_function

def rate_limit(max_requests: int = 60, window_seconds: int = 60, scope: str = 'ip'):
    """
    Декоратор для rate limiting
    """
    def decorator(f):
        @functools.wraps(f)
        def decorated_function(*args, **kwargs):
            # Визначення ключа для rate limiting
            if scope == 'ip':
                key = f"rate_limit:{request.remote_addr}:{f.__name__}"
            elif scope == 'user' and hasattr(g, 'current_user') and g.current_user:
                key = f"rate_limit:user:{g.current_user['telegram_id']}:{f.__name__}"
            else:
                key = f"rate_limit:global:{f.__name__}"

            # Перевірка rate limit через cache
            current_count = cache_manager.get(key, 0)

            if current_count >= max_requests:
                return jsonify({
                    'error': 'Rate limit exceeded',
                    'retry_after': window_seconds
                }), 429

            # Інкремент лічильника
            cache_manager.set(key, current_count + 1, window_seconds)

            return f(*args, **kwargs)
        return decorated_function
    return decorator

def validate_json(required_fields: List[str] = None, optional_fields: List[str] = None):
    """
    Декоратор для валідації JSON даних
    """
    def decorator(f):
        @functools.wraps(f)
        def decorated_function(*args, **kwargs):
            if not request.is_json:
                return jsonify({'error': 'Content-Type must be application/json'}), 400

            data = request.get_json()
            if not data:
                return jsonify({'error': 'Invalid JSON data'}), 400

            # Перевірка обов'язкових полів
            if required_fields:
                missing_fields = [field for field in required_fields if field not in data]
                if missing_fields:
                    return jsonify({
                        'error': 'Missing required fields',
                        'missing_fields': missing_fields
                    }), 400

            # Валідація типів даних (якщо задано)
            for field in required_fields or []:
                if field in data and data[field] is None:
                    return jsonify({
                        'error': f'Field {field} cannot be null'
                    }), 400

            return f(*args, **kwargs)
        return decorated_function
    return decorator

def validate_telegram_id(f):
    """
    Декоратор для валідації Telegram ID в URL параметрах
    """
    @functools.wraps(f)
    def decorated_function(*args, **kwargs):
        telegram_id = request.view_args.get('telegram_id')

        if telegram_id:
            validated_id = validate_telegram_id(telegram_id)
            if not validated_id:
                return jsonify({'error': 'Invalid telegram_id format'}), 400

            # Заміна в kwargs для подальшого використання
            kwargs['telegram_id'] = validated_id

        return f(*args, **kwargs)
    return decorated_function

def handle_errors(f):
    """
    Декоратор для централізованої обробки помилок
    """
    @functools.wraps(f)
    def decorated_function(*args, **kwargs):
        try:
            return f(*args, **kwargs)
        except ValidationError as e:
            return jsonify({'error': str(e)}), 400
        except AuthenticationError as e:
            return jsonify({'error': str(e)}), 401
        except AuthorizationError as e:
            return jsonify({'error': str(e)}), 403
        except NotFoundError as e:
            return jsonify({'error': str(e)}), 404
        except Exception as e:
            logger.error(f"Unhandled error in {f.__name__}: {e}", exc_info=True)
            return jsonify({'error': 'Internal server error'}), 500
    return decorated_function

def security_headers(f):
    """
    Декоратор для додавання security headers
    """
    @functools.wraps(f)
    def decorated_function(*args, **kwargs):
        response = make_response(f(*args, **kwargs))

        response.headers['X-Content-Type-Options'] = 'nosniff'
        response.headers['X-Frame-Options'] = 'DENY'
        response.headers['X-XSS-Protection'] = '1; mode=block'
        response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'
        response.headers['Content-Security-Policy'] = "default-src 'self'"

        return response
    return decorated_function

# Комбіновані декоратори для зручності
def secure_endpoint(max_requests: int = 30, window_seconds: int = 60, require_fresh_token: bool = False):
    """
    Комбінований декоратор для захищених endpoint'ів
    """
    def decorator(f):
        @security_headers
        @handle_errors
        @rate_limit(max_requests, window_seconds)
        @require_auth(require_fresh_token=require_fresh_token)
        @functools.wraps(f)
        def decorated_function(*args, **kwargs):
            return f(*args, **kwargs)
        return decorated_function
    return decorator

def public_endpoint(max_requests: int = 60, window_seconds: int = 60):
    """
    Комбінований декоратор для публічних endpoint'ів
    """
    def decorator(f):
        @security_headers
        @handle_errors
        @rate_limit(max_requests, window_seconds)
        @optional_auth
        @functools.wraps(f)
        def decorated_function(*args, **kwargs):
            return f(*args, **kwargs)
        return decorated_function
    return decorator
```

---

### `utils/cache.py` - Caching System
```python
Відповідальність: Багаторівневе кешування з підтримкою Redis та Memory
```

**Архітектура кешування:**
```python
import time
import json
import redis
from typing import Any, Optional, Dict
from enum import Enum

class CacheType(Enum):
    MEMORY = "memory"
    REDIS = "redis"
    HYBRID = "hybrid"

class CachePolicy(Enum):
    LRU = "lru"          # Least Recently Used
    LFU = "lfu"          # Least Frequently Used
    TTL = "ttl"          # Time To Live
    FIFO = "fifo"        # First In First Out

class CacheManager:
    """
    Централізований менеджер кешування
    """
    def __init__(self):
        self.memory_cache = MemoryCache()
        self.redis_cache = RedisCache() if CACHE_ENABLED else None

    def get(self, key: str, default: Any = None, cache_type: CacheType = CacheType.HYBRID) -> Any:
        """
        Отримання значення з кешу
        """
        if cache_type in [CacheType.MEMORY, CacheType.HYBRID]:
            # Спроба отримання з memory cache
            value = self.memory_cache.get(key)
            if value is not None:
                return value

        if cache_type in [CacheType.REDIS, CacheType.HYBRID] and self.redis_cache:
            # Спроба отримання з Redis
            value = self.redis_cache.get(key)
            if value is not None:
                # Збереження в memory cache для швидшого доступу
                if cache_type == CacheType.HYBRID:
                    self.memory_cache.set(key, value, ttl=60)  # 1 хвилина в memory
                return value

        return default

    def set(self, key: str, value: Any, ttl: int = 300, cache_type: CacheType = CacheType.HYBRID) -> bool:
        """
        Збереження значення в кеш
        """
        success = True

        if cache_type in [CacheType.MEMORY, CacheType.HYBRID]:
            success &= self.memory_cache.set(key, value, ttl)

        if cache_type in [CacheType.REDIS, CacheType.HYBRID] and self.redis_cache:
            success &= self.redis_cache.set(key, value, ttl)

        return success

    def delete(self, key: str, cache_type: CacheType = CacheType.HYBRID) -> bool:
        """
        Видалення ключа з кешу
        """
        success = True

        if cache_type in [CacheType.MEMORY, CacheType.HYBRID]:
            success &= self.memory_cache.delete(key)

        if cache_type in [CacheType.REDIS, CacheType.HYBRID] and self.redis_cache:
            success &= self.redis_cache.delete(key)

        return success

    def clear_pattern(self, pattern: str) -> int:
        """
        Очищення всіх ключів за шаблоном
        """
        cleared = 0
        cleared += self.memory_cache.clear_pattern(pattern)

        if self.redis_cache:
            cleared += self.redis_cache.clear_pattern(pattern)

        return cleared

class MemoryCache:
    """
    In-memory кеш з LRU policy
    """
    def __init__(self, max_size: int = 1000):
        self.max_size = max_size
        self.cache: Dict[str, Dict] = {}
        self.access_order: List[str] = []

    def get(self, key: str) -> Any:
        if key not in self.cache:
            return None

        item = self.cache[key]

        # Перевірка TTL
        if item['expires_at'] and time.time() > item['expires_at']:
            self.delete(key)
            return None

        # Оновлення порядку доступу (LRU)
        self.access_order.remove(key)
        self.access_order.append(key)

        return item['value']

    def set(self, key: str, value: Any, ttl: int = 300) -> bool:
        try:
            expires_at = time.time() + ttl if ttl > 0 else None

            # Якщо кеш повний, видаляємо найстаріший елемент
            if len(self.cache) >= self.max_size and key not in self.cache:
                oldest_key = self.access_order.pop(0)
                del self.cache[oldest_key]

            # Збереження
            self.cache[key] = {
                'value': value,
                'created_at': time.time(),
                'expires_at': expires_at
            }

            # Оновлення порядку доступу
            if key in self.access_order:
                self.access_order.remove(key)
            self.access_order.append(key)

            return True
        except Exception as e:
            logger.error(f"Memory cache set error: {e}")
            return False

    def delete(self, key: str) -> bool:
        if key in self.cache:
            del self.cache[key]
            if key in self.access_order:
                self.access_order.remove(key)
            return True
        return False

    def clear_pattern(self, pattern: str) -> int:
        """
        Очищення ключів за шаблоном (простий wildcard)
        """
        import fnmatch
        cleared = 0

        keys_to_delete = [
            key for key in self.cache.keys()
            if fnmatch.fnmatch(key, pattern)
        ]

        for key in keys_to_delete:
            if self.delete(key):
                cleared += 1

        return cleared

class RedisCache:
    """
    Redis кеш для розподіленого зберігання
    """
    def __init__(self):
        try:
            self.redis_client = redis.Redis(
                host=REDIS_HOST,
                port=REDIS_PORT,
                db=0,
                decode_responses=True,
                socket_timeout=5,
                socket_connect_timeout=5
            )
            # Тест підключення
            self.redis_client.ping()
            self.available = True
        except Exception as e:
            logger.error(f"Redis connection failed: {e}")
            self.redis_client = None
            self.available = False

    def get(self, key: str) -> Any:
        if not self.available:
            return None

        try:
            value = self.redis_client.get(key)
            if value:
                return json.loads(value)
            return None
        except Exception as e:
            logger.error(f"Redis get error for key {key}: {e}")
            return None

    def set(self, key: str, value: Any, ttl: int = 300) -> bool:
        if not self.available:
            return False

        try:
            serialized_value = json.dumps(value, default=str)
            return self.redis_client.setex(key, ttl, serialized_value)
        except Exception as e:
            logger.error(f"Redis set error for key {key}: {e}")
            return False

    def delete(self, key: str) -> bool:
        if not self.available:
            return False

        try:
            return bool(self.redis_client.delete(key))
        except Exception as e:
            logger.error(f"Redis delete error for key {key}: {e}")
            return False

    def clear_pattern(self, pattern: str) -> int:
        if not self.available:
            return 0

        try:
            keys = self.redis_client.keys(pattern)
            if keys:
                return self.redis_client.delete(*keys)
            return 0
        except Exception as e:
            logger.error(f"Redis clear pattern error: {e}")
            return 0

# Глобальний інстанс кеш менеджера
cache_manager = CacheManager()

# Декоратор для кешування функцій
def cached(timeout: int = 300, cache_type: CacheType = CacheType.HYBRID, key_prefix: str = ""):
    """
    Декоратор для автоматичного кешування результатів функцій
    """
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            # Генерація ключа кешу
            key_parts = [key_prefix or func.__name__]

            # Додавання аргументів до ключа
            for arg in args:
                key_parts.append(str(arg))

            for k, v in sorted(kwargs.items()):
                key_parts.append(f"{k}:{v}")

            cache_key = ":".join(key_parts)

            # Спроба отримання з кешу
            cached_result = cache_manager.get(cache_key, cache_type=cache_type)
            if cached_result is not None:
                return cached_result

            # Виконання функції та кешування результату
            result = func(*args, **kwargs)
            cache_manager.set(cache_key, result, timeout, cache_type)

            return result
        return wrapper
    return decorator

# Функції для очищення кешу
def clear_user_cache(telegram_id: str):
    """
    Очищення всього кешу користувача
    """
    patterns = [
        f"*user:{telegram_id}*",
        f"*{telegram_id}*",
        f"*telegram_id:{telegram_id}*"
    ]

    for pattern in patterns:
        cache_manager.clear_pattern(pattern)

def clear_winix_cache(telegram_id: str = None):
    """
    Очищення кешу WINIX системи
    """
    if telegram_id:
        patterns = [
            f"daily_bonus:{telegram_id}*",
            f"flex_balance:{telegram_id}*",
            f"task_progress:{telegram_id}*",
            f"wallet_info:{telegram_id}*"
        ]
    else:
        patterns = [
            "daily_bonus:*",
            "flex_balance:*",
            "task_progress:*",
            "wallet_info:*"
        ]

    for pattern in patterns:
        cache_manager.clear_pattern(pattern)
```

---

Ця архітектура забезпечує надійну, масштабовану та безпечну роботу backend системи завдань WINIX з повною підтримкою всіх функцій: аналітики, щоденних бонусів, FLEX токенів, завдань, транзакцій та TON гаманців! 🚀

---

## 🛡️ MIDDLEWARE LAYER - Cross-cutting Infrastructure

### `middleware/__init__.py` - Middleware Coordinator
```python
Відповідальність: Централізоване управління middleware компонентами
```

**Функціональність:**
- 📋 Middleware registration and initialization
- 🏥 Health monitoring for middleware services
- ⚙️ Configuration management
- 🔄 Request/response pipeline coordination

---

### `middleware/logger.py` - Advanced Logging System
```python
Відповідальність: Структуроване логування, метрики, моніторинг
```

**Архітектура логування:**
```python
import logging
import json
import time
import psutil
import asyncio
from datetime import datetime
from typing import Dict, Any, Optional
from prometheus_client import Counter, Histogram, Gauge

class StructuredLogger:
    """
    Структурований JSON logger з контекстом
    """
    def __init__(self, name: str):
        self.logger = logging.getLogger(name)
        self.context: Dict[str, Any] = {}

        # JSON Formatter
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )

        # File Handler з ротацією
        from logging.handlers import RotatingFileHandler
        file_handler = RotatingFileHandler(
            'logs/winix.log',
            maxBytes=LOG_FILE_MAX_SIZE,
            backupCount=LOG_FILE_BACKUP_COUNT
        )
        file_handler.setFormatter(formatter)

        # Console Handler
        console_handler = logging.StreamHandler()
        console_handler.setFormatter(formatter)

        self.logger.addHandler(file_handler)
        self.logger.addHandler(console_handler)
        self.logger.setLevel(getattr(logging, LOG_LEVEL))

    def set_context(self, **kwargs):
        """Встановлення контексту для всіх наступних логів"""
        self.context.update(kwargs)

    def clear_context(self):
        """Очищення контексту"""
        self.context.clear()

    def _format_message(self, message: str, extra: Dict[str, Any] = None) -> str:
        """Форматування повідомлення в JSON"""
        log_data = {
            'timestamp': datetime.utcnow().isoformat(),
            'message': message,
            'context': self.context.copy()
        }

        if extra:
            log_data['extra'] = extra

        return json.dumps(log_data, default=str)

    def info(self, message: str, **kwargs):
        self.logger.info(self._format_message(message, kwargs))

    def warning(self, message: str, **kwargs):
        self.logger.warning(self._format_message(message, kwargs))

    def error(self, message: str, **kwargs):
        self.logger.error(self._format_message(message, kwargs))

    def debug(self, message: str, **kwargs):
        self.logger.debug(self._format_message(message, kwargs))

class MetricsCollector:
    """
    Збирач метрик Prometheus
    """
    def __init__(self):
        # Request metrics
        self.request_count = Counter(
            'winix_requests_total',
            'Total HTTP requests',
            ['method', 'endpoint', 'status']
        )

        self.request_duration = Histogram(
            'winix_request_duration_seconds',
            'HTTP request duration',
            ['method', 'endpoint']
        )

        # Business metrics
        self.daily_bonus_claims = Counter(
            'winix_daily_bonus_claims_total',
            'Total daily bonus claims'
        )

        self.task_completions = Counter(
            'winix_task_completions_total',
            'Total task completions',
            ['task_type']
        )

        self.flex_claims = Counter(
            'winix_flex_claims_total',
            'Total FLEX claims',
            ['level']
        )

        # System metrics
        self.active_users = Gauge(
            'winix_active_users',
            'Number of active users'
        )

        self.system_cpu = Gauge(
            'winix_system_cpu_percent',
            'System CPU usage percent'
        )

        self.system_memory = Gauge(
            'winix_system_memory_percent',
            'System memory usage percent'
        )

    def record_request(self, method: str, endpoint: str, status: int, duration: float):
        """Запис метрики HTTP запиту"""
        self.request_count.labels(method=method, endpoint=endpoint, status=status).inc()
        self.request_duration.labels(method=method, endpoint=endpoint).observe(duration)

    def record_daily_bonus_claim(self):
        """Запис отримання щоденного бонусу"""
        self.daily_bonus_claims.inc()

    def record_task_completion(self, task_type: str):
        """Запис завершення завдання"""
        self.task_completions.labels(task_type=task_type).inc()

    def record_flex_claim(self, level: str):
        """Запис отримання FLEX винагороди"""
        self.flex_claims.labels(level=level).inc()

    def update_system_metrics(self):
        """Оновлення системних метрик"""
        self.system_cpu.set(psutil.cpu_percent())
        self.system_memory.set(psutil.virtual_memory().percent)

class AlertManager:
    """
    Менеджер алертів та нотифікацій
    """
    def __init__(self):
        self.alerts: Dict[str, Dict] = {}
        self.alert_rules = {
            'high_error_rate': {
                'threshold': 0.1,  # 10% error rate
                'window': 300,     # 5 minutes
                'severity': 'critical'
            },
            'high_cpu_usage': {
                'threshold': 80,   # 80% CPU
                'window': 300,
                'severity': 'warning'
            },
            'slow_requests': {
                'threshold': 5.0,  # 5 seconds
                'window': 300,
                'severity': 'warning'
            }
        }

    def check_alert_conditions(self, metrics: Dict[str, float]):
        """Перевірка умов алертів"""
        for rule_name, rule in self.alert_rules.items():
            if self._should_trigger_alert(rule_name, metrics, rule):
                self._trigger_alert(rule_name, metrics[rule_name], rule)

    def _should_trigger_alert(self, rule_name: str, metrics: Dict, rule: Dict) -> bool:
        """Перевірка чи треба тригерити алерт"""
        current_value = metrics.get(rule_name, 0)
        return current_value > rule['threshold']

    def _trigger_alert(self, rule_name: str, value: float, rule: Dict):
        """Тригер алерту"""
        alert_data = {
            'rule': rule_name,
            'value': value,
            'threshold': rule['threshold'],
            'severity': rule['severity'],
            'timestamp': time.time()
        }

        # Збереження алерту
        self.alerts[rule_name] = alert_data

        # Логування
        logger.error(f"ALERT TRIGGERED: {rule_name}", extra=alert_data)

        # Відправка нотифікації (webhook, email, etc.)
        asyncio.create_task(self._send_alert_notification(alert_data))

    async def _send_alert_notification(self, alert_data: Dict):
        """Відправка алерту"""
        try:
            # Webhook notification
            webhook_url = os.getenv('ALERT_WEBHOOK_URL')
            if webhook_url:
                async with aiohttp.ClientSession() as session:
                    await session.post(webhook_url, json=alert_data)
        except Exception as e:
            logger.error(f"Failed to send alert notification: {e}")

class MonitoringManager:
    """
    Центральний менеджер моніторингу
    """
    def __init__(self):
        self.logger = StructuredLogger('winix.monitoring')
        self.metrics = MetricsCollector()
        self.alerts = AlertManager()
        self.health_checks: Dict[str, Callable] = {}

    def register_health_check(self, name: str, check_func: Callable):
        """Реєстрація health check функції"""
        self.health_checks[name] = check_func

    async def run_health_checks(self) -> Dict[str, Any]:
        """Виконання всіх health checks"""
        results = {}

        for name, check_func in self.health_checks.items():
            try:
                start_time = time.time()
                result = await check_func() if asyncio.iscoroutinefunction(check_func) else check_func()
                duration = time.time() - start_time

                results[name] = {
                    'status': 'healthy' if result else 'unhealthy',
                    'duration': duration,
                    'timestamp': time.time()
                }
            except Exception as e:
                results[name] = {
                    'status': 'error',
                    'error': str(e),
                    'timestamp': time.time()
                }

        return results

    def get_system_status(self) -> Dict[str, Any]:
        """Отримання загального статусу системи"""
        return {
            'uptime': time.time() - self.start_time,
            'cpu_percent': psutil.cpu_percent(),
            'memory_percent': psutil.virtual_memory().percent,
            'disk_percent': psutil.disk_usage('/').percent,
            'active_alerts': len(self.alerts.alerts)
        }

# Request Logging Middleware
class RequestLoggingMiddleware:
    """
    Middleware для логування HTTP запитів
    """
    def __init__(self, app):
        self.app = app
        self.logger = StructuredLogger('winix.requests')
        self.metrics = MetricsCollector()

    def __call__(self, environ, start_response):
        start_time = time.time()

        # Збір інформації про запит
        method = environ['REQUEST_METHOD']
        path = environ['PATH_INFO']
        remote_addr = environ.get('REMOTE_ADDR', 'unknown')
        user_agent = environ.get('HTTP_USER_AGENT', 'unknown')

        # Встановлення контексту логування
        self.logger.set_context(
            method=method,
            path=path,
            remote_addr=remote_addr,
            user_agent=user_agent
        )

        def new_start_response(status, response_headers, exc_info=None):
            # Логування відповіді
            duration = time.time() - start_time
            status_code = int(status.split()[0])

            # Метрики
            self.metrics.record_request(method, path, status_code, duration)

            # Логування
            log_level = 'error' if status_code >= 400 else 'info'
            getattr(self.logger, log_level)(
                f"{method} {path} - {status}",
                duration=duration,
                status_code=status_code
            )

            return start_response(status, response_headers, exc_info)

        return self.app(environ, new_start_response)

# Глобальні інстанси
logger = StructuredLogger('winix')
monitoring_manager = MonitoringManager()
```

**Health Checks Registration:**
```python
# Реєстрація health checks
async def database_health_check():
    """Перевірка здоров'я бази даних"""
    try:
        result = supabase.table('winix').select('id').limit(1).execute()
        return len(result.data) >= 0
    except:
        return False

async def redis_health_check():
    """Перевірка Redis"""
    try:
        return cache_manager.redis_cache.redis_client.ping()
    except:
        return False

async def external_services_health_check():
    """Перевірка зовнішніх сервісів"""
    try:
        # Telegram API
        telegram_ok = await telegram_service.health_check()

        # TON API
        ton_ok = await ton_connect_service.health_check()

        return telegram_ok and ton_ok
    except:
        return False

# Реєстрація
monitoring_manager.register_health_check('database', database_health_check)
monitoring_manager.register_health_check('redis', redis_health_check)
monitoring_manager.register_health_check('external_services', external_services_health_check)
```

---

### `middleware/rate_limiter.py` - Advanced Rate Limiting
```python
Відповідальність: Розподілене rate limiting з різними стратегіями
```

**Архітектура Rate Limiting:**
```python
import time
import hashlib
from typing import Dict, Any, Optional, Tuple
from enum import Enum
from dataclasses import dataclass

class RateLimitStrategy(Enum):
    """Стратегії rate limiting"""
    FIXED_WINDOW = "fixed_window"      # Фіксоване вікно
    SLIDING_WINDOW = "sliding_window"  # Ковзне вікно
    TOKEN_BUCKET = "token_bucket"      # Токен-бакет
    LEAKY_BUCKET = "leaky_bucket"      # Дірявий бакет
    ADAPTIVE = "adaptive"              # Адаптивне обмеження

class RateLimitScope(Enum):
    """Області застосування rate limiting"""
    GLOBAL = "global"       # Глобальні ліміти
    IP = "ip"              # По IP адресі
    USER = "user"          # По користувачу
    ENDPOINT = "endpoint"  # По endpoint'у
    CUSTOM = "custom"      # Кастомні ключі

@dataclass
class RateLimitRule:
    """Правило rate limiting"""
    max_requests: int
    window_seconds: int
    strategy: RateLimitStrategy
    scope: RateLimitScope
    burst_allowance: int = 0  # Дозволені пікові запити

class RateLimitResult:
    """Результат перевірки rate limit"""
    def __init__(self, allowed: bool, remaining: int = 0, reset_time: int = 0, retry_after: int = 0):
        self.allowed = allowed
        self.remaining = remaining
        self.reset_time = reset_time
        self.retry_after = retry_after

class MemoryRateLimiter:
    """
    In-memory rate limiter для локального використання
    """
    def __init__(self):
        self.storage: Dict[str, Dict] = {}
        self.cleanup_interval = 3600  # Очищення кожну годину
        self.last_cleanup = time.time()

    def _cleanup_expired(self):
        """Очищення застарілих записів"""
        current_time = time.time()
        if current_time - self.last_cleanup < self.cleanup_interval:
            return

        expired_keys = []
        for key, data in self.storage.items():
            if data.get('expires_at', 0) < current_time:
                expired_keys.append(key)

        for key in expired_keys:
            del self.storage[key]

        self.last_cleanup = current_time

    def check_rate_limit(self, key: str, rule: RateLimitRule) -> RateLimitResult:
        """Перевірка rate limit"""
        self._cleanup_expired()
        current_time = time.time()

        if rule.strategy == RateLimitStrategy.FIXED_WINDOW:
            return self._fixed_window_check(key, rule, current_time)
        elif rule.strategy == RateLimitStrategy.SLIDING_WINDOW:
            return self._sliding_window_check(key, rule, current_time)
        elif rule.strategy == RateLimitStrategy.TOKEN_BUCKET:
            return self._token_bucket_check(key, rule, current_time)
        else:
            # Fallback до fixed window
            return self._fixed_window_check(key, rule, current_time)

    def _fixed_window_check(self, key: str, rule: RateLimitRule, current_time: float) -> RateLimitResult:
        """Fixed window rate limiting"""
        window_start = int(current_time // rule.window_seconds) * rule.window_seconds
        window_key = f"{key}:{window_start}"

        if window_key not in self.storage:
            self.storage[window_key] = {
                'count': 0,
                'window_start': window_start,
                'expires_at': window_start + rule.window_seconds * 2
            }

        data = self.storage[window_key]

        if data['count'] >= rule.max_requests:
            reset_time = int(window_start + rule.window_seconds)
            retry_after = reset_time - int(current_time)
            return RateLimitResult(False, 0, reset_time, retry_after)

        # Інкремент лічильника
        data['count'] += 1
        remaining = rule.max_requests - data['count']
        reset_time = int(window_start + rule.window_seconds)

        return RateLimitResult(True, remaining, reset_time, 0)

    def _sliding_window_check(self, key: str, rule: RateLimitRule, current_time: float) -> RateLimitResult:
        """Sliding window rate limiting"""
        if key not in self.storage:
            self.storage[key] = {
                'requests': [],
                'expires_at': current_time + rule.window_seconds * 2
            }

        data = self.storage[key]
        requests = data['requests']

        # Видалення застарілих запитів
        cutoff_time = current_time - rule.window_seconds
        data['requests'] = [req_time for req_time in requests if req_time > cutoff_time]

        if len(data['requests']) >= rule.max_requests:
            oldest_request = min(data['requests'])
            retry_after = int(oldest_request + rule.window_seconds - current_time)
            return RateLimitResult(False, 0, 0, max(1, retry_after))

        # Додавання поточного запиту
        data['requests'].append(current_time)
        remaining = rule.max_requests - len(data['requests'])

        return RateLimitResult(True, remaining, 0, 0)

    def _token_bucket_check(self, key: str, rule: RateLimitRule, current_time: float) -> RateLimitResult:
        """Token bucket rate limiting"""
        if key not in self.storage:
            self.storage[key] = {
                'tokens': rule.max_requests,
                'last_refill': current_time,
                'expires_at': current_time + rule.window_seconds * 2
            }

        data = self.storage[key]

        # Поповнення токенів
        time_passed = current_time - data['last_refill']
        tokens_to_add = (time_passed / rule.window_seconds) * rule.max_requests
        data['tokens'] = min(rule.max_requests, data['tokens'] + tokens_to_add)
        data['last_refill'] = current_time

        if data['tokens'] < 1:
            retry_after = int((1 - data['tokens']) * rule.window_seconds / rule.max_requests)
            return RateLimitResult(False, 0, 0, max(1, retry_after))

        # Витрата токену
        data['tokens'] -= 1

        return RateLimitResult(True, int(data['tokens']), 0, 0)

class RedisRateLimiter:
    """
    Redis-based rate limiter для розподіленого використання
    """
    def __init__(self, redis_client):
        self.redis = redis_client
        self.script_sha = None
        self._load_lua_scripts()

    def _load_lua_scripts(self):
        """Завантаження Lua скриптів для атомарних операцій"""
        sliding_window_script = """
        local key = KEYS[1]
        local window = tonumber(ARGV[1])
        local limit = tonumber(ARGV[2])
        local current_time = tonumber(ARGV[3])

        -- Видалення застарілих записів
        redis.call('ZREMRANGEBYSCORE', key, '-inf', current_time - window)

        -- Підрахунок поточних запитів
        local current_requests = redis.call('ZCARD', key)

        if current_requests < limit then
            -- Додавання поточного запиту
            redis.call('ZADD', key, current_time, current_time)
            redis.call('EXPIRE', key, window)
            return {1, limit - current_requests - 1}
        else
            return {0, 0}
        end
        """

        try:
            self.script_sha = self.redis.script_load(sliding_window_script)
        except Exception as e:
            logger.error(f"Failed to load Redis Lua script: {e}")

    def check_rate_limit(self, key: str, rule: RateLimitRule) -> RateLimitResult:
        """Перевірка rate limit через Redis"""
        try:
            if rule.strategy == RateLimitStrategy.SLIDING_WINDOW and self.script_sha:
                return self._redis_sliding_window_check(key, rule)
            else:
                return self._redis_fixed_window_check(key, rule)
        except Exception as e:
            logger.error(f"Redis rate limit check failed: {e}")
            # Fallback - дозволяємо запит при помилці Redis
            return RateLimitResult(True, rule.max_requests, 0, 0)

    def _redis_sliding_window_check(self, key: str, rule: RateLimitRule) -> RateLimitResult:
        """Sliding window через Redis Lua script"""
        current_time = time.time()

        result = self.redis.evalsha(
            self.script_sha, 1, key,
            rule.window_seconds, rule.max_requests, current_time
        )

        allowed = bool(result[0])
        remaining = int(result[1])

        if not allowed:
            # Підрахунок retry_after
            oldest_request = self.redis.zrange(key, 0, 0, withscores=True)
            if oldest_request:
                retry_after = int(oldest_request[0][1] + rule.window_seconds - current_time)
            else:
                retry_after = rule.window_seconds

            return RateLimitResult(False, 0, 0, max(1, retry_after))

        return RateLimitResult(True, remaining, 0, 0)

    def _redis_fixed_window_check(self, key: str, rule: RateLimitRule) -> RateLimitResult:
        """Fixed window через Redis"""
        current_time = time.time()
        window_start = int(current_time // rule.window_seconds) * rule.window_seconds
        window_key = f"{key}:{window_start}"

        pipe = self.redis.pipeline()
        pipe.incr(window_key)
        pipe.expire(window_key, rule.window_seconds)
        results = pipe.execute()

        current_count = results[0]

        if current_count > rule.max_requests:
            reset_time = int(window_start + rule.window_seconds)
            retry_after = reset_time - int(current_time)
            return RateLimitResult(False, 0, reset_time, max(1, retry_after))

        remaining = rule.max_requests - current_count
        reset_time = int(window_start + rule.window_seconds)

        return RateLimitResult(True, remaining, reset_time, 0)

class RateLimitManager:
    """
    Центральний менеджер rate limiting
    """
    def __init__(self):
        self.memory_limiter = MemoryRateLimiter()
        self.redis_limiter = RedisRateLimiter(cache_manager.redis_cache.redis_client) if cache_manager.redis_cache.available else None
        self.rules: Dict[str, RateLimitRule] = {}
        self.global_rules: List[RateLimitRule] = []

        # Налаштування стандартних правил
        self._setup_default_rules()

    def _setup_default_rules(self):
        """Налаштування стандартних правил rate limiting"""
        self.rules.update({
            'auth_login': RateLimitRule(
                max_requests=5,
                window_seconds=300,  # 5 хвилин
                strategy=RateLimitStrategy.SLIDING_WINDOW,
                scope=RateLimitScope.IP
            ),
            'daily_bonus_claim': RateLimitRule(
                max_requests=2,
                window_seconds=86400,  # 24 години
                strategy=RateLimitStrategy.FIXED_WINDOW,
                scope=RateLimitScope.USER
            ),
            'task_verification': RateLimitRule(
                max_requests=10,
                window_seconds=3600,  # 1 година
                strategy=RateLimitStrategy.SLIDING_WINDOW,
                scope=RateLimitScope.USER
            ),
            'wallet_connect': RateLimitRule(
                max_requests=3,
                window_seconds=300,  # 5 хвилин
                strategy=RateLimitStrategy.SLIDING_WINDOW,
                scope=RateLimitScope.USER
            ),
            'api_general': RateLimitRule(
                max_requests=100,
                window_seconds=60,  # 1 хвилина
                strategy=RateLimitStrategy.SLIDING_WINDOW,
                scope=RateLimitScope.IP
            )
        })

    def add_rule(self, name: str, rule: RateLimitRule):
        """Додавання кастомного правила"""
        self.rules[name] = rule

    def check_rate_limit(self, rule_name: str, identifier: str, custom_key: str = None) -> RateLimitResult:
        """
        Перевірка rate limit

        Args:
            rule_name: Назва правила
            identifier: Ідентифікатор (IP, user_id, etc.)
            custom_key: Кастомний ключ для додаткової ідентифікації
        """
        if rule_name not in self.rules:
            logger.warning(f"Unknown rate limit rule: {rule_name}")
            return RateLimitResult(True, 999, 0, 0)

        rule = self.rules[rule_name]

        # Генерація ключа
        key_parts = [rule_name, identifier]
        if custom_key:
            key_parts.append(custom_key)

        key = ":".join(key_parts)
        key_hash = hashlib.md5(key.encode()).hexdigest()

        # Вибір rate limiter
        if self.redis_limiter and RATE_LIMIT_STORAGE == 'redis':
            return self.redis_limiter.check_rate_limit(key_hash, rule)
        else:
            return self.memory_limiter.check_rate_limit(key_hash, rule)

    def get_statistics(self) -> Dict[str, Any]:
        """Статистика rate limiting"""
        return {
            'rules_count': len(self.rules),
            'active_limiters': {
                'memory': True,
                'redis': self.redis_limiter is not None
            },
            'rules': {name: {
                'max_requests': rule.max_requests,
                'window_seconds': rule.window_seconds,
                'strategy': rule.strategy.value,
                'scope': rule.scope.value
            } for name, rule in self.rules.items()}
        }

# Flask Middleware для автоматичного rate limiting
class RateLimitMiddleware:
    """
    Flask middleware для автоматичного застосування rate limiting
    """
    def __init__(self, app, rate_limit_manager: RateLimitManager):
        self.app = app
        self.rate_limiter = rate_limit_manager

        # Мапінг endpoint'ів на правила
        self.endpoint_rules = {
            '/api/auth/validate-telegram': 'auth_login',
            '/api/daily/claim': 'daily_bonus_claim',
            '/api/tasks/verify': 'task_verification',
            '/api/wallet/connect': 'wallet_connect'
        }

    def __call__(self, environ, start_response):
        path = environ['PATH_INFO']
        method = environ['REQUEST_METHOD']
        remote_addr = environ.get('REMOTE_ADDR', 'unknown')

        # Визначення правила для endpoint'у
        rule_name = self.endpoint_rules.get(path, 'api_general')

        # Перевірка rate limit
        result = self.rate_limiter.check_rate_limit(rule_name, remote_addr)

        if not result.allowed:
            # Rate limit перевищено
            response_body = json.dumps({
                'error': 'Rate limit exceeded',
                'retry_after': result.retry_after
            }).encode()

            headers = [
                ('Content-Type', 'application/json'),
                ('Content-Length', str(len(response_body))),
                ('X-RateLimit-Limit', str(self.rate_limiter.rules[rule_name].max_requests)),
                ('X-RateLimit-Remaining', '0'),
                ('X-RateLimit-Reset', str(result.reset_time)),
                ('Retry-After', str(result.retry_after))
            ]

            start_response('429 Too Many Requests', headers)
            return [response_body]

        # Додавання rate limit headers до відповіді
        def new_start_response(status, response_headers, exc_info=None):
            response_headers.extend([
                ('X-RateLimit-Limit', str(self.rate_limiter.rules[rule_name].max_requests)),
                ('X-RateLimit-Remaining', str(result.remaining)),
                ('X-RateLimit-Reset', str(result.reset_time))
            ])
            return start_response(status, response_headers, exc_info)

        return self.app(environ, new_start_response)

# Глобальний інстанс
rate_limit_manager = RateLimitManager()
```

---

## 🔗 Повні діаграми взаємодій компонентів

### 1. **Повний User Journey Flow**
```mermaid
graph TD
    A[User Opens Mini App] --> B[Telegram WebApp Init]
    B --> C[POST /api/auth/validate-telegram]
    C --> D[auth_controller.validate_telegram()]
    D --> E[telegram_service.validate_webapp_data()]
    E --> F[UserQuest.get_or_create_user()]
    F --> G[JWT Token Generation]
    G --> H[Welcome Bonus via Transaction Service]
    H --> I[Analytics Event Logging]
    I --> J[Response: User + Token]

    J --> K[Daily Bonus Check]
    K --> L[GET /api/daily/status]
    L --> M[daily_controller.get_status()]
    M --> N[DailyBonusManager.get_user_status()]
    N --> O[RewardCalculator.preview_reward()]
    O --> P[Response: Can Claim Status]

    P --> Q[User Claims Bonus]
    Q --> R[POST /api/daily/claim]
    R --> S[daily_controller.claim_bonus()]
    S --> T[RewardCalculator.calculate_reward()]
    T --> U[TransactionService.process_daily_bonus()]
    U --> V[Supabase: Atomic Balance Update]
    V --> W[DailyBonusManager.mark_claimed()]
    W --> X[Analytics: Daily Claimed Event]
    X --> Y[Response: Reward + New Balance]

    Y --> Z[Task Execution Flow]
    Z --> AA[GET /api/tasks/list]
    AA --> BB[TasksController.get_list()]
    BB --> CC[TaskModel.get_available_tasks()]
    CC --> DD[Filter Completed Tasks]
    DD --> EE[Response: Available Tasks]

    EE --> FF[User Starts Task]
    FF --> GG[POST /api/tasks/start]
    GG --> HH[TasksController.start_task()]
    HH --> II[TaskModel.update_progress()]
    II --> JJ[VerificationService.schedule_check()]
    JJ --> KK[Response: Task Started + Timer]

    KK --> LL[User Completes Action]
    LL --> MM[POST /api/tasks/verify]
    MM --> NN[TasksController.verify_task()]
    NN --> OO[VerificationService.complete_verification()]
    OO --> PP{Verification Successful?}

    PP -->|Yes| QQ[TransactionService.process_task_reward()]
    PP -->|No| RR[Update Status: Failed]

    QQ --> SS[TaskModel.mark_completed()]
    SS --> TT[Analytics: Task Completed Event]
    TT --> UU[Response: Verified + Reward]

    UU --> VV[Wallet Connection Flow]
    VV --> WW[POST /api/wallet/connect]
    WW --> XX[WalletController.connect_wallet()]
    XX --> YY[TONConnectService.validate_address()]
    YY --> ZZ[WalletModel.create_connection()]
    ZZ --> AAA[TransactionService.wallet_bonus()]
    AAA --> BBB[TONConnectService.get_balances()]
    BBB --> CCC[Analytics: Wallet Connected Event]
    CCC --> DDD[Response: Connected + Bonus]

    DDD --> EEE[FLEX Rewards Flow]
    EEE --> FFF[GET /api/flex/levels]
    FFF --> GGG[FlexController.get_levels()]
    GGG --> HHH[TONConnectService.get_flex_balance()]
    HHH --> III[FlexRewards.calculate_available_levels()]
    III --> JJJ[Response: Available Levels]

    JJJ --> KKK[User Claims FLEX Reward]
    KKK --> LLL[POST /api/flex/claim]
    LLL --> MMM[FlexController.claim_reward()]
    MMM --> NNN[Validate FLEX Balance + Cooldown]
    NNN --> OOO[TransactionService.process_flex_reward()]
    OOO --> PPP[FlexRewards.set_cooldown()]
    PPP --> QQQ[Analytics: FLEX Claimed Event]
    QQQ --> RRR[Response: Claimed + Reward]
```

### 2. **Transaction Service Central Hub Architecture**
```mermaid
graph TD
    subgraph "Transaction Service Ecosystem"
        TS[Transaction Service Core]

        subgraph "Input Sources"
            DC[Daily Controller]
            FC[FLEX Controller]
            TC[Tasks Controller]
            WC[Wallet Controller]
            UC[User Controller]
        end

        subgraph "Core Methods"
            PR[process_reward()]
            PS[process_spending()]
            PDB[process_daily_bonus()]
            PFR[process_flex_reward()]
            PTR[process_task_reward()]
            PWB[process_wallet_bonus()]
        end

        subgraph "Data Layer"
            TM[Transaction Model]
            UM[User Model]
            DB[(Supabase Database)]
        end

        subgraph "Analytics & Monitoring"
            AE[Analytics Events]
            ML[Metrics Logging]
            AL[Audit Logging]
        end
    end

    DC --> PR
    FC --> PFR
    TC --> PTR
    WC --> PWB
    UC --> PS

    PR --> TM
    PFR --> TM
    PTR --> TM
    PWB --> TM
    PS --> TM

    TM --> DB
    UM --> DB

    TS --> AE
    TS --> ML
    TS --> AL

    style TS fill:#ff9999
    style DB fill:#99ccff
    style AE fill:#99ff99
```

### 3. **Security & Middleware Pipeline**
```mermaid
graph TD
    subgraph "Request Pipeline"
        A[HTTP Request] --> B[Rate Limiting Middleware]
        B --> C[Request Logging Middleware]
        C --> D[Security Headers Middleware]
        D --> E[CORS Middleware]
        E --> F[Flask Routes]

        F --> G[Route Decorators]
        G --> H[@secure_endpoint]
        H --> I[@validate_json]
        I --> J[@validate_telegram_id]
        J --> K[@require_auth]

        K --> L[JWT Token Validation]
        L --> M[Controller Function]
        M --> N[Business Logic]
        N --> O[Service Layer]
        O --> P[Model Layer]
        P --> Q[Database]

        Q --> R[Response]
        R --> S[Security Headers Added]
        S --> T[Metrics Recorded]
        T --> U[Request Logged]
        U --> V[HTTP Response]
    end

    subgraph "Security Validations"
        L --> AA[decode_jwt_token()]
        AA --> BB{Token Valid?}
        BB -->|Yes| CC[Extract User Context]
        BB -->|No| DD[401 Unauthorized]

        CC --> EE[IP Validation]
        EE --> FF[Fresh Token Check]
        FF --> MM[Set g.current_user]
    end

    subgraph "Rate Limiting"
        B --> GG[Determine Rule]
        GG --> HH[Generate Key]
        HH --> II[Check Limit]
        II --> JJ{Limit Exceeded?}
        JJ -->|Yes| KK[429 Too Many Requests]
        JJ -->|No| LL[Add Rate Headers]
    end

    style A fill:#ffcc99
    style V fill:#99ff99
    style DD fill:#ff9999
    style KK fill:#ff9999
```

### 4. **External Services Integration**
```mermaid
graph TD
    subgraph "WINIX Backend"
        subgraph "Services Layer"
            TS[Telegram Service]
            TON[TON Connect Service]
            VS[Verification Service]
            AS[Analytics Service]
        end

        subgraph "Controllers"
            AC[Auth Controller]
            TC[Tasks Controller]
            WC[Wallet Controller]
            FC[FLEX Controller]
        end
    end

    subgraph "External APIs"
        TG[Telegram Bot API]
        TB[TON Blockchain]
        FLEX[FLEX Smart Contract]
        YT[YouTube API]
        TW[Twitter API]
        DC[Discord API]
    end

    subgraph "Database & Cache"
        DB[(Supabase PostgreSQL)]
        RC[(Redis Cache)]
        MC[Memory Cache]
    end

    AC --> TS
    TS --> TG

    TC --> VS
    VS --> TS
    VS --> YT
    VS --> TW
    VS --> DC

    WC --> TON
    FC --> TON
    TON --> TB
    TON --> FLEX

    AS --> DB

    TS --> RC
    TON --> MC
    VS --> RC

    style TG fill:#0088cc
    style TB fill:#0066cc
    style FLEX fill:#00aa00
    style DB fill:#ff6600
    style RC fill:#cc0000
```

### 5. **Error Handling & Fallback Mechanisms**
```mermaid
graph TD
    subgraph "Primary Flow"
        A[Request] --> B[Controller]
        B --> C[Service Layer]
        C --> D[External API Call]
        D --> E{API Available?}
        E -->|Yes| F[Process Response]
        E -->|No| G[Trigger Fallback]

        F --> H[Update Database]
        H --> I[Success Response]
    end

    subgraph "Fallback Mechanisms"
        G --> J{Cache Available?}
        J -->|Yes| K[Use Cached Data]
        J -->|No| L[Use Default Values]

        K --> M[Partial Success Response]
        L --> N[Degraded Service Response]

        M --> O[Schedule Retry]
        N --> P[Log Error for Manual Review]
    end

    subgraph "Transaction Service Fallback"
        Q[Transaction Service Down] --> R[Use Direct DB Operations]
        R --> S[Manual Transaction Logging]
        S --> T[Queue for Later Sync]
        T --> U[Success with Warning]
    end

    subgraph "Database Fallback"
        V[Database Connection Lost] --> W[Switch to Read Replicas]
        W --> X{Replicas Available?}
        X -->|Yes| Y[Continue with Read-Only]
        X -->|No| Z[Cache-Only Mode]

        Y --> AA[Queue Write Operations]
        Z --> BB[Return Cached Responses]
    end

    style G fill:#ffaa00
    style Q fill:#ffaa00
    style V fill:#ff6600
    style I fill:#00aa00
    style U fill:#aaaa00
```

---

## 🚀 Deployment & Configuration

### **Environment Configuration**
```bash
# Production Environment Variables
ENVIRONMENT=production
DEBUG=false
SECRET_KEY=your-super-secret-key-here
JWT_SECRET_KEY=your-jwt-secret-key

# Database Configuration
SUPABASE_URL=https://your-project.supabase.co
SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_KEY=your-service-key

# Telegram Configuration
TELEGRAM_BOT_TOKEN=your-bot-token
TELEGRAM_BOT_USERNAME=your-bot-username

# TON Blockchain
TON_API_KEY=your-ton-api-key
TON_NETWORK=mainnet
FLEX_CONTRACT_ADDRESS=your-flex-contract-address

# Redis Configuration
REDIS_HOST=your-redis-host
REDIS_PORT=6379
REDIS_PASSWORD=your-redis-password

# Rate Limiting
RATE_LIMIT_ENABLED=true
RATE_LIMIT_STORAGE=redis

# Monitoring
LOG_LEVEL=INFO
ALERT_WEBHOOK_URL=your-alert-webhook

# Security
CORS_ORIGINS=https://your-frontend-domain.com
TRUSTED_PROXIES=10.0.0.0/8,172.16.0.0/12,192.168.0.0/16
```

### **Docker Configuration**
```dockerfile
# Dockerfile
FROM python:3.11-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    build-essential \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements and install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Create logs directory
RUN mkdir -p logs

# Set environment variables
ENV PYTHONPATH=/app
ENV FLASK_APP=main.py

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:5000/api/health || exit 1

# Expose port
EXPOSE 5000

# Run application
CMD ["gunicorn", "--bind", "0.0.0.0:5000", "--workers", "4", "--timeout", "120", "main:app"]
```

### **Docker Compose**
```yaml
# docker-compose.yml
version: '3.8'

services:
  winix-backend:
    build: .
    ports:
      - "5000:5000"
    environment:
      - ENVIRONMENT=production
      - REDIS_HOST=redis
    depends_on:
      - redis
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    restart: unless-stopped

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - winix-backend
    restart: unless-stopped

volumes:
  redis_data:
```

### **Production Monitoring Setup**
```python
# monitoring/prometheus.py
from prometheus_client import start_http_server, generate_latest
from flask import Response

def setup_prometheus_metrics(app):
    """Налаштування Prometheus метрик"""

    @app.route('/metrics')
    def metrics():
        """Prometheus metrics endpoint"""
        return Response(
            generate_latest(),
            mimetype='text/plain'
        )

    # Запуск Prometheus HTTP сервера
    start_http_server(8000)

# monitoring/grafana_dashboards.json
{
  "dashboard": {
    "title": "WINIX Backend Monitoring",
    "panels": [
      {
        "title": "Request Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(winix_requests_total[5m])",
            "legendFormat": "{{method}} {{endpoint}}"
          }
        ]
      },
      {
        "title": "Error Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(winix_requests_total{status=~'4..|5..'}[5m])",
            "legendFormat": "Errors"
          }
        ]
      },
      {
        "title": "Daily Bonus Claims",
        "type": "stat",
        "targets": [
          {
            "expr": "increase(winix_daily_bonus_claims_total[24h])",
            "legendFormat": "Claims Today"
          }
        ]
      }
    ]
  }
}
```

## 📈 Performance Optimization

### **Database Optimization**
```sql
-- Оптимізація індексів для частих запитів
CREATE INDEX CONCURRENTLY idx_winix_telegram_id ON winix(telegram_id);
CREATE INDEX CONCURRENTLY idx_transactions_user_created ON transactions(telegram_id, created_at DESC);
CREATE INDEX CONCURRENTLY idx_daily_bonus_user_date ON daily_bonus_entries(telegram_id, claimed_at DESC);
CREATE INDEX CONCURRENTLY idx_task_progress_user_status ON task_progress(telegram_id, status);
CREATE INDEX CONCURRENTLY idx_analytics_events_user_time ON analytics_events(user_id, timestamp DESC);

-- Партиціонування великих таблиць
CREATE TABLE analytics_events_y2024 PARTITION OF analytics_events
FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');

-- Materialized views для аналітики
CREATE MATERIALIZED VIEW user_daily_stats AS
SELECT
    telegram_id,
    DATE(created_at) as date,
    COUNT(*) as events_count,
    SUM(CASE WHEN event_type = 'daily' THEN 1 ELSE 0 END) as daily_claims
FROM analytics_events
GROUP BY telegram_id, DATE(created_at);

-- Автоматичне оновлення materialized views
CREATE OR REPLACE FUNCTION refresh_materialized_views()
RETURNS void AS $
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY user_daily_stats;
END;
$ LANGUAGE plpgsql;

-- Cronjob для оновлення кожні 15 хвилин
SELECT cron.schedule('refresh-stats', '*/15 * * * *', 'SELECT refresh_materialized_views();');
```

### **Cache Warming Strategy**
```python
# cache_warming.py
async def warm_critical_caches():
    """Попереднє завантаження критичних кешів"""

    # Топ-100 активних користувачів
    active_users = await get_most_active_users(limit=100)

    for user in active_users:
        # Завантаження основних даних в кеш
        asyncio.create_task(cache_user_data(user['telegram_id']))
        asyncio.create_task(cache_daily_status(user['telegram_id']))
        asyncio.create_task(cache_task_progress(user['telegram_id']))

        await asyncio.sleep(0.1)  # Throttling

async def cache_user_data(telegram_id: str):
    """Кешування даних користувача"""
    user = get_user(telegram_id)
    if user:
        cache_manager.set(f"user:{telegram_id}", user, ttl=300)

# Запуск cache warming при старті додатку
@app.before_first_request
def setup_cache_warming():
    asyncio.create_task(warm_critical_caches())
```

---

## 🔧 Maintenance & Operations

### **Database Maintenance Scripts**
```python
# maintenance/db_cleanup.py
async def cleanup_old_data():
    """Очищення застарілих даних"""

    # Видалення старих analytics events (старше 90 днів)
    cutoff_date = datetime.now() - timedelta(days=90)

    deleted_count = supabase.table('analytics_events')\
        .delete()\
        .lt('timestamp', cutoff_date.isoformat())\
        .execute()

    logger.info(f"Cleaned up {len(deleted_count.data)} old analytics events")

    # Архівування старих транзакцій
    await archive_old_transactions(cutoff_date)

    # Очищення expired rate limit entries
    cache_manager.clear_pattern("rate_limit:*")

async def optimize_database():
    """Оптимізація бази даних"""

    # Vacuum та reindex
    maintenance_queries = [
        "VACUUM ANALYZE winix;",
        "VACUUM ANALYZE transactions;",
        "VACUUM ANALYZE analytics_events;",
        "REINDEX TABLE CONCURRENTLY winix;",
        "UPDATE pg_stat_statements SET calls = 0, total_time = 0;"
    ]

    for query in maintenance_queries:
        try:
            await execute_maintenance_query(query)
            logger.info(f"Executed: {query}")
        except Exception as e:
            logger.error(f"Failed to execute {query}: {e}")

# Cron jobs
# 0 2 * * * python maintenance/db_cleanup.py
# 0 3 * * 0 python maintenance/db_optimize.py
```

### **Health Monitoring & Alerting**
```python
# monitoring/health_checks.py
class HealthMonitor:
    def __init__(self):
        self.checks = {
            'database': self.check_database,
            'redis': self.check_redis,
            'external_apis': self.check_external_apis,
            'disk_space': self.check_disk_space,
            'memory_usage': self.check_memory_usage
        }

    async def run_all_checks(self) -> Dict[str, Any]:
        """Виконання всіх health checks"""
        results = {}

        for name, check_func in self.checks.items():
            try:
                start_time = time.time()
                result = await check_func()
                duration = time.time() - start_time

                results[name] = {
                    'status': 'healthy' if result else 'unhealthy',
                    'duration': duration,
                    'timestamp': time.time()
                }
            except Exception as e:
                results[name] = {
                    'status': 'error',
                    'error': str(e),
                    'timestamp': time.time()
                }

        return results

    async def check_database(self) -> bool:
        """Перевірка стану бази даних"""
        try:
            result = supabase.table('winix').select('id').limit(1).execute()
            return len(result.data) >= 0
        except:
            return False

    async def check_external_apis(self) -> bool:
        """Перевірка зовнішніх API"""
        try:
            telegram_ok = await telegram_service.health_check()
            ton_ok = await ton_connect_service.health_check()
            return telegram_ok and ton_ok
        except:
            return False

    def check_disk_space(self) -> bool:
        """Перевірка місця на диску"""
        disk_usage = psutil.disk_usage('/')
        return disk_usage.percent < 90  # Alert if > 90%

    def check_memory_usage(self) -> bool:
        """Перевірка використання пам'яті"""
        memory = psutil.virtual_memory()
        return memory.percent < 85  # Alert if > 85%

# Automated alerting
async def monitor_and_alert():
    """Автоматичний моніторинг з алертами"""
    health_monitor = HealthMonitor()

    while True:
        try:
            health_results = await health_monitor.run_all_checks()

            # Перевірка критичних проблем
            critical_issues = [
                name for name, result in health_results.items()
                if result['status'] in ['unhealthy', 'error']
            ]

            if critical_issues:
                await send_critical_alert(critical_issues, health_results)

            # Логування стану
            logger.info("Health check completed", extra={
                'healthy_services': len([r for r in health_results.values() if r['status'] == 'healthy']),
                'total_services': len(health_results),
                'critical_issues': critical_issues
            })

        except Exception as e:
            logger.error(f"Health monitoring error: {e}")

        await asyncio.sleep(60)  # Перевірка кожну хвилину

async def send_critical_alert(issues: List[str], health_data: Dict):
    """Відправка критичного алерту"""
    alert_data = {
        'severity': 'critical',
        'service': 'winix-backend',
        'issues': issues,
        'timestamp': time.time(),
        'health_data': health_data
    }

    # Відправка в Slack/Discord/Email
    webhook_url = os.getenv('ALERT_WEBHOOK_URL')
    if webhook_url:
        async with aiohttp.ClientSession() as session:
            await session.post(webhook_url, json=alert_data)
```

---

## 📊 Analytics & Business Intelligence

### **Advanced Analytics Models**
```python
# analytics/business_intelligence.py
class BusinessIntelligence:
    """Розширена бізнес-аналітика"""

    def __init__(self):
        self.db = supabase_client

    async def get_user_engagement_metrics(self, days: int = 30) -> Dict:
        """Метрики залученості користувачів"""

        # Daily Active Users (DAU)
        dau_query = """
        SELECT DATE(timestamp) as date, COUNT(DISTINCT user_id) as dau
        FROM analytics_events
        WHERE timestamp >= NOW() - INTERVAL '%s days'
        GROUP BY DATE(timestamp)
        ORDER BY date DESC
        """ % days

        # Retention analysis
        retention_query = """
        WITH first_login AS (
            SELECT user_id, MIN(DATE(timestamp)) as first_date
            FROM analytics_events
            WHERE event_type = 'auth'
            GROUP BY user_id
        ),
        user_activity AS (
            SELECT
                fl.user_id,
                fl.first_date,
                DATE(ae.timestamp) as activity_date,
                DATE(ae.timestamp) - fl.first_date as days_since_first
            FROM first_login fl
            JOIN analytics_events ae ON fl.user_id = ae.user_id
            WHERE ae.timestamp >= NOW() - INTERVAL '%s days'
        )
        SELECT
            days_since_first,
            COUNT(DISTINCT user_id) as retained_users
        FROM user_activity
        WHERE days_since_first IN (1, 7, 14, 30)
        GROUP BY days_since_first
        ORDER BY days_since_first
        """ % days

        return {
            'dau': await self._execute_query(dau_query),
            'retention': await self._execute_query(retention_query)
        }

    async def get_revenue_analytics(self) -> Dict:
        """Аналітика 'доходів' (віртуальних винагород)"""

        revenue_query = """
        SELECT
            DATE(created_at) as date,
            transaction_type,
            SUM(winix_amount) as total_winix,
            SUM(tickets_amount) as total_tickets,
            COUNT(*) as transaction_count
        FROM transactions
        WHERE created_at >= NOW() - INTERVAL '30 days'
            AND winix_amount > 0
        GROUP BY DATE(created_at), transaction_type
        ORDER BY date DESC, transaction_type
        """

        top_earners_query = """
        SELECT
            telegram_id,
            SUM(winix_amount) as total_earned,
            COUNT(*) as transactions_count
        FROM transactions
        WHERE created_at >= NOW() - INTERVAL '30 days'
            AND winix_amount > 0
        GROUP BY telegram_id
        ORDER BY total_earned DESC
        LIMIT 50
        """

        return {
            'daily_revenue': await self._execute_query(revenue_query),
            'top_earners': await self._execute_query(top_earners_query)
        }

    async def get_task_performance_analytics(self) -> Dict:
        """Аналітика продуктивності завдань"""

        task_completion_query = """
        SELECT
            task_type,
            COUNT(*) as total_attempts,
            SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as completed,
            AVG(CASE WHEN status = 'completed' THEN
                EXTRACT(EPOCH FROM (updated_at - created_at))/60
                ELSE NULL END) as avg_completion_time_minutes
        FROM task_progress
        WHERE created_at >= NOW() - INTERVAL '30 days'
        GROUP BY task_type
        ORDER BY total_attempts DESC
        """

        funnel_analysis_query = """
        WITH task_funnel AS (
            SELECT
                task_id,
                COUNT(CASE WHEN status = 'started' THEN 1 END) as started,
                COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed,
                COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed
            FROM task_progress
            WHERE created_at >= NOW() - INTERVAL '30 days'
            GROUP BY task_id
        )
        SELECT
            task_id,
            started,
            completed,
            failed,
            CASE WHEN started > 0 THEN
                ROUND((completed::FLOAT / started) * 100, 2)
                ELSE 0 END as completion_rate
        FROM task_funnel
        WHERE started > 10  -- Only tasks with significant attempts
        ORDER BY completion_rate DESC
        """

        return {
            'task_performance': await self._execute_query(task_completion_query),
            'conversion_funnel': await self._execute_query(funnel_analysis_query)
        }

# Automated reporting
async def generate_daily_report():
    """Генерація щоденного звіту"""
    bi = BusinessIntelligence()

    report_data = {
        'date': datetime.now().isoformat(),
        'engagement': await bi.get_user_engagement_metrics(7),
        'revenue': await bi.get_revenue_analytics(),
        'tasks': await bi.get_task_performance_analytics()
    }

    # Збереження звіту
    report_filename = f"reports/daily_report_{datetime.now().strftime('%Y%m%d')}.json"

    with open(report_filename, 'w') as f:
        json.dump(report_data, f, indent=2, default=str)

    logger.info(f"Daily report generated: {report_filename}")

    return report_data

# Cron job: 0 9 * * * python analytics/generate_reports.py
```

---

Ця повна архітектурна документація надає детальний огляд кожного компонента backend системи WINIX, включаючи взаємодії, security patterns, deployment стратегії, моніторинг та бізнес-аналітику. Система побудована з урахуванням масштабованості, надійності та підтримуваності! 🚀